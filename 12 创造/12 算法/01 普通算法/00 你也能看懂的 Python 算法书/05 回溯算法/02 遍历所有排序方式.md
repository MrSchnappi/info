---
title: 02 遍历所有排序方式
toc: true
date: 2019-07-01
---
6.2 遍历所有排序方式
小朗朗最近有 4 本想读的书：《红色的巴黎》《黄色的梧桐树》《蓝色的夏天》《绿色的天空》。如果小朗朗一次只能从图书馆借一本书，他一共有多少种借书的顺序呢？如果学过统计学的话，你会知道 4 本书一共有 4!=24种不同的排序方式。但是，我们不只想知道这个总数，还想一一输出所有的排序方式。
图 6.2 小朗朗想读的 4 本书
6.2.1 问题求解
我们来模拟一下一般是怎么排序的，如图 6.3所示。我们把 4 本书放入 4 个空位中。首先，第一个空位有 4 个选择：红、黄、蓝、绿。
假设第一本书是《红色的巴黎》，如图 6.4所示，那么第二本书剩下 3 个选择：黄，蓝，绿。
图 6.3 排位顺序
图 6.4 假设第一本书
假设第二本书是《黄色的梧桐树》，如图 6.5所示，那么第三本书剩下两个选择：蓝，绿。
图 6.5 假设第二本书
最后，假设第三本书是《蓝色的夏天》，如图 6.6所示。那么第四本书只能是《绿色的天空》，如图 6.7所示。
图 6.6 假设第三本书
图 6.7 假设第四本书
这是 24 种排序方式中的一种。我们也可以使第一本书是《黄色的梧桐树》，或者第二本书是《蓝色的夏天》，从而得出不同的排序方式。注意，第一本书有 4 种选择，第二本书有 3 种选择，第三本书有 2 种选择，第四本书只有 1 种选择，因为每一次都要把上一本书从我们的选择中剔除。
按照上面的解题思路，如果不用回溯可以这样写代码：
如果这样写代码你会发现有一个问题，那就是你需要提前知道数组的长度。另外一个问题就是代码十分累赘。


图 6.8 重复的代码
观察一下图 6.8，代码是一环套一环的，每一环都是重复的。排第一本书的时候，有 4 种选择，答案集合就是这 4 种选择在各结尾增加剩下的三本书的排序集合。那么，只需要得出剩余的三本书的排序集合就可以了。
同样的，排这三本书时第一本书有三种选择，所以只需要得出剩余的两本书的排序集合就可以了。那么，推到最后，我们排两本书时，只需要知道最后一本是什么就可以了。
其实就是一个大的问题套着中的问题再套着小的问题，问题都是一样的：输出排序集合。唯一不同的是书本和书本的数量。
6.2.2 最终代码
我们定义一个 helper 方法来帮助概括这些重复的代码。代码 6.1所示的是 helper 方法的完整代码，下面我们会详细进行介绍。
01 def helper（self,array,solution）:
代码 6.1 helper方法
02　　　 if len（array）==0:　　　　　　　　　 #如果没有剩余书籍
03　　　　　print（solution）　　　　　　　　 #输出结果
04　　　　　return　　　　　　　　　　　　　 #返回上一级
05　　　 for i in range（len（array））:　　　　#遍历书籍
06　　　　　newSolution=solution+[array[i]]　 #新建排序列表
07　　　　　newArray=array[:i]+array[i+1:]　　#新建书籍列表
08　　　　　self.helper（newArray,newSolution）　 #回溯
我们先来看一下 helper 方法的参数：
array，存储当前排序对象的列表，比如[红，黄，蓝，绿],[黄，蓝，绿],[蓝，绿],[绿]。
solution，存储当前排序组合的列表，比如[红],[红，黄],[红，黄，蓝],[红，黄，蓝，绿]。
接下来我们看一下 helper 方法履行的任务。
1.把第一本书的选择加入排序列表。注意：我们这里的“第一本书”不一定指 4 本书中的第一本，而是代指剩余书籍中的“第一本书”。
第一次调用 helper 方法时，排第一书有 4 种选择，那么依次把这 4 个选择加入排序列表。所以，新的排序列表是[红],[黄],[蓝],[绿]。
第二次调用 helper 方法时，排第一书我们有 3 种选择，仍然依次把这三本书加入列表。所以，新的排序列表是[红，黄],[红，蓝],[红，绿],[黄，红],[黄，蓝],[黄，绿],[蓝，红],[蓝，黄],[蓝，绿],[绿，红],[绿，黄],[绿，蓝]。注意：每加一本书就需创建新的排序列表，因为不同的选择不能同时存在，任一本书当第一本书都是一种新的排序方式。
2.把加入的书本从 array 中删除。
书已经被排过就不再是一个选择了。我们借的第一本书不再是第二本书的选择之一，所以需要把第一本书从排序对象列表中删除。
04　　　　　newArray=array[:i]+array[i+1:]　　　　　#删除书本
需要创建一个新的对象列表，因为每一次我们删除的书籍都是不一样的。
3.寻找剩余书本的排序组合。
05　　　　　self.helper（newArray,newSolution）　　 #寻找剩余对象的排序集合
找出第一本书的选择后，只要找到剩余书本的排序集合，把它们加到第一本书后面就可以了。也就是说，需要再次调用 helper 方法，传入新的排序集合和新的对象集合。这样，下一次的“第一本书”其实就是这次的“第二本书”。
4.检查是否得出排序方式。
如果不加上一个终止条件的话，helper方法不会知道什么时候输出结果。所以需要在一开始就加上 if 判断条件，如果没有排序对象了就输出结果，并返回上一次调用它的地方。
01 def helper（self,array,solution）:
02　　　 if len（array）==0:　　　　　　　　#如果没有剩余排序对象
03　　　　　print（solution）　　　　　　　#输出结果
04　　　　　return　　　　　　　　　　　　#返回上一次被调用的地方


返回上一级后，因为最后一本书只有一种选择，所以 helper 方法会再次返回上一次调用它的地方，也就是排倒数第二本书的地方。走完第二本书的 for 循环后，会返回到倒数第三本书的地方，依次类推，一直到第一本书。
有了 helper 方法，只需要调用它就可以解决排序问题了。
01 def solvePermutation（self,array）:
02　 self.helper（array,[]）　　　　　　　#调用 helper 方法注意：因为我们还没有开始排序，所以第一次调用 helper 方法时传入的排序列表为空。
下面来看一下完整的代码，如代码 6.2所示。
代码 6.2 用回溯算法解决排序问题
来试一下排序小朗朗的 4 本书：
Solution（）.solvePermutation（[＂红＂,＂黄＂,＂蓝＂,＂绿＂]）
以下是输出结果：
[＇红＇,＇黄＇,＇蓝＇,＇绿＇]
[＇红＇,＇黄＇,＇绿＇,＇蓝＇]
[＇红＇,＇蓝＇,＇黄＇,＇绿＇]
[＇红＇,＇蓝＇,＇绿＇,＇黄＇]
[＇红＇,＇绿＇,＇黄＇,＇蓝＇]
[＇红＇,＇绿＇,＇蓝＇,＇黄＇]
[＇黄＇,＇红＇,＇蓝＇,＇绿＇]
[＇黄＇,＇红＇,＇绿＇,＇蓝＇]
[＇黄＇,＇蓝＇,＇红＇,＇绿＇]
[＇黄＇,＇蓝＇,＇绿＇,＇红＇]
[＇黄＇,＇绿＇,＇红＇,＇蓝＇]
[＇黄＇,＇绿＇,＇蓝＇,＇红＇]
[＇蓝＇,＇红＇,＇黄＇,＇绿＇]
[＇蓝＇,＇红＇,＇绿＇,＇黄＇]
[＇蓝＇,＇黄＇,＇红＇,＇绿＇]
[＇蓝＇,＇黄＇,＇绿＇,＇红＇]
[＇蓝＇,＇绿＇,＇红＇,＇黄＇]
[＇蓝＇,＇绿＇,＇黄＇,＇红＇]
[＇绿＇,＇红＇,＇黄＇,＇蓝＇]
[＇绿＇,＇红＇,＇蓝＇,＇黄＇]
[＇绿＇,＇黄＇,＇红＇,＇蓝＇]
[＇绿＇,＇黄＇,＇蓝＇,＇红＇]
[＇绿＇,＇蓝＇,＇红＇,＇黄＇]
[＇绿＇,＇蓝＇,＇黄＇,＇红’]
