---
title: 102 数值类型 3 浮点数 float
toc: true
date: 2018-08-19
---
# 可以补充进来的

- nan 是什么？是 None 吗？

# 浮点数

浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如， 1.23x10^9和 12.3x10^8 是完全相等的。

## 浮点数的表示

浮点数可以用数学写法，如`1.23`，`3.14`，`-9.01`，等等。

对于很大或很小的浮点数，可以用科学计数法表示：把 10 用 e 替代，1.23x10^9就是`1.23e9`，或者`12.3e8`，0.000012可以写成`1.2e-5`，等等。


## 浮点数的大小限制

IEEE 754 的特殊值是 NaN, inf, -inf。

Python 的浮点数没有大小限制，但是超出一定范围就直接表示为`inf`（无限大）。

举例如下：

```py
a=1e100000000
b=1e10000000
print(a)
print(type(a))
print(b)
print(type(b))
print(a/b)
print(type(a/b))

print('---')
a=1e1000
b=1e100
print(a)
print(type(a))
print(b)
print(type(b))
print(a/b)
print(type(a/b))
```

输出：

```
inf
<class 'float'>
inf
<class 'float'>
nan
<class 'float'>
---
inf
<class 'float'>
1e+100
<class 'float'>
inf
<class 'float'>
```

可见，当变为 inf 后，即使除以一个很大的数，也会变成 nan 或者 inf，而不是一个计算结果。

## 浮点数的存储误差及引出的问题

整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的。<span style="color:red;">除法作为计算中间步骤也是精确的吗？还是有误差的？</span>

而浮点数运算则可能会有四舍五入的误差。为啥呢？原因如下：


不管是什么数，在计算机中最终都会被转化为 0 和 1 进行存储，所以需要弄明白以下几点问题：

### 一个小数如何转化为二进制浮点数的

浮点数的二进制表示首先我们要了解浮点数二进制表示，有以下两个原则:整数部分对 2 取余然后逆序排列小数部分乘 2 取整数部分，然后顺序排列

0.1 的表示是什么?我们继续按照浮点数的二进制表示来计算

- 0.1 * 2 = 0.2 整数部分取 0
- 0.2 * 2 = 0.4 整数部分取 0
- 0.4 * 2 = 0.8 整数部分取 0
- 0.8 * 2 = 1.6 整数部分取 1
- 0.6 * 2 = 1.2 整数部分取 1
- 0.2 * 2 = 0.4 整数部分取 0

…所以你会发现，0.1 的二进制表示是 0.00011001100110011001100110011……0011


0011 作为二进制小数的循环节不断的进行循环.这就引出了一个问题，你永远不能存下 0.1 的二进制，即使你把全世界的硬盘都放在一起，也存不下 0.1 的二进制小数.

那么我们平时用的二进制的浮点数是怎么储存的呢？

### 二进制如何存储

浮点数的二进制存储 Python 和 C 一样，采用 [IEEE 754](https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF) 规范来存储浮点数：

对双精度浮点数的存储规范将 64 bit 分为 3 部分：

- 第 1 bit 位用来存储符号，决定这个数是正数还是负数
- 然后使用 11 bit 来存储指数部分
- 剩下的 52 bit 用来存储尾数。

<center>

![mark](http://images.iterate.site/blog/image/20191109/qnPub6MMS3y3.png?imageslim)

</center>

而且可以指出的是，double 能存储的数的个数是有限的，double 能代表的数必然不超过 2^64 个，那么现实世界上有多少个小数呢？无限个。

所以计算机能做的只能是一个接近这个小数的值，是这个值在一定精度下与逻辑认为的值相等。换句话说，每个小数的存储(但是不是所有的)，都会伴有精度的丢失。<span style="color:red;">是这样吗？那岂不是说有些浮点数在计算机里存放的时候，实际是相等的？那银行的计算是怎么做的？</span>

### 存储的精度误差会导致的问题


由于浮点数的存储误差，所以，会出现计算上的问题：

举例：

```py
print(0.1+0.2)
print(0.1+0.2==0.3)
```

输出：

```
0.30000000000000004
False
```

原因就是：

- 0.1 在计算机存储中真正的数字是 0.1000000000000000055511151231257827021181583404541015625
- 0.2 是 0.200000000000000011102230246251565404236316680908203125
- 0.3 是 0.299999999999999988897769753748434595763683319091796875

这就是为什么 0.1 + 0.2 != 0.3 的原因。

## 浮点数比较

那么，既然0.1 + 0.2 != 0.3，怎么判断两个浮点数是不是相等呢？

原则如下：

- 只能用 `>` `<` 不可用 `==`
- 如果需要判断是否相等，可以用 `math.isclose(a,b)` 或者 `abs(a-b) < 1.0e-9`



# 相关

- [数据类型和变量](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431658624177ea4f8fcb06bc4d0e8aab2fd7aa65dd95000)
- [为什么 0.1+0.2=0.30000000000000004而 1.1+2.2=3.3000000000000003？](https://www.zhihu.com/question/28551135).
