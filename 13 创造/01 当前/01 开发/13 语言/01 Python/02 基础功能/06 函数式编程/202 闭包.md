---
title: 202 闭包
toc: true
date: 2019-02-05
---
# 可以补充进来的

- 补充例子


# 闭包

注意到返回的函数在其定义内部引用了局部变量`args`。

所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。

另一个需要注意的问题是，**返回的函数并没有立刻执行，而是直到调用了`f()`才执行。**

举例：

```py
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()

print(f1())
print(f2())
print(f3())
```

输出：

```
9
9
9
```

说明：

- 上面的例子中，每次循环，都创建了一个新的函数，然后返回创建的 3 个函数。
- 你可能认为调用`f1()`，`f2()`和`f3()`结果应该是`1`，`4`，`9`，但实际结果全部都是`9`！为什么呢？原因就在于 **返回的函数引用了变量 `i`，但它并非立刻执行。** 等到 3 个函数都返回时，它们所引用的变量 `i` 已经变成了 `3`，因此最终结果为 `9`。

## 闭包存在的问题及对应

因此，注意：

- **返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。**<span style="color:red;">是的，这个要注意的，返回函数不要饮用任何循环变量，或者后续会发生变化的变量。</span> 因为返回的函数不是立即执行的，而是当调用的时候执行的，这时候如果里面的用到的参数变更了，那么以变更后的值进行执行。

如果一定要引用循环变量怎么办？

方法是**再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变**。

举例：

```py
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此 i 的当前值被传入 f()
    return fs

f1, f2, f3 = count()

print(f1())
print(f2())
print(f3())
```

输出：

```
1
4
9
```

缺点是代码较长，可利用 lambda 函数缩短代码。


# 原文及引用

- [返回函数](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431835236741e42daf5af6514f1a8917b8aaadff31bf000)
00)
