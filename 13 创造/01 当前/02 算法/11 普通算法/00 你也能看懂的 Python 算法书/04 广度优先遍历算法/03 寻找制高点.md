---
title: 03 寻找制高点
toc: true
date: 2019-07-01
---
# 寻找制高点

又到了春暖花开的季节，学校组织同学们去爬香山。小朗朗和小伙伴们约定要走遍所有的制高点，他们找到了香山的地图开始分析要“占领”哪些山头。他们拿到的地图是一张海拔图，上面有每个地理位置的海拔高度数据。为了描述这张地图，我们同样使用一个 M×N的二维数组来表示，每个点的海拔用数字来表示，如表 5.5所示。

<center>

![](http://images.iterate.site/blog/image/20190701/tkuqtzoDSTqk.png?imageslim){ width=55% }

</center>


那么，我们来看一下小朗朗想找的制高点是什么样的，制高点是可以一直向下到达东西南北四个方向的点。在向下走的过程中是不能爬坡的，也就是说，只能向比当前点低的点或者和当前点一样高的点的方向走。同时，走的过程中只允许向上下左右四个方向走，例如图中的 7 点、6点和第 2 行第 3 列的 5 点就是制高点，它们可以通过图中带下画线的点走到四个边缘点。部分示例如表 5.6和表 5.7所示。

<center>

![](http://images.iterate.site/blog/image/20190701/pNkiIg1RVox2.png?imageslim){ width=55% }

</center>


<center>

![](http://images.iterate.site/blog/image/20190701/CnnreR0NGyep.png?imageslim){ width=55% }

</center>




## 问题求解

这个问题其实是典型的搜索问题，拿到这个问题后，最开始想的肯定是从每个点出发来搜索是否能到达四个边缘。但是，不像迷宫问题，搜索的目标点不是一个单点，而是所有的边缘点，按照这种思路显然是效率很低的。

那么，如何来优化算法呢？这条思路不通，那么就换一个角度考虑问题，既然从每个点向边缘走效率会比较低，那么以边缘作为起点向内部开始遍历搜索，看下一个节点的高度是否高于或者等于自身的高度（就是可以从那点走到自身的点）。

然后标记那些能够到达的点为 True，继续搜索下去，直到不能走为止。按照同样的思路分别标记从四个边缘出发可以到达的点，那么最终四者均为 True 的点，就是我们寻找的制高点。这个问题是典型的逆向思维，有时候我们需要学会用逆向思维来思考问题。<span style="color:red;">哇塞，是呀。</span>

为了标识地图上的每一个点，我们需要为这些点定义坐标。对于平面坐标来说，左上角的点为（0,0），右下角的点为（m-1,n-1），如表 5.8所示。

<center>

![](http://images.iterate.site/blog/image/20190701/iTBLMYxyFo4H.png?imageslim){ width=55% }

</center>


有了上面的分析，就可以开始写代码了。首先，我们的已知数据就是这张地图，也就是一个二维数组。代码框架应该是这样的：

为了更好地表示可以移动的方向，同样使用一个二维数组来存储上下左右四个方向。这个技巧在以后的问题中会多次使用。

```
01 dir=[[0,1],[0,-1],[1,0],[-1,0]]　　　　 #数组中四个元素代表四个方向注意：[0,1]表示在二维坐标中，x坐标+0,y坐标+1，即向下移动。
```

为了方便理解，先定义两个变量来存储二维数组的大小：

```
01　m=len（matrix）　　　　　　#表示二维数组有多少行
02　n=len（matrix[0]）　　　　 #表示二维数组有多少列
```



接下来，以从山的北边上山为例来寻找制高点，有了第一个问题“选课的智慧”的基础后，我们知道队列是完成广度优先遍历必备的数据结构。所以，先把第一行的点全部加入队列，然后就可以开始进行广度优先遍历了：

```
01 topPoint=[（0,y）for y in range（n）]
```

由于从上下左右四个方向上山都是同一个子问题，因此最好把广度优先遍历写成一个函数，广度优先遍历的代码模板如下：

广度优先遍历算法的步骤是从队头取出一个点，然后从该点出发，通过方向数组建立新的点，查询这些点是否可以到达。记录可以到达的点，同时把新点加入队列。为了保存那些可以到达的点，需要在广度优先遍历之前，建立一个队列的副本。在 python 中，list（）函数可以把将元组转换为列表，通过 list（）函数建立 set 的一个副本，作为新的队列：

```
01 queue=list（set）
```

我们使用 queue 来做广度优先遍历，set用来存储可以到达的点。广度优先遍历算法的代码如下：



经过上面的广度优先遍历，可以得到从某一个方向出发可以到达的点，那么我们执行四次，就可以得到四个方向的结果了。为了后面的集合运算，我们使用 set（）函数来把列表转换为集合：注意：set（）函数接收一个列表，输出一个集合。

从四个方向上山，可以得到四个集合，分别为：

集合和数组很像，它和数组的区别是集合内部没有重复的数据。根据上面的分析，最终的制高点应该为四个集合的交集，也就是说，从哪个方向都可以一直向上的上山的点。


再经过交集的计算就可以到最终的制高点了，一共有三个制高点。


## 集合

上面程序中`&`的作用就是求集合的交集。使用交集运算，省去了循环遍历四个数组来寻找相同的点的过程。只需要一个语句，就可以得到结果，非常神奇！它是怎么得到结果的呢？假如你早饭吃了包子、粥和鸡蛋，午饭吃了包子、烤鸭、臭豆腐，那么早饭和午饭这两个集合的交集就是包子，如图 5.7所示。

<center>

![](http://images.iterate.site/blog/image/20190701/sEBHvGklSE9g.png?imageslim){ width=55% }

</center>


## 最终代码

综合上面的代码，可以形成最终的程序，如代码 5.2所示。

```py
def bfs(set, m, n, matrix):  # queue为队列
    dir = [[0, 1], [0, -1], [1, 0], [-1, 0]]  # 数组中四个元素代表四个方向
    queue = list(set)  # list()函数创建 queue 为 set 的数列版本
    while len(queue) > 0:
        x, y = queue.pop()  # 取出队头的元素，由于是一个坐标，我们使用两个变量来接收
        for d in dir:  # 循环遍历 4 个方向
            nx = x + d[0]
            ny = y + d[1]
            if 0 <= nx and nx < m and 0 <= ny and ny < n:  # 如果新的点在二位数组内
                if matrix[nx][ny] >= matrix[x][y]:  # 如果新的点比原点高则可以走
                    if (nx, ny) not in set:
                        queue.append((nx, ny))
                        set.add((nx, ny))


def solve(matrix):  # 其中 matrix 就是存储地图的二维数组
    if not matrix:
        return matrix  # 如果二维数组为空那么就返回空
    m = len(matrix)  # 表示二维数组有多少行
    n = len(matrix[0])  # 表示二维数组有多少列
    topPoint = set([(0, y) for y in range(n)])  # 上边的点横坐标为 0，纵坐标为 0 到 n-1
    leftPoint = set([(x, 0) for x in range(m)])  # 左边的点横坐标为 0 到 m-1，纵坐标为 0
    bottomPoint = set([(m - 1, y) for y in range(n)])  # 下边的点横坐标为 m-1，纵坐标为 0 到 n-1
    rightPoint = set([(x, n - 1) for x in range(m)])  # 右边的点横坐标为 0 到 m-1，纵坐标为 n-1
    bfs(topPoint, m, n, matrix)  # 依次调用 4 次 bfs
    bfs(leftPoint, m, n, matrix)
    bfs(bottomPoint, m, n, matrix)
    bfs(rightPoint, m, n, matrix)
    result = topPoint & leftPoint & bottomPoint & rightPoint  # 求集合的交集
    return result


matrix = [[1, 3, 2, 3, 5],  # 测试程序
          [3, 4, 5, 6, 3],
          [2, 7, 4, 3, 3],
          [5, 2, 2, 3, 1]]
s = solve(matrix)
print(s)

```



广度优先遍历本质上是查找算法。为了解决查找问题，之前我们介绍了很多查找算法，例如顺序查找、二分查找、哈希查找。广度优先遍历更多地针对图的搜索，除此之外，广度优先搜索可以解决单一起点的最短路径问题，图和最短路径问题在最后一章会有详细讲解。
