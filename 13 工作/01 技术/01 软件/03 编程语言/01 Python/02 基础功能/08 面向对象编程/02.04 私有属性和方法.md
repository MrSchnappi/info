## 私有属性和方法


- 私有属性：`__private_attrs`：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 `self.__private_attrs`。
- 私有方法：`__private_method`：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用`self.__private_methods`


- 有些时候，你会看到以一个下划线开头的实例变量名，比如`_name`，这样的实例变量外部是可以访问的，但是，**按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。**<span style="color:red;">好吧，还搞得这么复杂，为什么这种情况会存在？</span>


举例：

```python
class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0  # 公开变量

    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print(self.__secretCount)



counter = JustCounter()
counter.count()
counter.count()
print(counter.publicCount)
print('--')
print(counter._JustCounter__secretCount)
print(counter.__secretCount)# 报错，实例不能访问私有变量
```


输出：

```
1
2
2
--
2
Traceback (most recent call last):
  File "D:/21.Practice/demo/d.py", line 16, in <module>
    print(counter.__secretCount)# 报错，实例不能访问私有变量
AttributeError: 'JustCounter' object has no attribute '__secretCount'
```

可见：

- Python不允许实例化的类访问私有数据，但你可以使用 `counter._JustCounter__secretCount` 来访问私有数据。强烈建议你不要这么访问，**因为不同版本的 Python 解释器可能会把 `__name` 改成不同的变量名。**

一个有问题的例子：

```py
class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def get_name(self):
        return self.__name

bart = Student('Bart Simpson', 59)
print(bart.get_name())

bart.__name = 'New Name'
print(bart.__name)

print(bart.get_name())
```

输出：

```
Bart Simpson
New Name
Bart Simpson
```

说明：

- 外部代码设置了一个`__name`变量，但 **实际上这个`__name`变量和 class 内部的`__name`变量不是一个变量！** 因为内部的`__name`变量已经被 Python 解释器自动改成了`_Student__name`，而外部代码给`bart`新增了一个`__name`变量。
