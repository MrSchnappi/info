---
title: 04 猜词游戏
toc: true
date: 2019-06-26
---
# 猜词游戏

小朗朗在和他的好朋友多多玩猜数字（Bulls and Cows）游戏。这个游戏的玩法是这样的：一个人写下几个数字让另外一人猜，当每次答题方猜完之后，出题方会给答题方一个提示，告诉他刚才的猜测中有多少位数字和确切位置都猜对了（称为“Bulls”，公牛），还有多少位数字猜对了但是位置不对（称为“Cows”，奶牛）。答题方将会根据出题方的提示继续猜，直到猜出秘密数字为止。

可以保证的是，秘密数字和猜测数字的位数是一样的。

我们需要写一个程序，它能够根据秘密数字和朋友的猜测数返回提示，其中用 A 表示公牛，用 B 表示奶牛。

请注意秘密数字和朋友的猜测数字都可能含有重复数字。

例如秘密数字为 2018，猜测数字为 8021，由于 0 这个数不仅数字猜对了，位置也和秘密数字一致，所以它算一个公牛（A），而其他三位都是数字猜对了，但是位置不对，所以只能算是奶牛（B），我们的程序应该返回 1A3B，如图 3.13所示。

<center>

![](http://images.iterate.site/blog/image/20190701/CQKmex0vmVxg.png?imageslim){ width=55% }
</center>

再比如，秘密数字为 1123，猜测数字为 9111，由于 9111 中的第一个 1 不仅数字猜对了，位置也和秘密数字一致，所以它算一个公牛（A），而其他两个 1 是数字猜对了，但是位置不对，所以只能算是奶牛（B），而且只能算一个，因为一旦秘密数字中的某一位和猜测中的某一位匹配，该数就不能和其他数字匹配了。<span style="color:red;">哦，如果某一位和猜测中的某一位匹配，那么这个数字就不能喝其他数字匹配了。那么 11123 和 91111 应该返回什么？</span>我们的程序应该返回 1A1B，如图 3.14和图 3.15所示。

<center>

![](http://images.iterate.site/blog/image/20190701/fIQD6pFByJCO.png?imageslim){ width=55% }
</center>

<center>

![](http://images.iterate.site/blog/image/20190701/Eu4shBK7MQT0.png?imageslim){ width=55% }
</center>

## 问题求解

对于这个问题，最直接的想法是把猜测数字中的每一位数字取出来在秘密数字中找一圈。如果这个数字和秘密数字中的某一位数字一样并且位置一样，则为一个公牛（A），如果仅仅只是数字一致的话，则是一个奶牛（B）。同时，为了不重复对应，还需要在每次找到对应关系后都对秘密数字已经对应的位置进行记录。<span style="color:red;">是的。</span>

上面的办法虽然简单易行，但是对于大数据量的问题，这个算法就有点吃不消了，并且在每次寻找的过程中存在很多重复的判断。

这个问题本质上还是一个查找问题，既然是查找问题，那么首先要想到的就是哈希。在每一轮查找的过程中如果使用哈希将会大大降低查询时间，提高查找效率。<span style="color:red;">嗯，查找问题首先想到的是 hash。</span>

先解决第一个问题，查找公牛（A）的数量。这个问题比较简单，首先定义一个变量 A 表示公牛的数量，之后循环把每个位置上的数字都取出来，按位置对比即可，数字一样则让 A 加 1。

那么，如何解决计算奶牛的数量的问题呢？为了解决这个问题，我们使用哈希来加快速度，先建立两个字典。

那么，为什么需要建立两个字典呢？因为在配对的过程中需要知道哪些位置的数字配对了，哪些还没有配对。

记录每一位的情况比较麻烦，有没有什么简便方法能够简化这个过程呢？我们来观察一下最终的结果和数据的关系，对于秘密数字为 1123，猜测数字为 9111 的例子，为什么 B 的数量是 1 呢？

在秘密数字中第二个 1 已经算作公牛（A），而第一个数字 1 只能和猜测数字中两个 1 中的某一个 1 对应，也就是说，最终 B 的数量是由该数在秘密数字中和在猜测数字中更小的那方决定的。

为此，我们只需要记录秘密数字和猜测数字中未匹配的数字和它的个数，之后看相同数字的最小数即可。<span style="color:red;">嗯，也就是 11123 和 91111 返回的应该是 2A1B 是吧？</span>

那么，在分析 A 的数量的同时，记录其他未匹配数字的数量，代码如下：

记录好了数量，接下来就可以根据两个数组中的数的最小值来判断 B 的数量了。

## 最终代码

猜词游戏的最终代码如代码 3.4所示。



```py
def get_hint(secret, guess):
    secret_dict = {}
    guess_dict = {}

    A = 0
    B = 0
    for i in range(len(secret)):
        if secret[i] == guess[i]:
            A += 1
        else:
            if secret[i] in secret_dict:
                secret_dict[secret[i]] = secret_dict[secret[i]] + 1
            else:
                secret_dict[secret[i]] = 1
            if guess[i] in guess_dict:
                guess_dict[guess[i]] = guess_dict[guess[i]] + 1
            else:
                guess_dict[guess[i]] = 1
    for digit in secret_dict:
        if digit in guess_dict:
            B += min(secret_dict[digit], guess_dict[digit])
    return str(A) + "A" + str(B) + "B"
```



# 相关

- 《你也能看得懂的 python 算法书》
