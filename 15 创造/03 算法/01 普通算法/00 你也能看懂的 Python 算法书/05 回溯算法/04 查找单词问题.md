---
title: 04 查找单词问题
toc: true
date: 2019-07-01
---

6.4 查找单词问题
你玩过报纸上那种找单词的游戏吗？就是那种在一堆字母中橫向或竖向找出单词的游戏。小朗朗现在在玩一个和那个很像的游戏，只不过现在不但可以上下左右斜着连接字母，还可以转弯。看一下图 6.15，这是游戏的盘面，图 6.16展示的是遵循规则找出来的 4 个单词：“world”“week”“rose”“reef”。
图 6.15 游戏盘面
图 6.16 找出的单词
给出一个单词，我们的目标是通过回溯算法得出这个单词是否存在于盘面中。比如，给予“world”就返回 True，给予“hello”就返回 False。
6.4.1 问题求解
下面我们手动模拟一下算法，通过这个过程能够找到写代码的逻辑。以“week”单词为例。
首先，需要看一下盘面中的 25 个字母中有没有“w”。如图 6.17所示，找到了一个“w”。接下来，第二个字母是“e”，来看一下“w”的上下左右有没有“e”。因为没有找到“e”，所以只好寻找另一个“w”。
如图 6.18所示，找到了第二个“w”之后，发现它的左边和右边都是“e”。
图 6.17 找到第一个字母“w”
图 6.18 重新找“w”
遵守上下左右的顺序，选择左边的“e”，如图 6.19所示。
接下来的步骤就不一一展示了，到最后，成功地找出了“week”这个单词，如图 6.20所示，所以返回 True。

下面我们来看一下不用回溯写出的代码。当你不清楚怎么用回溯写出简短的代码时，可以尝试先用“笨代码”把逻辑写出来。这样能够看清楚哪段代码是重复的，哪个函数是需要传入的，哪个条件是输出条件，看清楚之后写回溯方法就很容易了。
上面的代码看上去非常乱，但它的逻辑其实很好理解。它的基本逻辑是：从盘面上任何字母（1）开始，如果（1）是单词的首字母，看它的上下左右有没有单词的第二个字母，如果有，称这个字母为（2），再看（2）的上下左右有没有单词的第三个字母……就这样一直检查下去；如果没有，就改变（1），换一个字母开始。
需要注意的是，当我们找到了一个对应的字母时，需要把它从盘面中删除（改成空字符串），这样在下面的检查过程中不会再次使用该字母。检查后，如果该字母的上下左右没有对应的剩余单词，需要把它再次填入盘面。
看一下图 6.21，是不是一下感觉代码整齐了许多？每一个黑框中的代码都是重复的。仔细观察，你会发现每一个黑框都包着 4 个小黑框。


注意：我们省略了一些前提条件，比如，如果 i 小于 0 则不检查。
写这样的代码的前提条件是已知单词的长度，不然我们无法得知在第几环输出结果。
6.4.2 最终代码
现在清楚地看到了重复的代码结构，就可以轻松地写出回溯算法了。定义一个 helper 回溯方法概括重复的代码。下面我们会进行解释。
上面是 helper 方法的完整代码，也就是“笨代码”中黑框里的代码。只不过我们把黑框中的小黑框改成了调用 helper 方法。
来看一下 helper 方法的参数：
board，游戏的盘面，一个由字母组成的二维列表。不一定是 n*n，可能是 6*7、8*8、9*1……
current，剩余的单词，比如“week”“eek”“ek”“k”“”。
row，当前字母在盘面的横坐标。
column，当前字母在盘面的纵坐标。
来看一下 helper 方法履行的任务：
1.检查当前盘面坐标对应的字母是不是剩余单词的首字母。
如果当前坐标不在盘面范围内（如果坐标小于 0 或大于盘面长度），跳过该坐标。如果符合前提条件，并且两个字母相同，把字母从盘面中去除。
2.如果对应，检查坐标的上下左右是否对应剩余单词的首字母。
调用 helper 方法返回的布尔值代表的是：以当前坐标为起点是否能够找出剩余的单词（current[1:]）。我们有 4 个选择，所以要调用 helper 方法 4 次。如果没有返回 True，走到了第 13 行代码，那么就把字母填回到盘面上。
3.检查是否已经找到单词。

在一开始的时候，如果剩余单词是一个空字符串，我们就没有往下走的意义了，直接返回 True 就可以了。
有了 helper 方法，需要遍历盘面中的字母并调用它解决问题。
完整代码如代码 6.4所示。
代码 6.4 用回溯算法解决查找单词问题
那我们就尝试一下查找“week”这个单词：
board=[[＂a＂,＂c＂,＂r＂,＂y＂,＂l＂],[＂l＂,＂w＂,＂o＂,＂r＂,＂i＂],[＂a＂,＂f＂,＂d＂,＂l＂,＂c＂],[＂k＂,＂e＂,＂e＂,＂w＂,＂e＂],[＂o＂,＂d＂,＂r＂,＂o＂,＂s＂]]
Solution（）.wordSearch（board,＂week＂）
返回：
True
