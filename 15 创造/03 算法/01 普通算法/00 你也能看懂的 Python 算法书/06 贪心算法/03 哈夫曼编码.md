---
title: 03 哈夫曼编码
toc: true
date: 2019-07-01
---
7.3 哈夫曼编码
哈夫曼编码是一种字符编码方式，可以对指定的字符集进行数据压缩，压缩率在 20%～90%。
7.3.1 问题描述
现在有一个包含 5 个字符的字符表{A,B,C,D,E}，各个字符出现的频率统计如表 7.1所示。
表 7.1 各个字符出现的频率
需要构造一种有效率的编码类型，使用该编码表达以上字符表内容时可以产生平均长度最短的位串。
在对由 n 个字符组成的文本进行编码的过程中，有两种编码方式，即定长编码和变长编码。
对于定长编码而言，会为每个字符赋予一个长度固定为 m（m >=log2n）的位串，我们常用的标准 ASCII 码就是采用定长编码策略对字符集进行编码的。
长度各异的编码，其中出现频率较高的字符，采用长度较短的编码表示，出现频率较低的字符，采用长度较长的编码表示。著名的摩斯电码（Morse code）就是采用这种策略进行编码的。
通常情况下，与定长编码相比，变长编码可以有效减少表示同一字符集所需的编码长度，提升编码效率。
但是，为了使用变长编码策略，需要解决在定长编码模式下不会遇到的一个问题，就是前缀码问题。所谓前缀码，是对每一个字符规定一个 0-1串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀，这种编码称为前缀码。
有了前缀码，可以在编码完成的位串中准确定位每个属于字符集的字符。通过简单扫描一个位串，直到得到某个等于字符集中字符的位串后，将该字符替换之前的位串，重复以上操作，即可根据位串恢复原来的文本。
7.3.2 哈夫曼树
为了对某字母表构造一套二进制的前缀码，可以借助二叉树。将树中所有的左向边都标记为 0，所有的右向边都标记为 1。通过记录从根节点到字符所在的叶子节点的简单路径上的所有 0-1标记来获得表示该字符的编码。
根据二叉树的性质，因为从一个叶子节点到另一个叶子节点的简单路径不存在，所以字符集中的每个字符，其对应的编码不可能是其他字符的前缀，因此，任何一棵这样的二叉树均能生成一套前缀码。
对于给定的字符集和字符表，可以确定每个字符的出现频率，我们怎么才能构造一棵二叉树，将较短的编码分配给高频字符，将较长的编码分配给低频字符呢？
用贪心算法可以实现这个目标。这个算法由戴维·哈夫曼（David Huffman）发明，因此，能达到这个目标的二叉树称为哈夫曼树。
具体算法如下：
初始化 n个单节点的树，并为它们标上字母表中的字符。把每个字符出现的频率记在其对应的根节点中，用来标记各个树的权重，即树的权重等于树中所有叶子节点的概率之和。
重复下面的步骤，直到只剩一颗单独的树。找到两棵权重最小的树，若两棵树权重相同，可任选其一，分别把它们作为新二叉树的左右子树，并把其权重之和作为新的权重记录在新树的根节点中。
用上述算法构造出的二叉树即为哈夫曼树。根据哈夫曼树获取的编码称为哈夫曼编码。下面构造 7.3.1节中提到的字符集的哈夫曼树。
在初始状态，构造如图 7.5所示的根节点集合。
图 7.5 初始化根节点的示意图
此时，我们将节点 B 和 E 合并成一棵新的子树，如图 7.6所示。


图 7.6 合并节点 B 和 E 后的示意图
合并节点 B 和 E 之后，重新排序根节点，合并两个权值最小的节点，C和 D，如图 7.7所示。
图 7.7 合并节点 C 和 D 后的示意图
之后，合并由节点 B 和 D 组成的树的根节点和节点 A，如图 7.8所示。
图 7.8 合并由节点 B 和 D 组成的树的根节点和节点 A 后的示意图
最后，获取剩余的两个节点，得到结果哈夫曼树，如图 7.9所示。
图 7.9 结果哈夫曼树示意图
获得哈夫曼树后，根据给结果哈夫曼树的左侧分支编 0，右侧分支编 1，可以得到字符表中的各个字符的对应编码，如表 7.2所示。
表 7.2 对应编码
至此，7.3.1节的字符集编码问题得到解决。根据给定的字符出现的概率和求得的各字符对应的编码长度，若采用上述编码策略，每个字符的平均位长度为：
2×0.35+3×0.1+2×0.2+2×0.2+3×0.15=2.25
若采用定长编码策略，则表示 7.3.1节的字符表中的每个字符至少需要用 3 位编码来表示。因此，针对这一实例，哈夫曼编码的实现的压缩率为：
[（3-2.25）/3]×100%=25%
综上，若采用哈夫曼编码，我们表达该字符集时比采用定长编码策略可以少占用 25%的存储空间。
7.3.3 贪心选择性质


二叉树 T 表示字符集 C 的一个最优前缀码，证明可以对 T 做适当修改后得到一棵新的二叉树 T＇＇。在 T＇＇中，x和 y 是最深叶子节点且为兄弟，同时 T＇＇表示的前缀码也是 C 的最优前缀码。设 b 和 c 是二叉树 T 的最深叶子节点，且为兄弟。设 f（i）为节点 i 对应字符出现的频率，且 f（b）<=f（c）,f（x）<=f（y）。
由于 x 和 y 是 C 中具有最小频率的两个字符，有 f（x）<=f（b）,f（y）<=f（c）。首先，在树 T 中交换叶子 b 和 x 的位置得到 T＇，然后在树 T＇中交换叶子 c 和 y 的位置，得到树 T＇＇，如图 7.10所示。
图 7.10 贪心选择性质证明示意图
由此可知，树 T 和 T＇的前缀码的平均码长之差如下：
因此，T＇＇表示的前缀码也是最优前缀码，且 x 和 y 具有相同的码长，同时，仅最优一位编码不同。
7.3.4 最优子结构性质
二叉树 T 表示字符集 C 的一个最优前缀码，x和 y 是树 T 中的两个叶子节点且为兄弟，z是它们的父亲。若将 z 当作具有频率 f（z）=f（x）+f（y）的字符，则树 T＇=T-{x,y}表示字符集 C ＇=C-{x,y}∪{z}的一个最优前缀码。因此，有：
如果 T＇不是 C ＇的最优前缀码，假定 T＇＇是 C ＇的最优前缀码，那么显然 T＇＇是比 T 更优的前缀码，跟前提矛盾！故 T＇所表示的 C＇的前缀码是最优的。
由贪心选择性质和最优子结构性质可以推出哈夫曼算法是正确的，即 HuffmanTree 产生的一棵最优前缀编码树。
7.3.5 最终代码
哈夫曼编码的贪心算法代码如代码 7.3所示。
代码 7.3 哈夫曼编码的贪心算法求解



最终的输出结果为：
>>>
Character:C freq:2 encoding: 10100
Character:G freq:2 encoding: 10101
Character:E freq:3 encoding: 0000
Character:K freq:3 encoding: 0001
Character:B freq:4 encoding: 0100
Character:F freq:4 encoding: 0101
Character:I freq:4 encoding: 0110
Character:J freq:4 encoding: 0111
Character:D freq:5 encoding: 1011
Character:H freq:6 encoding: 1110
Character:N freq:6 encoding: 1111
Character:L freq:7 encoding: 001
Character:M freq:9 encoding: 100
Character:A freq:10 encoding: 110
