---
title: 03 字符串、向量和数组
toc: true
date: 2018-08-21 18:16:23
---
#### 第 3 章

### 字符串、向量和数组

内容

除了第 2 章介绍的内置类型之外,C++语言还定义了…个内容丰富的抽象数裾类型厍。 其中，string和 vector 是两利 1 最重要的标准浑类型，前者支持可聚长字符串，后者则 表示可变长的集合。还有•种标准库类型是迭代器，它是 string 和 vector 的配套类型， 常被用于访 M string中的字符或 vector 中的元素。

内置数组是一种更基础的类型，string和 vector 都是对它的某种抽象。本章将分 别介绍数飢以及标准阵类型 string 和 vector。

□T＞第 2 章介绍的内置类型是由 C++语言直接定义的。这些类型，比如数字和字符，体现了大 多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型，它们尚 未直接实现到计算机硬件中。

本章将介绍两种最重要的标准库类型：string和 vector。string表示可变长的 字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类 型，和其他内置类型一样，数组的实现与硬件密切相关。因此相较于标准库类型 string 和 vector，数组在灵活性上稍显不足。

在开始介绍标准库类型之前，先来学习一种访问库中名字的简单方法。

粗 3.1命名空间的 using 声明

目前为止，我们用到的库函数基本上都属于命名空间 std，而程序也显式地将这一点 标示了出来。例如，std: :cin表示从标准输入中读取内容。此处使用作用域操作符（::） （参见 1.2节，第 7 页）的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那 个名字。因此，std: :cin的意思就是要使用命名空间 std 中的名字 cin。

上面的方法显得比较烦琐，然而幸运的是，通过更简单的途径也能使用到命名空间中 的成员。本节将学习其中--种最安全的方法，也就是使用 using 声明（usingdeclaration）, 18.2.2节（第 702 页）会介绍另一种方法。

有了 using声明就无须专门的前缀（形如命名空间：：）也能使用所需的名字了。 using声明具有如下的形式：

using namespace::name;

一旦声明了上述语句，就可以直接访问命名空间中的名字:

\#include <iostream>

// using声明，当我们使用名字 cin 时，从命名空间 std 中获取它 using std::cin;

int main()

{

int i;

cin » i; cout « i; std::cout « i; return 0;



//正确：ciri和 std: : cin含义相同

//错误：没有对应的 using 声明，必须使用完整的名字 //正确：显式地从 std 中使用 cout

每个名字都需要独立的 using 声明

按照规定，每个 using 声明引入命名空间中的一个成员。例如，可以把要用到的标 准库中的名字都以 using 声明的形式表示出来，重写 1.2节（第 5 页）的程序如下：

I 83 >    #include <iostream>



//通过下列 using 声明，我们可以使用标准库中的名字 using std::cin;

using std::cout; using std::endl;

int main()

cout « "Enter two numbers:,' << endl;

int vl, v2; cin >> vl >> v2;

cout « "The sum of " « vl « " and " « v2 << "is " << vl + v2 << endl;

return 0;

}

在上述程序中，一开始就有对 cin、cout和 endl 的 using 声明，这意味着我们不用再 添加 std::形式的前缀就能直接使用它们。C++语言的形式比较自由，因此既可以一行只 放一条 using 声明语句，也可以一行放上多条。不过要注意，用到的每个名字都必须有 自己的声明语句，而且每句话都得以分号结束。

头文件不应包含 using 声明

位于头文件的代码（参见 2.6.3节，第 67 页）一般来说不应该使用 using 声明。这 是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个 using 声明， 那么每个使用了该头文件的文件就都会有这个声明。对下•某些程序来说，由于不经意间包 含了一些名字，反而可能产生始料未及的名字冲突。

一点注意事项

经本节所述，后面的所有例子将假设，但凡用到的标准库中的名字都已经使用 using 语句声明过了。例如，我们将在代码中直接使用 cin，而不再使用 std: :cin»

为了让书中的代码尽量简洁，今后将不会再把所有 using 声明和#include指令一 一标出。附录 A 中的表 A.1 （第 766 页）列出了本书涉及的所有标准库中的名字及对应的 头文件。

A

WARNING



读者请注意：在编译及运行本书的示例前请为代码添加必要的#include指令 和 using 声明；，

###### 3.1节练习

练习 3.1:使用恰当的 using 声明重做 I.4.1节（第 11 页）和 2.6.2节（第 67 页）的练习。

##### 3.2    准库炎哦 string    50

标准库类型 string 表示可变长的字符序列，使用 string 类型必须首先包含<~84~1 string头文件。作为标准库的一部分，string定义在命名空间 std 中。接下来的示例 都假定已包含了下述代码：

\#include <string> using std::string;

本节描述最常用的 string 操作，9.5节（第 320 页）还将介绍另外一些。

C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现 者做出一些性能上的需求' 因此，标准库类型对于一般应用场合来说有足够的 效率，

###### 3.2.1定义和初始化 string 对象

如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式， 只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。 表 3.1列出了初始化 string 对象最常用的一些方式，下面是几个例子：

string si;    //默认初始化，si是一^空字符串

string s2 =    si;    //    s2 是 si 的副本

string s3 =    "hiya";    //    s3是该字符串字面值的副本

string s4 (10, ' c' ) ;    //    s4 的内容是 cccccccccc

可以通过默认的方式(参见 2.2.1节，第 40 页)初始化一个 string 对象，这样就会得到 一个空的 string，也就是说，该 string 对象中没有任何字符。如果提供了一个字符串 字面值(参见 2.1.3节，第 36 页)，则该字面值中除了最后那个空字符外其他所有的字符 都被拷贝到新创建的 string 对象中去。如果提供的是一个数字和一个字符，则 string 对象的内容是给定字符连续重复若干次肟得到的序列。

表 3.1 ••初始化 string 对象的方式

| string | si           |             |
| ------ | ------------ | ----------- |
| string | s2           | (si)        |
| string | s2           | =si         |
| string | s3 ("value") |             |
| string | s3           | ="value     |
| string | s4           | (n,    'c') |



默认初始化，si是一个空串 s2是 si 的副本

等价于 s2(sl)，s2是 si 的副本

S3是字面值"value”的副本，除了字面值最后的那个空字符外 等价于 s3 ("value") , S3是字面值"value"的副本 把 s4 初始化为由连续 n 个字符 c 组成的串

直接初始化和拷贝初始化

由 2.2.1节(第 39 页)的学习可知，C++语言有几种不同的初始化方式，通过 string 我们可以清楚地看到在这些初始化方式之间到底有什么区別和联系。如果使用等号(=) 初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的 初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化

(direct initialization )o

当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面的 s4 那样初 始化要用到的值有多个，一般来说只能使用直接初始化的方式：

string s5 = "hiya";    // 拷贝初始化

string s6(’’hiya");    // 直接初始化

string s7(10, ’ c’)；    // 直接初始化，s7 的内容是 cccccccccc

El5＞对于用多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需 要显式地创建一个(临时)对象用于拷贝：

string s8 = string (10, r cf ) ; // 拷贝初始化，s8 的内容是 cccccccccc

s8的初始值是 string (10,，c，)，它实际上是用数字 10 和字符 c 两个参数创建出来的 --个 string 对象，然后这个 string 对象又拷贝给了 s8。这条语句本质上等价于下面 的两条语句：

string temp (10, f cf ) ;    // temp 的内容是 cccccccccc

string s8 = temp;    // 将 temp 拷贝给 s8

其实我们可以看到，尽管初始化 s8 的语句合法。但和初始化 s7 的方式比较起来可读性 较差，也没有任何补偿优势。

###### 3.2.2 string对象上的操作    啦

一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，

类既能定义通过函数名调用的操作，就像 SaleS_item类的 isbn 函数那样（参见 1.5.2 节，第 20 页），也能定义＜＜、+等各种运算符在该类象上的新含义。表 3.2中列举了 string 的大多数操作。

| 表 3.2: string的操作 |                                                            |
| ------------------- | ---------------------------------------------------------- |
| os«s                | 将 s 写到输出流 os 当中，返回 OS                                |
| is»s                | 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is             |
| getline (is, s)     | 从 is 中读取一行赋给 s，返回 is                                |
| s.empty()           | s为空返回 true，否则返回 false                                |
| s.size ()           | 返回 s 中字符的个数                                          |
| s [n]               | 返回 s 中第 n 个字符的引用，位置 n 从 0 计起                       |
| sl+s2               | 返回 si 和 s2 连接后的结果                                     |
| sl=s2               | 用 s2 的副本代替 si 中原来的字符                               |
| sl==s2              | 如果 si 和 s2 中所含的字符完全一样，则它们相等；string对象的相 |
| si!=s2              | 等性判断对字母的大小写敏感                                 |
| <,<=z >, >=         | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感       |

读写 string 对象

第 I 章曾经介绍过，使用标准库中的 iostream 来读写 int、double等内置类型的 值。同样，也可以使用 IO 操作符读写 string 对象：

//注意：要想编译下面的代码还需要适当的#include语句和 using 声明 int main（）

{

string s;    //空字符串

cin » s;    //将 string 对象读入 s，遇到空白停止

cout ＜＜ s « endl;    // 输出 s

return 0;

}

这段程序首先定义一个名为 s 的空 string，然后将标准输入的内容读取到 s 中。在执行＜86~| 读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从 第一个真正的字符开始读起，直到遇见下一处空白为止。

如上所述，如果程序的输入是“    Hello World! ”（注意开头和结尾处的空

格），则输出将是“Hello”，输出结果中没有任何空格。

和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运 算对象作为其结果。因此，多个输入或者多个输出可以连写在一起：

string si, s2;

cin » si » s2;

cout « si « s2 « endl;



//把第一个输入读到 si 中，第二个输入读到 s2 中 //输出两个 string 对象

假设给上面这段程序输入与之前一样的内容“    Hello World! ”，输出将是

“HelloWorld!”。

读取未知数量的 string 对象

1.4.3节(第 13 页)的程序可以读入数量未知的整数，下面编写一个类似的程序用于 读取 string 对象：

int main()

{

string word;

while (cin >> word)    //反复读取。直至到达文件末尾

cout « word << endl;    //逐个输出单词，每个单词后面紧跟一个换行

return 0;

}

在该程序中，读取的对象是 string 而非 int，但是 while 语句的条件部分和之前版本 的程序是一样的。该条件负责在读取时检测流的情况，如果流有效，也就是说没遇到文件

EJL>结朿标记或非法输入，那么执行 while 语句内部的操作。此时，循环体将输出刚刚从标 准输入读取的内容。重复若干次之后，一旦遇到文件结朿标记或非法输入循环也就结朿了。

使用 getline 读取一整行

有时我们希望能在最终得到的字符串中保留输入时的空白符，这吋应该用 getline 函数代替原来的>>运算符。getline函数的参数是一个输入流和一个 string 对象，函 数从给定的输入流中读入内容，直到遇到换行符为止(注意换行符也被读进来了)，然后 把所读的内容存入到那个 string 对象中去(注意不存换行符)，getline只要一遇到换 行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的 一开始就是换行符，那么所得的结果是个空 string。

和输入运算符一样，getline也会返回它的流参数，因此既然输入运算符能作为判 断的条件(参见 1.4.3节，第 13 页)，我们也能用 getline 的结果作为条件。例如，可以 通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了：

int main()

{

string line;

//每次读入一整行，直至到达文件末尾 while (getline(cin, line))

cout << line << endl; return 0;

I

因为 line 中不包含换行符，所以我们手动地加上换行操作符。和往常一样，使用 endl 结束当前行并刷新显示缓冲区。

![img](C++  Primer 5-30.jpg)



触发 getline 函数返回的那个换行符实际上被丢弃掉了，得到的 string 对 象中并不包含该换行符。

string 的 empty 和 size 操作

顾名思义，empty函数根据 string 对象是否为空返回一个对应的布尔值(参见第

2.1节，30页)。和 Sales_item类(参见 1.5.2节，第 20 页)的 isbn 成员一样，empty 也是 string 的一个成员数。调用该函数的方法很简单，只要使用点操作符指明是哪个 对象执行了 empty函数就可以了。

通过改写之前的程序，可以做到只输出非空的行：

II每次读入一整行，遇到空行直接跳过 while (getline(cinz line))

if (!line.empty())

cout « line « endl;

在上面的程序中，if语句的条件部分使用了逻辑非运算符(！)，它返回与其运算对象相 反的结果。此例中，如果 str 不为空则返回真。

size函数返回 string 对象的长度(即 string 对象中字符的个数)，可以使用 size <88 | 函数只输出长度超过 80 个字符的行：

string line;

//每次读入一整行，输出其中超过 80 个字符的行 while (getline(cin, line))

if (line.size() > 80)

cout « line << endl;

string::size_type 类型

对于 size 函数来说，返回一个 int 或者如前面 2.1.1节(第 31 页)所述的那样返回 —个 unsigned 似乎都是合情合理的。但其实 size 函数返回的是一个 string: : size_type类型的值，下面就对这种新的类型稍作解释。

string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了 标准库类型与机器无关的特性，类型 siZe_type即是其中的一种。在具体使用的吋候， 通过作用域操作符来表明名字 size_type是在类 string 中定义的。

尽管我们不太清楚 string: : size_type类型的细节，但有一点是肯定的：它是一 个无符号类型的值(参见 2.1.1节，第 30 而且能足够存放下任何 string 对象的大小。 所有用于存放 string 类的 size 函数返回值的变量，都应该是 string: : size_type 类型的。

过去，string: :size_type这种类型有点儿神秘，不太容易理解和使用。在 C++11新 标准中，允许编译器通过 auto 或者 decltype (参见 2.5.2节，第 61 页)来推断变量的类型：岡

auto len = line .size () ; / / len 的类型是 string: : size_type

由于 size 函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符 号数和无符号数将可能产生意想不到的结果(参见 2.1.2节，第 33 页)。例如，假设 n 是 -个具有负值的 int，则表达式 s . size () <n的判断结果几乎肯定是 true-这是因为负

值 n 会自动地转换成一个比较大的无符号值。

![img](C++  Primer 5-31.jpg)



如果一条表达式中已经有了 size ()函数就不要再使用 int 了，这样可以避免 混用 int 和 unsigned 可能带来的问题、

比较 string 对象

string类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较 string

对象中的字符，并且对大小写敏感，也就是说，在比较时同一个字母的大写形式和小写形 式是不同的。

相等性运算符（==和!=）分别检验两个 string 对象相等或不相等，string对象相 等意味着它们的长度相同而且所包含的字符也全都相同。关系运算符＜、＜=、〉、＞=分别 检验一个 string 对象是否小于、小于等于、大于、大于等于另外一个 string 对象。上 述这些运算符都依照（大小写敏感的）字典顺序：

EZ^＞ 1.如果两个 string 对象的长度不同，而且较短 string 对象的每个字符都与较长 string对象对应位置上的字符相同，就说较短 string 对象小于较长 string 对象。

2.如果两个 string 对象在某些对应的位置上不一致，则 string 对象比较的结果 其实是 string 对象中第一对相异字符比较的结果。

下面是 string 对象比较的一个示例：

string str = "Hello";

string phrase = "Hello World";

string slang = "Hiya";

根据规则 1 可判断，对象 str 小于对象 phrase；根据规则 2 可判断，对象 slang 既大 于 str 也大于 phrase。

为 string 对象赋值

一般来说，在设计标准库类型时都力求在易用性上向内置类型看齐，因此大多数库类 型都支持赋值操作。对于 string 类而言，允许把一个对象的值赋给另外一个对象：

string stl （10, ' c' ） , st2; // stl 的内容是 cccccccccc; st2 是一个空字符串 stl = st2;    //赋值：用 st2 的副本替换 stl 的内容

//此时 stl 和 st2 都是空字符串

两个 string 对象相加

两个 string 对象相加得到一个新的 string 对象，其内容是把左侧的运算对象与右 侧的运算对象串接而成=也就是说，对 string 对象使用加法运算符（+ ）的结果是一个 新的 string 对象，它所包含的字符由两部分组成：前半部分是加号左侧 string 对象所 含的字符、后半部分是加号右侧 string 对象所含的字符。另外，复合赋值运算符（+=） （参见 1.4.1节，第 10 页）负责把右侧 string 对象的内容追加到左侧 string 对象的 后面：

string si = "hello, ", s2 = "world\n";

string s3 = si + s2;    // s3 的内容是 hello, world\n

si += s2;    // 等价于 si = si + s2

字面值和 string 对象相加

如 2.1.2节（第 33 页）所讲的，即使一种类型并非所需，我们也可以使用它，不过前 提是该种类型可以自动转换成所需的类型。因为标准库允许把字符字面值和字符串字面值 （参见 2.1.3节，第 36 页）转换成 string 对象，所以在需要 string 对象的地方就可以 使用这两种字面值来替代。利用这一点将之前的程序改写为如下形式：

string si = "hello", s2 = "world"; // 在 si 和 s2 中都没有标点符号 string s3 = si + ", " + s2 + f\nr ;

当把 string 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加 法运算符(+ )的两侧的运算对象至少有一个是 string:

string s4 = si + ",，'；    //正确：把一个 string 对象和一个字面值相加    〈90 j

string s5 = "hello” + ", ••;    //错误：两个运算对象都不是 string

//正确：每个加法运算符都有一个运算对象是 string

string s6=sl+", "+ "world";

string s7 = "hello" + ", " + s2; //错误：不能把字面值直接相加

s4和 s5 初始化时只用到了一个加法运算符，因此很容易判断是否合法。s6的初始化形 式之前没有出现过，但其实它的工作机理和连续输入连续输出(参见 1.2节，第 6 页)是 一样的，可以用如下的形式分组：

string s6 = (si + ", ") + "world";

其中子表达式 sl + ”，"的结果是一个 string 对象，它同时作为第二个加法运算符的左 侧运算对象，因此上述语句和下面的两个语句是等价的：

string tmp = sl + *',    //正确：加法运算符有一个运算对象是 string

s6 = tmp + "world" ;    //正确：加法运算符有一个运算对象是 string

另一方面，s7的初始化是非法的，根据其语义加上括号后就成了下面的形式： string s7 = ("hello" + ", ") + s2; //错误：不能把字面值直接相加

很容易看到，括号内的子表达式试图把两个字符串字面值加在一起，而编译器根本没法做 到这一点，所以这条语句是错误的。

WARNING



因为某些历史原因，也为了与 C 兼容，所以 C++语言中的字符串字面值并不是 标准库类型 string 的对象切记，字符串字面值与 string 是不同的类型。

###### 3.2.2节练习

练习 3.2:编写一段程序从标准输入中一次读入一整行，然后修改该程序使其一次读入 一个词。

练习 3.3:请说明 string 类的输入运算符和 getline 函数分别是如何处理空白字符 的。

练习 3.4:编写一段程序读入两个字符串，比较其是否相等并输出结果。如果不相等， 输出较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长, 输出长度较大的那个字符串。

练习 3.5:编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接 成的大字符串。然后修改上述程序，用空格把输入的多个字符串分隔开来。

###### 3.2.3处理 string 对象中的字符    啦

我们经常需要单独处理 string 对象中的字符，比如检查一个 string 对象是否包含 空白，或者把 string 对象中的字母改成小写，再或者査看某个特定的字符是否出现等。

这类处理的一个关键问题是如何获取字符本身。有时需要处理 string 对象中的每一 个字符，另外一些时候则只需处理某个特定的字符，还有些时候遇到某个条件处理就要停

下来。以往的经验告诉我们，处理这些情况常常要涉及语言和库的很多方面。

另一个关键问题是要知道能改变某个字符的特性。在 cctype 头文件中定义了一组标 准库函数处理这部分工作。表 3.3列出了主要的函数名及其含义。

| 表 3.3: cctype头文件中的函数 |                                                              |
| --------------------------- | ------------------------------------------------------------ |
| isalnum(c)                  | 当 c 是字母或数字时为真                                        |
| isalpha(c)                  | 当 c 是字母时为真                                              |
| iscntrl(c)                  | 当 C 是控制字符时为真                                          |
| isdigit(c)                  | 当 C 是数字吋为真                                              |
| isgraph(c)                  | 当 C 不是空格但可打印时为真                                    |
| islower(c)                  | 当 C 是小写字母时为真                                          |
| isprint(c)                  | 当 C 是可打印字符时为真（即 C 是空格或 C 具有可视形式）            |
| ispunct(c)                  | 当 C 是标点符号时为真（即 C 不是控制字符、数字、字母、可打印空白中的 一种） |
| isspace(c)                  | 当 C 是空白时为真（即 C 是空格、横向制表符、纵向制表符、回车符、换行 符、进纸符中的一种） |
| isupper(c)                  | 当 C 是大写字母时为真                                          |
| isxdigit(c)                 | 当 C 是十六进制数字时为真                                      |
| tolower(c)                  | 如果 C 是大写字母，输出对应的小写字母；否则原样输出 C           |
| toupper(c)                  | 如果 C 是小写字母，输出对应的大写字母；否则原样输出 C           |

进议：使用 C++版本的 C 杉准库头文件

C++标准库中除了定义 C++语言特有的功能外，也兼容了 C语言的标准库。C语言 的头文件形如 C++则将这些文件命名为也就是去掉了 .h后缀，而在 文件名 wazne 之前添加了字母 c，这里的 c 表示这是一个属于 C 语言标准库的头文件。

因此，cctype头文件和 ctype.h头文件的内容是一样的，只不过从命名规范上 来讲更符合 C++语言的要求。特别的，在名为 c/wme的头文件中定义的名字从属于命名 空间 std，而定义在名为.h的头文件中的则不然。

一般来说，C++程序应该使用名为的头文件而不使用的形式，标准 库中的名字总能在命名空间 std 中找到。如果使用.h形式的头文件，程序员就不得不 时刻牢记哪些是从 C 语言那儿继承过来的，哪些又是 C++语言所独有的。

处理每个字符？使用基于范围的 for 语句

如果想对 string 对象中的每个字符做点儿什么操作，目前最好的办法是使用 C++11 新标准提供的一种语句：范围 for （range for）语句。这种语句遍历给定序列中的每个元 素并对序列中的每个值执行某种操作，其语法形式是：

for （declaration : expression） statement

其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变 量，该变量将被用于访问序列中的基础元素。每次迭代，部分的变量会被初始 化为 expression 部分的下一个元素值。

一个 string 对象表示一个字符的序列，因此 string 对象可以作为范围 for 语句

中的 expression 部分。举一个简单的例子，我们可以使用范围 for 语句把 string 对象中 的字符每行一个输出出来：

string str ( "some string’’)；

//每行输出 str 中的一个字符

for (auto c : str)    //对于 str 中的每个字符

cout << c << endl;    //输出当前字符，后面紧跟一个换行符

for循环把变量 c 和 str 联系了起来，其中我们定义循环控制变量的方式与定义任意一 个普通变量是一样的。此例中，通过使用 auto 关键字(参见 2.5.2节，第 61 页)让编译 器来决定变量 c 的类型，这里 c 的类型是 char。每次迭代，str的下一个字符被拷贝给 c，因此该循环可以读作“对于字符串 str 中的每个字符 c，”执行某某操作。此例中的“某 某操作”即输出一个字符，然后换行。

< 92 I



举个稍微复杂一点的例子，使用范围 for 语句和 ispunct 函数来统计 string 对象 中标点符号的个数：

string s ("Hello World!!!");

// punct_cnt的类型和 s . size的返回类型一样；参见 2.5.3节(第 62 页)

decitype(s.size()) punct cnt = 0;



//统计 s 中标点符号的数量 for (auto c : s)

if (ispunct(c)) ++punct_cnt;

cout « punct_cnt



//对于 s 中的每个字符 //如果该字符是标点符号 //将标点符号的计数值加 1



« " punctuation characters in " << s « endl;



程序的输出结果将是:

3 punctuation characters in Hello World!!!

这里我们使用 decltype 关键字(参见 2.5.3节，第 62 页)声明计数变量 punct_cnt， 它的类型是 s . size函数返回值的类型，也就是 string: : size_type。使用范围 for 语句处理 string 对象中的每个字符并检查其是否是标点符号。如"果是，使用递增运算符 (参见 1+4+1节，第 10 页)给计数变量加 1。最后，待范围 for 语句结束后输出统计结果。

<93~1



使用范围 for 语句改变字符串中的字符

如果想要改变 string 对象中字符的值，必须把循环变量定义成引用类型(参见 2.3.1 节，第 45 页)。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制 变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改 变它绑定的字符。

新的例子不再是统计标点符号的个数了，假设我们想要把字符串改写为大写字母的形 式。为了做到这一点可以使用标准库函数 toupper，该函数接收一个字符，然后输出其 对应的大写形式。这样，为了把整个 string 对象转换成大写，只要对其中的每个字符调 用 toupper 函数并将结果再赋给原字符就可以了：

string s ("Hello World!!!");

//转换成大写形式.

for (auto &c : s)    II对于 s 中的每个字符(注意：c是引用)

c = toupper (c) ;    // c是一个引用，因此赋值语句将改变 s 中字符的值

cout « s << endl;

上述代码的输出结果将是：

HELLO WORLD!!!

每次迭代时，变量 c 引用 string 对象 s 的下一个字符，赋值给 c 也就是在改变 s 中对应字符的值。因此当执行下面的语句时，

c = toupper (c) ; // c是一引用，因此赋值语句将改变 s 中字符的值 实际上改变了 c绑定的字符的值。整个循环结束后，str中的所有字符都变成了大写形式。

只处理一部分字符？

如果要处理 string 对象中的每一个字符，使用范围 for 语句是个好主意。然而， 有时我们需要访问的只是其中一个字符，或者访问多个字符但遇到某个条件就要停下来。 例如，同样是将字符改为大写形式，不过新的要求不再是对整个字符串都这样做，而仅仅 把 string 对象中的第一个字母或第一个单词大写化。

要想访问 string 对象中的单个字符有两种方式：一种是使用下标，另外一种是使用 迭代器，其中关于迭代器的内容将在 3.4节(第 95 页)和第 9 章中介绍。

下标运算符([])接收的输入参数是 string : : size_type类型的值(参见 3.2.2 节，第 79 页)，这个参数表示要访问的字符的位置：返回值 i 该位置上字符的引用。

string对象的下标从 0 计起。如果 string 对象 s 至少包含两个字符，则 s[0]是 第 1 个字符、s[l]是第 2 个字符、s[s.size(>-l]是最后一个字符。

string对象的下标必须大于等于 0 而小于 s . size ():.

![img](C++  Primer 5-33.jpg)



使用超出此范围的下标将引发不可预知的结果，以此推断，使用下标访问 空 string 也会引发不可预知的结果。

EK>    下标的值称作“下标”或“索引”，任何表达式只要它的值是一个整型值就能作为索

弓 I。不过，如果某个索引是带符号类型的值将自动转换成由 string: :SiZe_type (参 见 2.1.2节，第 33 页)表达的无符号类型。

下面的程序使用下标运算符输出 string 对象中的第一个字符：

if (! s. empty () )    //确保确实有字符需要输出

cout « s[0] << endl;    //输出 s 的第一个字符

在访问指定字符之前，首先检查 s 是否为空。其实不管什么时候只要对 string 对象使用 了下标，都要确认在那个位置上确实有值。如果 s 为空，则 3[0]的结果将是未定义的。

只要字符串不是常量(参见 2.4节，第 53 页)，就能为下标运算符返回的字符赋新值。 例如，下面的程序将字符串的首字符改成了大写形式：

string s ("some string’’)；

if (! s .empty () )    //确保 s [0]的位置确实有字符

s [0] = toupper (s [0] ) ;    //为 s 的第一个字符赋一个新值

程序的输出结果将是，

Some string

使用下标执行迭代

另一个例子是把 S 的第一个词改成大写形式：

//依次处理 S 中的字符直至我们处理完全部字符或者遇到一个空白 for (decltype(s.size()) index = 0;

index != s.size () && !isspace(s[index]); ++index)

s [index] = toupper (s [index] ) ; //将当前字符改成大写形式

程序的输出结果将是：

SOME string

在上述程序中，for循环使用变量 index 作为 s 的下标，index的类型是由 decltype 关键字决定的。首先把 index 初始化为 0，这样第一次迭代就会从 s 的首字符开始：之 后每次迭代将 index 加 1 以得到 s 的下一个字符。循环体负责将当前的字母改写为大写 形式。

for语句的条件部分涉及一点新知识，该条件使用了逻辑与运算符(&&)。如果参与 运算的两个运算对象都为真，则逻辑与结果为真；否则结果为假。对这个运算符来说最重 耍的一点是，C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。如 此例所示，这条规定确保了只有当下标取值在合理范围之内时才会真的用此下标去访问字 符串。也就是说，只有在 index 达到 s . size G之前才会执行 s [index]。随着 index 的增加，它永远也不可能超过 s . size (>的值，所以可以确保 index 比 s.size ()小。

捉尔：注意检查卜保的介法性

<95~1



使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于 0 而小于字 符串的 size ()的值 a —种简便易行的方法是，总是设下标的类型为 string: : size_type，因为此类型是无符号数，可以确保下标不会小于 0。此时，代 码只需保证下标 7、于 size()的值就可以了。

![img](C++  Primer 5-34.jpg)



C++标准并不要求标准库俭测下标是否合法，一旦使用了一个超出范围的下 标，就会产生不可预知的结果.

使用下标执行随机访问

在之前的示例中，我们让字符串的下标每次加 1 从而按顺序把所有字符改写成了大写 形式。其实也能通过计算得到某个下标值，然后直接获取对应位置的字符，并不是每次都 得从前往后依次访问。

例如，想要编写一个程序把 0 到 15 之间的十进制数转换成对应的十六进制形式，只 需初始化一个字符串令其存放 16 个十六进制“数字”：

const string hexdigits = "0123456789ABCDEF"; // 可能的十六进制数字 cout << "Enter a series of numbers between 0 and 15"

« " separated by spaces. Hit ENTER when finished:"

« endl;

string result;    //用于保存十六进制的字符串

string: :size_type n;    //用于保存从输入流读取的数

while (cin » n)

if (n < hexdigits.size () )    // 忽略无效输入

result += hexdigits [n] ;    //得到对应的十六进制数字

cout << "Your hex number is: " << result « endl;

假设输入的内容如下：

12 0 5 15 8 15

程序的输出结果将是：

Your hex number is: C05F8F

上述程序的执行过程是这样的：首先初始化变量 hexdigits 令其存放从 0 到 F 的十六进 制数字，注意我们把 hexdigits 声明成了常量(参见 2.4节，第 53 页)，这是因为在后 面的程序中不打算再改变它的值。在循环内部使用输入值 n 作为 hexdigits 的下标， hexdigits [n]的值就是 hexdigits 内位置 n 处的字符。例如，如果 n 是 15，则结果 是 F；如果 n 是 12，则结果是 C，以此类推。把得到的十六进制数字添加到 result 内， 最后一并输出。

无论何时用到字符串的下标，都应该注意检查其合法性。在上面的程序中，下标 n 是 string: :SiZe_type类型，也就是无符号类型，所以 n 可以确保大于或等于 0。在实 际使用吋，还需 i 查 n 是否小于 hexdigits 的长度。

###### 3.2.3节练习

练习 3.6:编写一段程序，使用范围 for 语句将字符串内的所有字符用 X 代替。

练习 3.7:就上一题完成的程序而言，如果将循环控制变量的类型设为 char 将发生什 么？先估计一下结果，然后实际编程进行验证。

练习 3.8:分别用 while 循环和传统的 for 循环重写第一题的程序，你觉得哪种形式 更好呢？为什么？

练习 3.9:下面的程序有何作用？它合法吗？如果不合法，为什么？ string s;

cout << s[0] « endl;

练习 3.10:编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字 符串剩余的部分。

练习 3.11:下面的范围 for 语句合法吗？如果合法，c的类型是什么？

const string s = "Keep out!"; for (auto-&c : s) {/*...*/}

###### 姆 3.3标准库类型 vector

标准库类型 vector 表示对象的集合，其中所有对象的类型都相同。集合中的每个对 象都有一个与之对应的索引，索引用于访问对象。因为 vector “容纳着”其他对象，所 以它也常被称作容器(container)。第 II 部将对容器进行更为详细的介绍。

要想使用 vector，必须包含适当的头文件。在后续的例子中，都将假定做了如下 using声明：

^include <vector> using std::vector;

C++语言既有类模板(class template)，也有函数模板，其中 vector 是一个类模板。 只有对 C++有了相当深入的理解才能写出模板，事实上，我们直到第 16 章才会学习如何 自定义模板。幸运的是，即使还不会创建模板，我们也可以先试着用用它。

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说 明。编译器根据模板创建类或函数的过程称为实例化(instantiation)，当使用模板时，需 要指出编译器应把类或函数实例化成何种类型。

对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类， 需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括 号，在括号内放上信息。

以 vector 为例，提供的额外信息是 vector 内所存放对象的类型：

vector<int> ivec;    // ivec 保存 int 类型的对象

<97~|



vector<Sales_item> Sales_vec; // 保存 Sales_item 类型的对象 vector<vector<string>> file;    // 该向量的元素是 vector 对象

在上面的例子中，编译器根据模板 vector 生成了三种不同的类型：vector<int〉、 vector<Sales_item〉和 vector<vector<string〉〉0

![img](C++  Primer 5-35.jpg)



vector是模板而非类型，由 vector 生成的类型必须包含 vector 中元素的 类型，例如 vector<int〉o

vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象(参见 2.3.1 节，第 45 页)，所以不存在包含引用的 vector。除此之外，其他大多数(非引用)内置 类型和类类型都可以构成 vector 对象，甚至组成 vector 的元素也可以是 vector。

需要指出的是，在早期版本的 C++标准中如果 vector 的元素还是 vector (或者其 他模板类型)，则其定义的形式与现在的 C++11新标准略有不同。过去，必须在外层 vector 对象的右尖括号和其元素类型之间添加一个空格，如应该写成 vector<vector<int>〉 而非 vector<vector<int〉〉。

WARNING



某些编译器可能仍需以老式的声明语句来处理元素为 vector 的 vector 对 象，如 vector<vector<int〉 >o

###### 3.3.1定义和初始化 vector 对象

和任何一种类类型一样，vector模板控制着定义和初始化向量的方法。表 3.4列出 了定义 vector 对象的常用方法。

表 3.4:初始化 vector 对象的方法

vector<T>

vector<T>

vector<T>

vector<T>

vector<T〉



vl

v2(vl) v2 = vl v3(n, val) v4 (n)



vector<T> v5 {a, b, c. . . } vector<T> v5={a,b,c...}



vl是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化

v2中包含有 vl 所有元素的副本

等价于 v2(vl), v2中包含有 vl 所有元素的副本

v3包含了 11个重复的元素，每个元素的值都是 val

v4包含了 n个重复地执行了值初始化的对象

v5包含了初始值个数的元素，每个元素被赋予相应的初始值

等价于 v5 {a,b, c. . .}



可以默认初始化 vector 对象（参见 2.2.1节，第 40 页），从而创建一个指定类型的 空 vector：

vector<string> svec; //默认初始化，svec不含任何元素

看起来空 vector 好像没什么用，但是很快我们就会知道程序在运行时可以很高效地往 vector对象中添加元素。事实上，最常见的方式就是先定义一个空 vector，然后当运 行时获取到元素的值后再逐一添加。

当然也可以在定义 vector 对象时指定元素的初始值。例如，允许把一个 vector 对 象的元素拷贝给另外一个 vector 对象。此时，新 vector 对象的元素就是原 vector 对象对应元素的副本。注意两个 vector 对象的类型必须相同：

//初始状态为空



//把 ivec 的元素拷贝给 ivec2

//把 ivec 的元素拷贝给 ivec3

//错误：svec的元素是 string 对象，不是 int



vector<int> ivec;

//在此处给 ivec 添加一些值 vector<int> ivec2(ivec); vector<int> ivec3 = ivec; vector<string> svec(ivec2);

1~98~>列表初始化 vector 对象

C^ll新标准还提供了另外一种为 vector 对象的元素赋初值的方法，即列表初始化（参 见 2.2.1节，第 39 页）。此时，用花括号括起来的 0 个或多个初始元素值被赋给 vector 对象：

vector<string> articles = {"a", "an", "the"};

上述 vector 对象包含三个元素：第一个是字符串"a"，第二个是字符串"an"，最后一个 是字符串"the"。

之前已经讲过，C++语言提供了几种不同的初始化方式（参见 2.2.1节，第 39 页）。在 大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此。目前已经介绍 过的两种例外情况是：其一，使用拷贝初始化时（即使用=时）（参见 3.2+1节，第 76 页）， 只能提供一个初始值：其二，如果提供的是一个类内初始值（参见 2.6.1节，第 64 页）， 则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是 初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号 里：

vector<string> vl{"a", "an", "the"}; // 歹丨］表初始化 vector<string> v2（"a", "an", "the"）; // 错误

创建指定数量的元素

还可以用 vector 对象容纳的元素数量和所有元素的统一初始值来初始化 vector 对象:

vector<int> ivec （10, -1）;    // 10个 int 类型的元素，每个都被初始化为-1

vector<string> svec （10, "hi!"）;    // 10 个 string 类型的元素，

//每个都被初始化为"hi!"

值初始化

通常情况下，可以只提供 vector 对象容纳的元素数量而不用略去初始值。此时库会 创建一个值初始化的（value-initialized）元素初值，并把它赋给容器中的所有元素。这个 初值由 vector 对象中元素的类型决定。

如果 vector 对象的元素是内置类型，比如 int，则元素初始值自动设为 0。如果元 素是某种类类型，比如 string，则元素由类默认初始化：

vector<int> ivec (10) ;    // 10个元素，每个都初始化为 0

vector<string> svec (10) ;    // 10 个元素，每个都是空 string 对象

对这种初始化的方式有两个特殊限制:其一，有些类要求必须明确地提供初始值(参见 2.2.1 节，第 40 页)，如果 vector 对象中元素的类型不支持默认初始化，我们就必须提供初始 的元素值，对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。

其二，如果只提供了元素的数量而没有设定初始值，只能使用直接初始化： vector<int> vi = 10; //错误：必须使用直接初始化的形式指定向量大小    〈的 J

这里的 10 是用来说明如何初始化 vector 对象的，我们用它的本意是想创建含有 10 个值 初始化了的元素的 vector 对象，而非把数字 10 “拷贝"到 vector 中。因此，此时不 宜使用拷贝初始化，7.5.4节(第 265 页)将对这一点做更详细的介绍。

列表初始值还是元素数量？    eg

在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。例 如，用一个整数来初始化 vector<int>时，整数的含义可能是 vector 对象的容量也可 能是元素的值。类似的，用两个整数来初始化 veCtOr<intMt这两个整数可能一个是 vector对象的容量，另一个是元素的初值，也可能它们是容量为 2 的 vector 对象中两 个元素的初值。通过使用花括号或圆括号可以区分上述这些含义：

vector<int> vl(10); vector<int> v2(10};



vectorcint〉 v3(10, 1); vector<int> v4{10, 1};



// vl有 10 个元素，每个的值都是 0 // v2有 1 个元素，该元素的值是 10 // v3有 10 个元素，每个的值都是】 II v4有 2 个元素，值分别是 10 和]

如果用的是圆括号，可以说提供的值是用来构造(construct) vector对象的。例如，vl 的初始值说明了 vector对象的容量；v3的两个初始值则分别说明了 vector对象的容 量和元素的初值。

如果用的是花括号，可以表述成我们想列表初始化(list initialize)该 vector 对象。 也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有 在无法执行列表初始化时才会考虑其他初始化方式。在上例中，给 v2 和 v4 提供的初始 值都能作为元素的值，所以它们都会执行列表初始化，vector对象 v2 包含一个元素而 vector对象 v4 包含两个元素。

另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，

就要考虑用这样的值来构造 vector 对象了。例如，要想列表初始化一个含有 string 对<J00] 象的 vector 对象，应该提供能赋给 string 对象的初值。此时不难区分到底是要列表初 始化 vector 对象的元素还是用给定的容量值来构造 vector 对象：

vector<string>

vector<string>

vector<string>

vector<string>



v5{"hi’.}; // v6("hi"); // v7{10}; v8{10, "hi"}



列表初始化：v5有一个元素

错误：不能使用字符串字面值构建 vector 对象 // v7有 10 个默认初始化的元素 // v8有 10 个值为"hi"的元素

尽管在上面的例子中除了第二条语句之外都用了花括号，但其实只有 v5 是列表初始化。 要想列表初始化 vector 对象，花括号里的值必须与元素类型相同。显然不能用 int 初 始化 string 对象，所以 v"7和 v8 提供的值不能作为元素的初始值。确认无法执行列表 初始化后，编译器会尝试用默认值初始化 vector 对象。

###### 3.3.1节练习

练习 3.12:下列 vector 对象的定义有不正确的吗？如果有，请指出来。对于正确的, 描述其执行结果；对于不正确的，说明其错误的原因。

(a)    vector<vector<int» ivec;

(b)    vector<string> svec = ivec;

(c)    vector<string> svec(10, "null");

练习 3.13:下列的 vector 对象各包含多少个元素？这些元素的值分别是多少？

(a) vector<int> vl;

(b) vector<int> v2 (10);

(d) vector<int> v4 {10 };

(f) vector<string> v6 {10 };



(c) vector<int> v3 (10, 42);

(e) vector<int> v5 {10, 42 };

(g)vector<string> v7{10, "hi"};

###### 3.3.2向 vector 对象中添加元素

对 vector 对象来说，直接初始化的方式适用于三种情况：初始值已知且数量较少、 初始值是另一个 vector 对象的副本、所有元素的初始值都一样。然而更常见的情况是： 创建一个 vector 对象吋并不清楚实际所需的元素个数，元素的值也经常无法确定。还有 些时候即使元素的初值已知，但如果这些值总量较大而各不相同，那么在创建 vector 对 象的时候执行初始化操作也会显得过于烦琐。

举个例子，如果想创建一个 vector 对象令其包含从 0 到 9 共 10 个元素，使用列表 初始化的方法很容易做到这一点；但如果 vector 对象包含的元素是从 0 到 99 或者从 0 至 IJ999 呢？这时通过列表初始化把所有元素都一一罗列出来就不太合适了。对于此例来说， 更好的处理方法是先创建一个空 vector，然后在运行时再利用 vector 的成员函数 push_back向其中添加元素。push_back负责把一个值当成 vector 对象的尾元素“压 至 lj ( push) ” vector 对象的“尾端(back) ”。例如:

I 101〉 vector<int> v2;    // 空 vector 对象

for (int i = 0; i != 100; ++i)

v2 .push_back (i) ; //依次把整数值放到 v2 尾端

//循环结束后 v2 有 100 个元素，值从 0 到 99

在上例中，尽管知道 vector 对象最后会包含 100 个元素，但在一开始还是把它声明成空 vector，在每次迭代时才顺序地把下一个整数作为 v2 的新元素添加给它。

同样的：如果直到运行时才能知道 vector 对象巾元素的确切个数，也应该使用刚刚 这种方法创建 vector 对象并为其赋值。例如，有时需要实时读入数据然后将其赋予 vector 对象：

//从标准输入中读取单词，将其作为 vector 对象的元素存储 string word;

vector<string> text;    // 空 vector 对象

while (cin » word) {

text. push_back (word) ;    // 把 word 添加到 text 后面

}

和之前的例子一样，本例也是先创建一个空 vector，之后依次读入未知数量的值并保存 至 lj text 中。

关键概念：vectoi•对象能高效增长 _

C++标准要求 vector 应该能在运行时高效快速地添加元素。因此既然 vector 对 象能高效地增长，那么在定义 vector 对象的时候设定其大小也就没什么必要了，事实 上如果这么做性能可能更差。只有一种例外情况，就是所有（all）元素的值都一样。一 旦元素的值有所不同，更有效的办法是先定义一个空的 vector 对象，再在运行时向其 中添加具体值。此外，9.4节（苐 317 页）将介绍，vector还提供了方法，允许我们 进一步提升动态添加元素的性能。

开始的时候创建空的 vector 对象，在运行时再动态添加元素，这一做法与 C 语言 及其他大多数语言中内置数组类型的用法不同。特别是如果用惯了 C或者 Java，可以 预计在创建 vector 对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰 恰相反。

向 vector 对象添加元素蕴含的编程假定

由于能高效便捷地向 vector 对象中添加元素，很多编程工作被极大简化了 =然而， 这种简便性也伴随着一些对编写程序更高的要求：其中一条就是必须要确保所写的循环正 确无误，特别是在循环有可能改变 vector 对象容量的时候。

随着对 vector 的更多使用，我们还会逐渐了解到其他一些隐含的要求，其中一条是 现在就要指出的：如果循环体内部包含有向 vector 对象添加元素的语句，则不能使用范 围 for 循环，具体原因将在 5.4.3节（第 168 页）详细解释。

WARNING



范围 for 语句体内不应改变其所遍历序列的大小。



###### 3.3.2节练习

<ioT|

6



练习 3.14:编写一段程序，用 cin 读入一组整数并把它们存入一个 vector 对象。 练习 3.15:改写上题的程序，不过这次读入的是字符串。

###### 3.3.3其他 vector 操作

除了 push_back之外，vector还提供了几种其他操作，大多数都和 string 的相 关操作类似，£3.5列出了其中比较重要的一些。

| 表 3.5: vector支持的操作 |                                                              |
| ----------------------- | ------------------------------------------------------------ |
| v.empty()               | 如果 V 不含有任何元素，返回真：否则返回假                      |
| v.size ()               | 返回 V 中元素的个数                                            |
| v.push_back(t)          | 向 V 的尾端添加一个值为 t 的元素                                 |
| v[n]                    | 返回 V 中第 n 个位置上元素的引用                                 |
| vl = v2                 | 用 v2 中元素的拷贝替换 vl 中的元素                               |
| vl = {a,b,c...]         | 用列表中元素的拷贝替换 vl 中的元素                             |
| vl == v2                | vl和 V2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| vl != v2                |                                                              |
| <=r    〉.    >=        | 顾名思义，以字典顺序进行比较                                 |

访问 vector 对象中元素的方法和访问 string 对象中字符的方法差不多，也是通过 元素在 vector 对象中的位置。例如，可以使用范围 for 语句处理 vector 对象中的所 有元素：

vector<int> v{l,2,3,4, for (auto &i : v)

i *= i;

for (auto i : v)

cout « i « "，.；

cout << endl;



5,6,7,8,9};

//对于 V 中的每个元素（注意：i是一个引用） //求元素值的平方 //对于 V 中的每个元素 //输出该元素

第一个循环把控制变量 i 定义成引用类型，这样就能通过 i 给 V 的元素赋值，其中 i 的 类型由 auto 关键字指定。这里用到了一种新的复合赋值运算符（参见 1.4.1节，第 10 页）。 如我们所知，+=把左侧运算对象和右侧运算对象相加，结果存入左侧运算对象；类似的， *=把左侧运算对象和右侧运算对象相乘，结果存入左侧运算对象。最后，第二个循环输出 所有元素。

vector的 empty 和 size 两个成员与 string 的同名成员（参见 3.2.2节，第 78 页）功能完全一致：empty检查 vector 对象是否包含元素然后返回一个布尔值；size 则返回 vector 对象中元素的个数，返回值的类型是由 vector 定义的 size_type类型。

![img](C++  Primer 5-38.jpg)



要使用 size_type，需首先指定它是由哪种类型定义的 vector 对象的类 型总是包含着元素的类型（参见 3.3节，第 87 页）：

vector<int>: : size_type    // 正确

vector: :size_type    // 错误

各个相等性运算符和关系运算符也与 string 的相应运算符（参见 3.2.2节，第 79 页） 功能一致。两个 vector 对象相等当且仅当它们所含的元素个数相同，而且对应位置的元 素值也相同。关系运算符依照字典顺序进行比较：如果两个 vector 对象的容量不同，但 是在相同位置上的元素值都一样，则元素较少的 vector 对象小于元素较多的 vector 对 象；若元素的值有区别，则 vector 对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时，vector对象才能被比较。一些类，如 string 等，确实 定义了自己的相等性运算符和关系运算符；另外一些，如 Sales_item类支持的运算已 经全都罗列在 1.5.1节（第 17 页）中了，显然并不支持相等性判&和关系运算等操作。因 此，不能比较两个 vector<Sales_item>X寸象。

计算 vector 内对象的索引

使用下标运算符（参见 3.2.3节，第 84 页）能获取到指定的元素。和 string—样， vector对象的下标也是从 0 开始计起，下标的类型是相应的 size_type类型。只要 vector对象不是一个常量，就能向下标运算符返回的元素赋值。此;5^，如 3.2.3节（第 85页）所述的那样，也能通过计算得到 vector 内对象的索引，然后直接获取索引位置 上的元素。

举个例子，假设有一组成绩的集合，其中成绩的取值是从 0 到 100。以 10 分为一个分 数段，要求统计各个分数段各有多少个成绩。显然，从 0 到 100 总共有 101 种可能的成绩 取值，这些成绩分布在 11 个分数段上：每 10 个分数构成一个分数段，这样的分数段有 10 个，额外还有一个分数段表示满分 100 分。这样第一个分数段将统计成绩在 0 到 9 之间的 数量；第二个分数段将统计成绩在 10 到 19 之间的数量，以此类推。最后一个分数段统计 满分 100 分的数量。

按照上面的描述，如果输入的成绩如下：

42 65 95 100 39 67 95 76 88 76 83 92 76 93

则输出的结果应该是:

00011023241

结果显示：成绩在 30 分以下的没有、30分至 39 分有 1 个、40分至 49 分有 1 个、50分至 59分没有、60分至 69 分有 2 个、70分至 79 分有 3 个、80分至 89 分有 2 个、90分至 99 分有 4 个，还有 1 个是满分。

在具体实现时使用一个含有 11 个元素的 vector 对象，每个元素分别用于统计各个＜JS 分数段上出现的成绩个数。对于某个成绩来说，将其除以 10 就能得到对应的分数段索引。

注意：两个整数相除，结果还是整数，余数部分被自动忽略掉了。例如，42/10=4、65/10=6、 100/10=10等。一旦计算得到了分数段索引，就能用它作为 vector 对象的下标，进而获 取该分数段的计数值并加 1:

//以 10 分为一个分数段统计成绩的数量 vector<unsigned> scores (11, 0); unsigned grade;

0 〜9, 10 〜19，...，90-99, 100 // 11个分数段，全都初始化为 0

//读取成绩

//只处理有效的成绩

II将对应分数段的计数值加 1



while (cin » grade) { if (grade <= 100)

++scores[grade/10];

在上面的程序中，首先定义了一个 vector 对象存放各个分数段上成绩的数量。此例中， 由于初始状态下每个元素的值都相同，所以我们为 vector 对象申请了 11个元素，并把 所有元素的初始值都设为 0、while语句的条件部分负责读入成绩，在循环体内部首先检 查读入的成绩是否合法（即是否小于等于 100 分），如果合法，将成绩对应的分数段的计 数值加 1 ■»

执行计数值累加的那条语句很好地体现了 C++程序代码的简洁性。表达式 ++scores [grade/10] ; //将当前分数段的计数值加 1

等价于

auto ind = grade/10;    //得到分数段索引

scores [ind] = scores [ind] + 1;    // 将计数值加 1

上述语句的含义是：用 grade 除以 10 来计算成绩所在的分数段，然后将所得的结果作为 变量 scores 的下标。通过运行下标运算获取该分数段对应的计数值，因为新出现了一个 属于该分数段的成绩，所以将计数值加 1。

如前所述，使用下标的时候必须清楚地知道它是否在合理范围之内（参见 3.2.3节， 第 85 页）。在这个程序里，我们事先确认了输入的成绩确实在 0 到 100 之间，这样计算 所得的下标就一定在 0 到 10 之间，属于 0 到 scores, size （） -1规定的有效范围，一 定是合法的。

不能用下标形式添加元素

刚接触 C++语言的程序员也许会认为可以通过 vector 对象的下标形式来添加元素， 事实并非如此。下面的代码试图为 vector 对象 ivec 添加 10 个元素：

vector<int> ivec; // 空 vector 对象

for (decitype(ivec.size()) ix = 0; ix != 10; ++ix) ivec[ix] = ix; //严重错误：ivec不包含任何元素

然而，这段代码是错误的：ivec是一个空 vector，根本不包含任何元素，当然也就不 能通过下标去访问任何元素！如前所述，正确的方法是使用 push_back:

I 105〉    for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)

ivec.push_back (ix) ; //正确：添加一个新元素，该元素的值是 ix

WARNING



vector对象(以及 string 对象)的下标运算符可用于访问已存在的元素， 而不能用于添加元素

提示：只能对确知已存在的元素执行下标操作!

关于下标必须明确的一点是：只能对确知已存在的元素执行下标操作。例如，

vector<int> ivec;    // 空 vector 对象

cout « ivec [0] ;    //错误：ivec不包含任何元素

vector<int> ivec2 (10) ;    // 含有 10 个元素的 vector 对象

cout « ivec2 [10] ;    //错误：ivec2元素的合法索引是从 0 到 9

试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发 现，而是在运行时产生一个不可预知的值。

不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的 后果。所谓的缓冲区溢出(buffer overflow)指的就是这类错误，这也是导致 PC 及其他 设备上应用程序出现安全问题的一个重要原因。

![img](C++  Primer 5-40.jpg)



确保下标合法的一种有效手段就是尽可能使用范围 for 语句

###### 3.3.3节练习

练习 3.16:编写一段程序，把练习 3.13中 vector 对象的容量和具体内容输出出来。 检验你之前的回答是否正确，如果不对，回过头重新学习 3.3+1节(第 87 页)直到弄明 白错在何处为止。

练习 3.17:从 cin 读入一组词并把它们存入一个 vector 对象，然后设法把所有词都 改写为大写形式。输出改变后的结果，每个词占一行。

练习 3.18：下面的程序合法吗？如果不合法，你准备如何修改？

vector<int> ivec; ivec[0] = 42;

练习 3.19:如果想定义一个含有 10 个元素的 vector 对象，所有元素的值都是 42，请 列举出三种不同的实现方法。哪种方法更好呢？为什么？

练习 3.20：读入一组整数并把它们存入一个 vector 对象，将每对相邻整数的和输出出 来。改写你的程序，这次要求先输出第 1 个和最后 1 个元素的和，接着输出第 2 个和倒 数第 2 个元素的和，以此类推。

##### 3.4迭代器介绍

$6



我们已经知道可以使用下标运算符来访问 string 对象的字符或 vector 对象的元＜M] 素，还有另外一种更通用的机制也可以实现同样的目的，这就是迭代器（iterator）。在第 11部分中将要介绍，除了 vector之外，标准库还定义了其他几种容器。所有标准库容器 都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。严格来说，string 对象不属于容器类型，但是 string 支持很多与容器类型类似的操作。vector支持下标 运算符，这点和 string—样；string支持迭代器，这也和 vector 是一样的。

类似于指针类型（参见 2.3.2节，第 47 页），迭代器也提供了对对象的间接访问。就 迭代器而言，其对象是容器中的元素或者 string 对象中的字符。使用迭代器可以访问某 个元素，迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分，这一点 和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其 他所有情况都属于无效。

###### 3.4.1使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭 代器的成员。比如，这些类型都拥有名为 begin 和 end 的成员，其中 begin 成员负责 返回指向第一个元素（或第一个字符）的迭代器。如有下述语句：

II由编译器决定 b 和 e 的类型；参见 2.5.2节（第 61 页）

// b表示 v 的第一个元素，e表示 v 尾元素的下一位置

auto b = v.begin （） , e = v.end （） ; //b 和 e 的类型相同

end成员则负责返回指向容器（或 string 对象）“尾元素的下一位置（one past the end）" 的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的"尾后（offthe end）”元 素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所 有元素。end成员返网的迭代器常被称作尾后迭代器（off-the-end iterator）或者简称为尾 迭代器（end iterator）□特殊情况下如果容器为空，贝 lj begin和 end 返回的是同一个迭 代器。

\如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。

一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么。在上面的例子中， 使用 auto 关键字定义变量 b 和 e （参见 2.5.2节，第 61 页），这两个变量的类型也就是 begin和 end 的返冋值类型，第 97 页将对相关内容做更详细的介绍。

迭代器运算符

表 3.6列举了迭代器支持的一些运算。使用==和！=来比较两个合法的迭代器是否相 等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等；否 则就说这两个迭代器不相等。

| 表 3.6:标准容器迭代器的运算符 |                                                              |
| ---------------------------- | ------------------------------------------------------------ |
| *iter                        | 返回迭代器 iter 所指元素的引用                                 |
| iter-〉mem                   | 解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter) .mem    |
| ++iter                       | 令 iter 指示容器中的下一个元素                                 |
| ——iter                       | 令 iter 指示容器中的上一个元素                                 |
| iterl == iter2               | 判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同•个元 |
| iterl != iter2               | 素或者它们是同一个容器的尾后迭代器，则相等；反之，不相等     |

□oz>    和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必

须合法并确实指示着某个元素(参见 2.3.2节，第 48 页)。试图解引用一个非法迭代器或 者尾后迭代器都是未被定义的行为。

举个例子，3.2.3节(第 84 页)中的程序利用下标运算符把 string 对象的第一个字 母改为了大写形式，下面利用迭代器实现同样的功能：

string s(.’some string");

if (s .begin ()    ! = s .end () )    {    // 确保 s 非空

auto it = s .begin () ;    // it 表示 s 的第一个字符

*it = toupper (*it) ;    //将当前字符改成大写形式

}

本例和原来的程序一样，首先检查 S 是否为空，显然通过检查 begin 和 end 返回的结果 是否一致就能做到这一点。如果返回的结果一样，说明 s 为空；如果返回的结果不一样， 说明 s 不为空，此时 s 中至少包含一个字符。

我们在 if 内部，声明了一个迭代器变量 it 并把 begin 返回的结果赋给它，这样就 得到了指示 S 中第一个字符的迭代器，接下来通过解引用运算符将第一个字符更改为大写 形式。和原来的程序一样，输出结果将是，

Some string

将迭代器从一个元素移动到另外一个元素

迭代器使用递增(++)运算符(参见 1.4.1节，第 11 页)来从一个元素移动到下一个 元素。从逻辑上来说，迭代器的递增和整数的递增类似，整数的递増是在整数值上“加 1”, 迭代器的递增则是将迭代器“向前移动一个位置”。

![img](C++  Primer 5-41.jpg)



因为 end 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解 引用的操作。

之前有一个程序把 string 对象中第一个单词改写为大写形式，现在利用迭代器及其 递增运算符可以实现相同的功能：

[JP8>    //依次处理 s 的字符直至我们处理完全部字符或者遇到空白

for (auto it = s.begin(); it != s.end() && !isspace (*it); ++it)

*it = toupper (*it) ; //将当前字符改成大写形式

和 3.2.3节(第 84 页)的那个程序一样，上面的循环也是遍历 s 的字符直到遇到空白字符 为止，只不过之前的程序用的是下标运算符，现在这个程序用的是迭代器。

循环首先用 s .begin的返回值来初始化 it，意味着 it 指示的是 s 中的第一个字符 (如果有的话)=条件部分检查是否已到达 s 的尾部，如果尚未到达，则将 it 解引用的结

果传入 isspace 函数检查是否遇到了空白。每次迭代的最后，执行++it令迭代器刖移 ―个位置以访问 s 的下一个字符。

循环体内部和上一个程序 if 语句内的最后一句话一样，先解引用 it，然后将结果传 入 toupper 函数得到该字母对应的大写形式，再把这个大写字母重新赋值给 it 所指示 的字符。

关键概念：泛概编程

原来使用 C 或 Java 的程序员在转而使用 C++语言之后，会对 for 循环中使用！=而 非<进行判断有点儿奇怪，比如上面的这个程序以及 85 页的那个。C++程序员习惯性地 使用！=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标 准库提供的所有容器上都有效。    …

之前已经说过，只有 string 和 vector 等一些标准库类型有下标运算符，而并非 全都如此。与之类似，所有标准库容器的迭代器都定义了 ==和！=，但是它们中的大多 数都没有定义<运算符。因此，只要我们养成使用迭代器和！=的习惯，就不用太在意用 的到底是哪种容器类型。

迭代器类型

就像不知道 string 和 vector 的 size_type成员（参见 3.2.2节，第 79 页）到底 是什么类型一样，一般来说我们也不知道（其£是无须知道）迭代器的精确类型。而实际上， 那些拥有迭代器的标准库类型使用 iterator 和 const_iterator来表示迭代器的类型：

veotor<int>: : iterator it; // it 能读写 vector<int>的元素 string: :iterator it2;    // it2 能读写 string 对象中的字符

vector<int>: :const_iterator it3; // it3 只能读元素，不能写元素 string: :const_iterator it4;    // it4 只能读字符，不能写字符

const_iterator和常量指针（参见 2.4.2节，第 56 页）差不多，能读取佴不能修改它 所指的元素值。相反，iterator的对象可读可写。如果 vector 对象或 string 对象是 一个常量，只能使用 const_iterator；如果 vector 对象或 string 对象不是常量， 那么既能使用 iterator 也能使用 const_iterator。

术语：迭代器和迭代器炎哦

<M]



迭代器这个名词有三种不同的含义：可能是迭代器概念本身，也可能是指容器定义 的迭代器类型，还可能是指某个迭代器对象。

重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支 持一套操作，这套操作使得我们能访伺容器的元素或者从某个元素移动到另外一个元素。

每个容器类定义了一个名为.iterator的类型，该类型支持迭代器概念所规定的 一套操作。

begin和 end 运算符

begin和 end 返回的具体类型由对象是否是常量决定，如果对象是常量，begin和 end返回 const_iterator；如果对象不是常量，返回 iterator:

vector<int> v;

const vector<int> cv;

auto itl = v.begin () ;    // itl 的类型是 vector<int>:: iterator

auto it2 = cv.begin () ;    // it2 的类型是 vector<int>: :const_iterator

有时候这种默认的行为并非我们所要。在 6.2.3节(第 191 页)中将会看到，如果对象只 需读操作而无须写操作的话最好使用常量类型(比如 const_iterator)o为了便于专门

卜：,j得到 const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是 cbegin 和 cend：

auto it3 = v. cbegin () ; // it3 的类 3!是 vector<int>:: const_iterator

类似于 begin 和 end，上述两个新函数也分别返回指示容器第一个元素或最后元素下一 位置的迭代器。有所不同的是，不论 vector 对象(或 string 对象)本身是否是常量， 返回值都是 cons t_i ter ator»

结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望 进一步访问它的成员。例如，对于一个由字符串组成的 vector 对象来说，要想检查其元 素是否为空，令 it 是该 vector 对象的迭代器，只需检查 it 所指字符串是否为空就可 以了，其代码如下所示：

(*it) .empty()

注意，(*it> .empty()中的圆括号必不可少，具体原因将在 4.1.2节(第 121 页)介绍， 该表达式的含义是先对 it 解引用，然后解引用的结果再执行点运算符(参见 1.5.2节，第 20页)。如果不加圆括号，点运算符将由 it 来执行，而非 it 解引用的结果：

(*it) .empty ()    //解引用 it，然后调用结果对象的 empty 成员

\* it. empty ()    //错误：试图访问 it 的名为 empty 的成员，但 it 是个迭代器，

//没有 empty 成员

EUD>上面第二个表达式的含义是从名为 it 的对象中寻找其 empty 成员，显然 it 是一个迭代 器，它没有哪个成员是叫 empty 的，所以第二个表达式将发生错误。

为了简化上述表达式，C++语言定义了箭头运算符(->)。箭头运算符把解引用和成 员访问两个操作结合在一起 I 也就是说，it->niem和(*it) .mem表达的意思相同。

例如，假设用一个名为 text 的字符串向量存放文本文件中的数据，其中的元素或者 是一句话或者是一个用于表示段落分隔的空字符串。如果要输出 text 中第一段的内容， 可以利用迭代器写一个循环令其遍历 text，直到遇到空字符串的元素为止：

//依次输出 text 的每一行直至遇到第一个空白行为止 for (auto it = text.cbegin();

it != text.cend() && !it->empty(); ++it) cout « *it « endl;

我们首先初始化 it 令其指向 text 的第-个元素，循环重复执行直至处理完了 text的所 有元素或者发现某个元素为空。每次迭代时只要发现还有元素并且尚未遇到空元素，就输 出当前正在处理的元素。值得注意的是。因为循环从头到尾只是读取 text 的元素而未向 其中写值，所以使用了 cbegin和 cend 来控制整个迭代过程。

某些对 vector 对象的操作会使迭代器失效

3.3.2节(第 90 页)曾经介绍过，虽然 vector 对象可以动态地增长，何是也会有一

些副作用。已知的一个限制是不能在范围 for 循环中向 vector 对象添加元素。另外一 个限制是任何一种可能改变 vector 对象容量的操作，比如 push_back，都会使该 vector对象的迭代器失效。9.3.6节（第 315 页）将详细解释迭代器是如何失效的。

谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素-

WARNING

###### 3.4.1节练习

练习 3.21:请使用迭代器重做 3.3.3节（第 94 页）的第一个练习。

练习 3.22：修改之前那个输出 text 第一段的程序，首先把 text 的第一段全都改成大 写形式，然后再输出它。

练习 3.23:编写一段程序，创建一个含有 10 个整数的 vector 对象，然后使用迭代器 将所有元素的值都变成原来的两倍。输出 vector 对象的内容，检验程序是否正确。

###### 3.4.2迭代器运算    ®

迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都有支持递增运算 的迭代器，类似的，也能用==和！=对任意标准库类型的两个有效迭代器（参见 3.4节，第 95页）进行比较。

string和 vector 的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次 移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作迭代器运算

（iterator arithmetic）。其细节由表 3.7 列出。

| 表 3.7: vector和 string 迭代器支持的运算 |                                                              |
| ------------------------------------- | ------------------------------------------------------------ |
| iter + n                              | 迭代器加上--个整数值仍得一个迭代器，迭代器指示的新位置与原来相比 向前移动了若干个元素。结果迭代器或者指示容器内的-•个元素，或者指 示容器尾元素的下•位置 |
| iter - n                              | 迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比 向后移动了若干个元素，结果迭代器或者指示容器内的---个元素，或者指 示容器尾元素的下一位置 |
| iter1 += n                            | 迭代器加法的复合赋值语句，将 iterl 加 n 的结果赋给 iterl          |
| iterl -= n                            | 迭代器减法的复合赋值语句，将 iterl 减 n 的结果赋给 iterl          |
| iterl - iter2                         | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭 代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器 必须指向的是同一个容器中的元素或者尾元素的下-•位置 |
| ＞、＞=、＜、＜=                      | 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指 位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一 个容器中的元素或者尾元素的下一位置 |

迭代器的算术运算

可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干 个位置的迭代器。执行这样的操作时，结果迭代器或者指示原 vector 对象（或 string 对象）内的一个元素，或者指示原 vector 对象（或 string 对象）尾元素的下一位置。

举个例子，下面的代码得到一个迭代器，它指向某 vector 对象中间位置的元素：

//计算得到最接近 vi 中间元素的一个迭代器 auto mid = vi.begin() + vi.size() / 2;

如果 vi 有 20 个元素，vi . size (>/2得 10，此例中即令 mid 等于 vi .begin ()+10。 已知下标从 0 开始，则迭代器所指的元素是 vi [10]，也就是从首元素开始向前相隔 10 个位置的那个元素。

对于 string 或 vector 的迭代器来说，除了判断是否相等，还能使用关系运算符(<、 <=、>、>=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的 元素(或者尾元素的下一位置)。例如，假设 it 和 mid 是同一个 vector 对象的两个迭 代器，可以用下面的代码来比较它们所指的位置孰前孰后：

if (it < mid)

//处理 vi 前半部分的元素

C5E>    只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相

减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能 追上左侧的迭代器，其类型是名为 difference_type的带符号整型数。string和 vector都定义了 difference_type，因为这个距离可正可负，所以 dif ference_type是带符号类型的。

使用迭代器运算

使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的 值。二分搜索从序列中间的位置开始搜索，如果中间位置的元素正好就是要找的元素，搜 索完成；如果不是，假如该元素小于要找的元素，则在序列的后半部分继续搜素；假如该 元素大于要找的元素，则在序列的前半部分继续搜索。在缩小的范围中计算一个新的中间 元素并重复之前的过程，直至最终找到目标或者没有元素可供继续搜索。

下面的程序使用迭代器完成了二分搜索：

// text必须是有序的

// beg和 end 表示我们搜索的范围

auto beg = text.begin(), end = text.end();

auto mid = text.begin () + (end - beg) / 2; // 初始状态下的中间点 //当还有元素尚未检查并且我们还没有找到 sought 时执行循环

while (mid != end && *mid



sought) {



if (sought < *mid) end = mid;

else

beg = mid + 1; mid = beg + (end -



//我们要找的元素在前半部分吗？

//如果是，调整搜索范围使得忽略掉后半部分 //我们要找的元素在后半部分

//在 mid 之后寻找 beg) /2;    //新的中间点



程序的一开始定义了三个迭代器：beg指向搜索范围内的第一个元素、end指向尾元素的 下一位置、mid指向中间的那个元素。初始状态下，搜索范围是名为 text 的 vector〈string〉的全部范围。

循环部分先检查搜索范围是否为空，如果 mid 和 end 的当前值相等，说明已经找遍 了所有元素，此时条件不满足，循环终止。当搜索范围不为空时，可知 mid 指向了某个 元素，检查该元素是否就是我们所要搜索的，如果是，也终止循环。

当进入到循环体内部后，程序通过某种规则移动 beg 或者 end 来缩小搜索的范围。 如果 mid 所指的元素比要找的元素 sought 大，可推测若 text 含有 sought，则必出现 在 mid 所指元素的前面。此时，可以忽略 mid 后面的元素不再查找，并把 mid 赋给 end 即可。另一种情况，如果*mid比 sought 小，则要找的元素必出现在 mid 所指兀素的后 面。此时，通过令 beg 指向 mid 的下一个位置即可改变搜索范围。因为已经验证过 mid 不是我们要找的对象，所以在接下来的搜索中不必考虑它。

循环过程终止时，mid或者等于 end 或者指向要找的元素。如果 mid 等于 end，说 明 text 中没有我们要找的元素。

###### 3.4.2节练习

练习 3.24:请使用迭代器重做 3.3.3节（第 94 页）的最后一个练习。

练习 3.25: 3.3.3节（第 93 页）划分分数段的程序是使用下标运算符实现的，请利用迭 代器改写该程序并实现完全相同的功能，

练习 3.26:在 100 页的二分搜索程序中，为什么用的是 mid = beg + （end - beg） / 2. 而非 mid = （beg + end） /2; ?

###### 3.5数组

数组是一种类似于标准库类型 vector （参见 3.3节，第 86 页）的数据结构，但是在 性能和灵活性的权衡上又与 vector 有所不同。与 vector 相似的地方是，数组也是存放 类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与 vector 不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定， 因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。

![img](C++  Primer 5-42.jpg)



如果不清楚元素的确切个数，请使用 vector



###### 3.5.1定义和初始化内置数组

数组是一种复合类型（参见 2.3节，第 45 页）。数组的声明形如 a [d]，其中 a 是数 组的名字，d是数组的维度。维度说明了数组中元素的个数，因此必须大于 0。数组中元 素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须 是一个常量表达式（参见 2.4.4节，第 58 页）：

unsigned cnt = 42;    //不是常量表达式

constexpr unsigned sz = 42; // 常量表达式，关于 constexpr，参见 2.4.4 节（第 59 页）

int arr [10] ;    //含有 10 个整数的数组

int *parr [sz] ;    //含有 42 个整型指针的数组

string bad [cnt] ;    //错误：cnt不是常量表达式

string strs [get_size （） ] ; // 当 get_size 是 constexpr 时正确；否则错误

默认情况下，数组的元素被默认初始化（参见 2.2.1节，第 40 页）。

WARNING



和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默 认初始化会令数组含有未定义的值。

定义数组的时候必须指定数组的类型，不允许用 auto 关键字由初始值的列表推断类 型。另外和 vector—样，数组的元素应为对象，因此不存在引用的数组。

□S＞显式初始化数组元素

可以对数组的元素进行列表初始化（参见 3.3+1节，第 88 页），此时允许忽略数组的 维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反， 如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值 数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值（参见 3.3.1 节，第 88 页）：

| const unsigned sz | =3;          |      |                                        |
| ----------------- | ------------ | ---- | -------------------------------------- |
| int ial[sz] = {0, | 1, 2};       | //   | 含有 3 个元素的数组，元素值分别是 0, 1, 2 |
| int a2[] = {0, 1, | 2};          | //   | 维度是 3 的数组                          |
| int a3[5] = {0, 1 | r    2};     | //   | 等价于 a3[] = {0, 1, 2, 0, 0}          |
| string a4[3] = {" | hi", "bye"}; | //   | 等价于 a4[] = {"hi", "bye", ""}        |
| int a5[2] = {0,1, | 2}；         | //   | 错误：初始值过多                       |

字符数组的特殊性

字符数组有一种额外的初始化形式，我们可以用字符串字面值（参见 2.1.3节，第 36 页）对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个 空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：

char al[] = {'C'，'+，，，+'};    II列表初始化，没有空字符

char a2[] = {'C',    , '\0'};    //列表初始化，含有显式的空字符

char a3[] = "C++";    //自动添加表示字符串结束的空字符

const char a4 [6] = "Daniel";    //错误：没有空间可存放空字符！

al的维度是 3, a2和 a3 的维度都是 4, a4的定义是错误的。尽管字符串字面值"Daniel" 看起来只有 6 个字符，但是数组的大小必须至少是 7，其中 6 个位置存放字面值的内容， 另外 1 个存放结尾处的空字符。

不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： int a[] = {0, 1, 2};    //含有 3 个整数的数组

int a2[] = a;    //错误：不允许使用一个数组初始化另一个数组

a2 = a;    II错误：不能把一个数组直接赋值给另一个数组

„    一些编译器支持数组的赋值，这就是所谓的编译器矿展（compiler extension ）.、

/!\但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在 WARNING其他编译器上无法正常工作』

理解复杂的数组声明

和 vector—样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数 组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中， 定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了:

int *ptrs [10];

int &refs[10] = /* ? */; int (*Parray)[10] = &arr; int (&arrRef)[10] = arr;



// ptrs是含有 10 个整型指针的数组 //错误：不存在引用的数组 // Parray指向一个含有 10 个整数的数组 // arrRef引用一个含有 10 个整数的数组

默认情况下，类型修饰符从右向左依次绑定。对于 ptrs 来说，从右向左（参见 2.3.3节， 第 52 页）理解其含义比较简单：首先知道我们定义的是一个大小为 10 的数组，它的名字 是 ptrs，然后知道数组中存放的是指向 int 的指针。

但是对于 Parray 来说，从右向左理解就不太合理了。因为数组的维度是紧跟着被声 明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮 助我们更好地理解 Parray 的含义：首先是圆括号括起来的部分，*Parray意味着 Parray是个指针，接下来观察右边，可知道 Parray 是个指向大小为 10 的数组的指针， 最后观察左边，知道数组中的元素是 int。这样最终的含义就明白无误了，Parray是一 个指针，它指向一个 int 数组，数组中包含 10 个元素。同理，（SarrRef）表示 arrRef 是一个引用，它引用的对象是一个大小为 10 的数组，数组中元素的类型是 int。

当然，对修饰符的数量并没有特殊限制：

int * （sarry） [10] = ptrs; // arry是数组的引用，该数组含有 10 个指针

按照由内向外的顺序阅读上述语句，首先知道 arry 是一个引用，然后观察右边知道，arry 引用的对象是一个大小为 10 的数组，最后观察左边知道，数组的元素类型是指向 int 的 指针。这样，arry就是一个含有 10 个 int 型指针的数组的引用。

![img](C++  Primer 5-43.jpg)



要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺 序阅读。

###### 3.5.1节练习

练习 3.27：假设 txt_size是一个无参数的函数，它的返回值是 into 请回答下列哪 个定义是非法的？为^么？

unsigned buf_size = 1024;

(a) int ia [buf_size] ;    (b) int ia[4 * 7 - 14];

(c) int ia [txt_size () ] ;    (d) char st [ 11 ] = "fundamental";

练习 3.28:下列数组中元素的值是什么？

string sa[10]; int ia [ 10]; int main()    {

string sa2[10 ]; int ia2[10];

}

练习 3.29:相比于 vector 来说，数组有哪些缺点，请列举一些。

<~nn



###### 3.5.2访问数组元素

与标准库类型 vector 和 string 一样，数组的元素也能使用范围 for 语句或下标 运算符来访问。数组的索引从 0 开始，以一个包含 10 个元素的数组为例，它的索引从 0 到 9，而非从 1 到 10。

在使用数组下标的时候，通常将其定义为 size_t类型。size_t是一种机器相关的 无符号类型，它被设计得足够大以便能表示内存中任意对象的大小 f 在 cstddef 头文件 中定义了 size t类型，这个文件是 C 标准库 stddef.h头文件的 C++语言版本。

数组除了大小固定这一特点外，其他用法与 vector 基本类似。例如，可以用数组来 记录各分数段的成绩个数，从而实现与 3.3.3节(第 93 页)的程序一样的功能：

//以 10 分为一个分数段统计成绩的数量：0~9, 10~19，…，90-99, 100 unsigned scores [ 11 ] = {};    // 11个分数段，全部初始化为 0

unsigned grade;

while (cin » grade) { if (grade <= 100)

++scores [grade/10] ;    //将当前分数段的计数值加 1

}

与 93 页的程序相比，上面程序最大的不同是 scores 的声明。这里 scores 是一个含有 11个无符号元素的数组。另外一处不太明显的区别是，本例所用的下标运算符是由 语言直接定义的，这个运算符能用在数组类型的运算对象上。93页的那个程序所用的下标 运算符是库模板 vector 定义的，只能用于 vector 类型的运算对象。

与 vector 和 string—样，当需要遍历数组的所有元素时，最好的办法也是使用范 围 for 语句。例如，下面的程序输出所有的 scores:

for (auto i : scores)    //对于 scores 中的每个计数值

cout « i << "    //输出当前的计数值

cout « endl;

因为维度是数组类型的一部分，所以系统知道数组 scores 中有多少个元素，使用范围 for语句可以减轻人为控制遍历过程的负担。

检查下标的值

与 vector 和 string—样，数组的下标是否在合理范围之内由程序员负责检查，所 谓合理就是说下标应该大于等于 0 而且小于数组的大小。要想防止数组下标越界，除了小 心谨慎注意细节以及对代码进行彻底的测试之外，没有其他好办法。对于一个程序来说， 即使顺利通过编译并执行，也不能肯定它不包含此类致命的错误。

/A 大多数常见的安全问题都源于缓冲区溢出错误当数组或其他类似数据结构的 下标越界并试图访问非法内存区域时，就会产生此类错误

###### 3.5.2节练习

练习 3.30:指出下面代码中的索引错误。

constexpr size_t array_size = 10; int ia[array_size];

for (size_t ix = 1; ix <= array_size; ++ix) ia[ix] = ix;

练习 3.31:编写一段程序，定义一个含有 I0 个 int 的数组，令每个元素的值就是其下 标值。

练习 3.32：将上一题刚刚创建的数组拷贝给另外一个数组。利用 vector 重写程序，实 现类似的功能。

练习 3.33：对于 104 页的程序来说，如果不初始化 scores 将发生什么？

###### 3.5.3指针和数组

在 C++语言中，指针和数组有非常紧密的联系。就如即将介绍的，使用数组的时候编 译器一般会把它转换成指针。

通常情况下，使用取地址符（参见 2.3.2节，第 47 页）来获取指向某个对象的指针，取 地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定 位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：

string nums [] = {"one", "two", "three"}; // 数组的元素是 string 对象 string *p = &nums [0] ;    // p 指向 nums 的第一个元素

然而，数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换 为一个指向数组首元素的指针：

string *p2 = nums; // 等价于 p2 = &nums [0]

在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的 d指针。

由上可知，在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意 思。其中一层意思是当使用数组作为一个 auto （参见 2.5.2节，第 61 页）变量的初始值 时，推断得到的类型是指针而非数组：

int ia[] = {0,1,2, 3, 4,5, 6,7,8, 9}; // ia 是一个含有 10 个整数的教组 auto ia2 （ia） ;    // ia2是一个整型指针，指向 ia 的第一个元素

ia2 = 42;    //错误：ia2是一个指针，不能用 int 值给指针賦值

尽管 ia 是由 10 个整数构成的数组，但当使用 ia 作为初始值时，编译器实际执行的初始 化过程类似于下面的形式：

<JK1



auto ia2 （&ia[0] ） ; //昱然 ia2 的类叟是 int*

必须指出的是，当使用 decltype 关键字（参见 2.5.3节，第 62 页）时上述转换不会发 生，decltype （ia）返回的类型是由 10 个整数构成的数组：

II ia3是一个含有 10 个整数的数组 decltype（ia） ia3 = {0,1,2,3,4,5,6,7,8,9}; ia3 = p; //错误：不能用整型指针给数组赋值 ia3[4] = i; //正确：把 i 的值赋给 ia3 的一个元素

指针也是迭代器

与 2.3.2节（第 47 页）介绍的内容相比，指向数组元素的指针拥有更多功能。vector 和 string 的迭代器（参见 3.4节，第 95 页）支持的运算，数组的指针全都支持。例如， 允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

int arr[] = （0,1,2,3,4,5,6,7,8,91; int *p = arr; // p指向 arr 的第一个元素 ++P;    // p 指向 arr[l]

就像使用迭代器遍历 vector 对象中的元素一样，使用指针也能遍历数组中的元素。 当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位 置的指针。之前己经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素 的指针；不过获取尾后指针就要用到数组的另外一个特殊性质了。我们可以设法获取数组

尾元素之后的那个并不存在的元素的地址：

int *e = &arr [10] ; //指向 arr 尾元素的下一位置的指针

这里显然使用下标运算符索引了一个不存在的元素，arr有 10 个元素，尾元素所在位置 的索引是 9，接下来那个不存在的元素唯一的用处就是提供其地址用于初始化 e»就像尾 后迭代器(参见 3.4.1节，第 95 页)一样，尾后指针也不指向具体的元素。因此，不能对 尾后指针执行解引用或递增的操作。

利用上面得到的指针能重写之前的循环，令其输出 arr 的全部元素：

for (int *b = arr; b != e; ++b)

cout « *b « endl; // 输出 arr 的元素

标准库函数 begin 和 end

尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使用更简单、更安全， C++11新标准引入了两个名为 begin 和 end 的函数。这两个函数与容器中的两个同名成

®员(参见 3.4.1节，第 95 页)功能类似，不过数组毕竟不是类类型，因此这两个函数不是 成员函数。正确的使用形式是将数组作为它们的参数：

int ia[] = { 0,1,2,3, 4,5, 6, 7,8, 9}; // ia 是一个含有 10 个整数的数组

int *beg = begin (ia);    //指向 ia 首元素的指针

int *last = end (ia) ;    //指向 arr 尾元素的下一位置的指针

\J^> begin函数返回指向 ia 首元素的指针，end函数返回指向 ia 尾元素下一位置的指针， 这两个函数定义在 iterator 头文件中。

使用 begin 和 end 可以很容易地写出一个循环并处理数组中的元素。例如，假设 arr 是一个整型数组，下面的程序负责找到 arr 中的第一个负数：

// pbeg指向 arr 的首元素，pend指向 arr 尾元素的下一位置 int *pbeg = begin (arr), *pend = end(arr);

//寻找第一个负值元素，如果已经检查完全部元素则结束循环 while (pbeg != pend && *pbeg >= 0)

++pbeg;

首先定义了两个名为 pbeg 和 pend 的整型指针，其中 pbeg 指向 arr 的第一个元素,pend 指向 arr 尾元素的下一位置。while语句的条件部分通过比较 pbeg 和 pend 来确保可 以安全地对 pbeg 解引用，如果 pbeg 确实指向了一个元素，将其解引用并检查元素值是 否为负值。如果是，条件失效、退出循环：如果不是，将指针向前移动一位继续考査下一 个元素。

—个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与 }vector的 end 函数返回的与迭代器类似的功能。特别要注意，尾后指针不能 <3/执行解引用和递增操作。

指针运算

指向数组元素的指针可以执行表 3.6 (第 96 页)和表 3.7 (第 99 页)列出的所有迭代 器运算，这些运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针 和用在迭代器上意义完全一致。

给(从)一个指针加上(减去)某整数值，结果仍是指针。新指针指向的元素与原来

的指针相比前进了(后退了)该整数值个位置，

constexpr size_t sz = 5; int arr[sz] = {1,2,3,4,5};

int *ip = arr;    // 等价于 int *ip = &arr [0]

int *ip2 = ip + 4;    // ip2 指向 arr 的尾元素 arr [4]

ip加上 4 所得的结果仍是一个指针，该指针所指的元素与 ip 原来所指的元素相比前进了 4个位置。

给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向同一数 组的尾元素的下一位置：

//正确：arr转换成指向它首元素的指针；p指向 arr 尾元素的下一位置

int *p = arr + sz;    //使用警告：不要解引用！

int *p2 = arr + 10;    //错误：arr只有 5 个元素，p2的值未定义

当给 arr 加上 SZ 时，编译器自动地将 arr 转换成指向数组 arr 中首元素的指针。执行 加法后，指针从首元素开始向前移动了 sz (这里是 5)个位置，指向新位置的元素。也<J2£] 就是说，它指向了数组 arr 尾元素的下一位置。如果计算所得的指针超出了上述范围就 将产生错误，而且这种错误编译器一般发现不了。

和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指 向同一个数组当中的元素：

auto n = end (arr) - begin (arr); // n的值是 5，也就是 arr 中元素的数量

两个指针相减的结果的类型是一种名为 ptrdiff_t的标准库类型，和 size_t 一样， ptrdiff_t也是一种定义在 cstddef 头文件中的机器相关的类型。因为差值可能为负 值，所以 ptrdiff_t是一种带符号类型。

只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，就能利 用关系运算符对其进行比较。例如，可以按照如下的方式遍历数组中的元素：

int *b = arr, *e = arr + sz; while (b < e) {

//使用*b ++b;

}

如果两个指针分别指向不相关的对象，则不能比较它们：

int i=0, sz = 42; int *p = &i, *e = &sz;

//未定义的：p和 e 无关，因此比较毫无意义！ while (p < e)

尽管作用可能不是特别明显，但必须说明的是，上述指针运算同样适用于空指针(参 见 Z3.2节，第 48 页)和所指对象并非数组的指针。在后一种情况下，两个指针必须指向 同一个对象或该对象的下一位置。如果 p 是空指针，允许给 p 加上或减去一个值为 0 的 整型常量表达式(参见 2.4+4节，第 58 页)。两个空指针也允许彼此相减，结果当然是 0。

解引用和指针运算的交互

指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许 解引用该结果指针：

int ia[] = {0,2,4,6,8};    //含有 5 个整数的数组

int last = * （ia + 4） ;    //正确：把 last 初始化成 8，也就是 ia[4]的值

表达式* （ia+4>计算 ia 前进 4 个元素后的新地址，解引用该结果指针的效果等价于表达 式 ia[4]。

回忆一下在 3.4.1节（第 98 页）中介绍过如果表达式含有解引用运算符和点运算符， 最好在必要的地方加上圆括号。类似的，此例中指针加法的圆括号也不可缺少。如果写成 下面的形式：

last = *ia + 4; // 正确：last =4 等价于 ia[0] +4

含义就与之前完全不同了，此时先解引用 ia，然后给解引用的结果再加上 4。4.1.2节（第 121页）将对这一问题做进一步分析。

下标和指针

EZK> 如前所述，在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针。一 个典型的例子是当对数组使用下标运算符时，编译器会自动执行上述转换操作。给定

int ia[] = {0,2, 4,6, 8}; //含有 5 个整数的数组

此时，ia[0]是一个使用了数组名字的表达式，对数组执行下标运算其实是对指向数组元 素的指针执行下标运算：

int i = ia[2];

int *p = ia; i = * (p + 2);



// ia转换成指向数组首元素的指针 // ia[2]得到（ia + 2）所指的元素 // p指向 ia 的首元素

II等价于 i = ia[2]

只耍指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算: int    *p = &ia [2] ;    II    p指向索引为 2 的元素

int    j = p [ 1 ];    //    p[l]等价于* （p + 1），就是 ia [3]表示的那个元素

int    k = p [-2] ;    //    p [-2]是 ia [0]表示的那个元素

虽然标准库类型 string 和 vector 也能执行下标运算，但是数组与它们相比还是有 所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求，上 面的最后一个例子很好地说明了这一点。内置的下标运算符可以处理负值，当然，结果地 址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置 X

A

WARNING



内置的下标运算符所用的索引值不是无符号类型， string 不一样 o

这一点与 vector 和



###### 3.5.3节练习

练习 3.34：假定 pi 和 p2 指向同一个数组中的元素，则下面程序的功能是什么？什么 情况下该程序是非法的？ pi += p2 - pi;

练习 3.35:编写一段程序，利用指针将数组中的元素置为 0。

练习 3.36:编写一段程序，比较两个数组是否相等。再写一段程序，比较两个 vector 对象是否相等。

3.5.4

WARNING



C风格字符申

尽管 C++支持 C 风格字符串，但在 C++程序中最好还是不要使用它们，这是因 为 C 风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全 问题的根本原因。

字符串字面值是一种通用结构的实例，这种结构即是 C++由 C 继承而来的 C 风格字符串 (C-style character string)。C风格字符串不是一种类型，而是为了表达和使用字符串而形成 的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束(null terminated)o以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符('\0,)。 一般利用指针来操作这些字符串。

C标准库 String 函数

表 3.8列举了 C语言标准库提供的一组函数，这些函数可用于操作 C 风格字符串，它 们定义在 cstring 头文件中，cstring是 C 语言头文件 string. h的 C++版本。

表 3.8: C风格字符串的函数

| strlen(p)      | 返回 p 的长度，空字符不计算在内                                |
| -------------- | ------------------------------------------------------------ |
| strcmp(pi, p2) | 比较 pi 和 p2 的相等性。如果 pl==p2，返回 0；如果 pl>p2，返回一个正值；如果 pl<p2，返回一个负值 |
| strcat(pi, p2) | 将 p2 附加到 pi 之后，返回 pi                                     |
| strcpy(pi, p2) | 将 p2 拷贝给 pi，返回 pi                                         |

WARNING

表 3.8所列的函数不负责验证其字符串参数。

传入此类函数的指针必须指向以空字符作为结束的数组：

char ca[] = {'C',    // 不以空字符结束

cout « strlen(ca) « endl;    //严重错误：ca没有以空字符结束

此例中，ca虽然也是一个字符数组但它不是以空字符作为结束的，因此上述程序将产生 未定义的结果。strlen函数将有可能沿着 ca 在内存中的位置不断向前寻找，直到遇到 空字符才停下来。

比较字符串

比较两个 C 风格字符串的方法和之前学习过的比较标准库 string 对象的方法大相径 庭。比较标准库 string 对象的时候，用的是普通的关系运算符和相等性运算符：

string si = *'A string example"; string s2 = "A different string"; if (si < s2) // false： s2 小于 si

如果把这些运算符用在两个 c 风格字符串上，实际比较的将是指针而非字符串本身：

const char cal[] = "A string example"; const char ca2[] = "A different string"; if (cal < ca2) //未定义的：试图比较两个无关地址

谨记之前介绍过的，当使用数组的时候其实真正用的是指向数组首元素的指针(参见 3.5.3 节，第 105 页)。因此，上面的 if 条件实际上比较的是两个 const char*的值。这两个

<3221



<J23]



指针指向的并非同一对象，所以将得到未定义的结果。

要想比较两个 C 风格字符串需要调用 strcmp 函数，此时比较的就不再是指针了。如 果两个字符串相等，strcmp返回 0；如果前面的字符串较大，返回正值；如果后面的字 符串较大，返回负值：

if (strcmp (cal, ca2) < 0) // 和两个 string 对象的比较 si < s2 效果一样

目标字符串的大小由调用者指定

连接或拷贝 C 风格字符串也与标准库 string 对象的同类操作差别很大。例如，要想 把刚刚定义的那两个 string 对象 si 和 s2 连接起来，可以直接写成下面的形式：

//将 largeStr 初始化成 si、一个空格和 s2 的连接 string largeStr = si + " " + s2;

同样的操作如果放到 cal 和 ca2 这两个数组身上就会产生错误了。表达式 cal + ca2 试图将两个指针相加，显然这样的操作没什么意义，也肯定是非法的。

正确的方法是使用 strcat 函数和 strcpy 函数。不过要想使用这两个函数，还必须 提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的 空字符。下面的代码虽然很常见，但是充满了安全风险，极易引发严重错误：

//如果我们计算错了 largeStr的大小将引发严重错误 strcpy (largeStr,    cal) ;    //    把 cal 拷贝给 largeStr

strcat (largeStr,    ’• ’’)；    //    在 largeStr 的末尾加上一个空格

strcat (largeStr,    ca2) ;    //    把 ca2 连接到 largeStr 后面

一个潜在的问题是，我们在估算 largeStr 所需的空间时不容易估准，而且 largeStr 所存的内容一旦改变，就必须重新检查其空间是否足够。不幸的是，这样的代码到处都是, 程序员根本没法照顾周全。这类代码充满了风险而且经常导致严重的安全泄漏。

![img](C++  Primer 5-44.jpg)



对大多数应用来说，使用标准库 string 要比使用 C 风格字符串更安全、更高 效。

Pi24>



###### 3.5.4节练习

练习 3.37:下面的程序是何含义，程序的输出结果是什么？

const char ca[] = {r hr, r 'lz, zlz, 1or }; const char *cp = ca; while (*cp)    {

cout « *cp << endl;

++cp;

}

练习 3.38：在本节中我们提到，将两个指针相加不但是非法的，而且也没什么意义。请 问为什么两个指针相加没什么意义？

练习 3.39：编写一段程序，比较两个 string 对象 u 再编写一段程序，比较两个 C 风 格字符串的内容。

练习 3.40:编写一段程序，定义两个字符数组并用字符串字面值初始化它们；接着再定 义一个字符数组存放前两个数组连接后的结果。使用 strcpy 和 strcat 把前两个数组 的内容拷贝到第三个数组中。

###### 3.5.5与旧代码的接 U

很多 C++程序在标准库出现之前就已经写成了，它们肯定没用到 string 和 vector 类型。而且，有一些 C 杆程序实际上是与 C 语言或其他语言的接口程序，当然也无法使用 C++标准厍。因此，现代的 C 杆程序不得不与那些充满了数组和/或 C 风格字符串的代码衔 接，为了使这一工作简单易行，C++专门提供了一组功能。

混用 string 对象和 C 风格字符串    O

3.2.1节(第 76 页)介绍过允许使用字符串字面值来初始化 string 对象： string s ("Hello World") ; // s 的内容是 Hello World

更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组來替 代：

•允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值。

•在 string 对象的加法运算中允许使用以空字符结朿的字符数组作为其中一个运 算对象(不能两个运算对象都是)；在 string 对象的复合赋值运算中允许使用以 空字符结束的字符数组作为右侧的运算对象。

上述性质反过来就不成立了：如果程序的某处需要一个 C 风格字符串，无法直接用 string对象来代替它。例如，不能用 string 对象直接初始化指向字符的指针。为了完 成该功能，string专门提供了一个名为 c_str的成员函数：

char *str = s; //错误：不能用 string 对象初始化 char* const char *str = s.c_str(); // 正确

顾名思义，c_str函数的返回值是一个 C 风格的字符串。也就是说，函数的返回结果是<J25] 一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个 string对象的-样。结果指针的类型是 const char*，从而确保我们不会改变字符数 组的内容。

我们无法保证 c_str函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返 1]的数组失去效用。

/\ 如果执行完 c_str()函数后程序想一直都能使用其返回的数组，最好将该数 组重新拷贝一份。

WARNING

使用数组初始化 vector 对象

3.5.1节(第 102 页)介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也 不允许使用 vector 对象初始化数组。相反的，允许使用数组来初始化 vector 对象。要 实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了：

int int_arr[] = {0, 1, 2, 3, 4, 5};

// ivec有 6 个元素，分别是 int_arr中对应元素的副本 vector<int> ivec(begin(int_arr), end(int_arr));

在上述代码中，用于创建 ivec 的两个指针实际上指明了用來初始化的值在数组 int_arr 中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。此例中，使用标牟函 数 begin 和 end (参见 3.5.3节，第 106 页)來分别计算 int_arr的首指针和尾后指 针。在最终的结果中，ivec将包含 6 个元素，它们的次序和值 jp 与数组 int arr完全

一样。，

用于初始化 vector 对象的值也可能仅是数组的一部分：

// 拷贝三个元素：int_arr[l]、int_arr[2]、int_arr [3] vector<int> subVec（int_arr + 1, int_arr + 4）;

这条初始化语句用 3 个元素创建了对象 subVec, 3个元素的值分别來自 int_arr[l]、 int_arr[2]和 int_arr[3]。

建议：尽 a 使川榇准库类型而非数组

使用指针和数组很容易出错。一部分原因是概念上的问题：指针常用于底层操作， 因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误，特别是声明指针 时的语法错误。

现代的 C++程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应该 尽量使用 string，避免使用 C 风格的基于数组的字符串，

###### 3.5.5节练习

练习 3.41:编写一段程序，用整型数组初始化一个 vector 对象。

练习 3.42:编写-段程序，将含有整数元素的 vector 对象拷贝给一个整型数组。

###### O 3.6多维数绀

严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记 Ej26>这一点，对今后理解和使用多维数组大有益处。

当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本 身大小，另外-个维度表示其元素（也是数组）大小：

int ia[3] [4] ; //大小为 3 的数组，每个元素是含有 4 个整数的数组

//大小为 10 的数组，它的每个元素都是大小为 20 的教组，

//这些数组的元素是含有 30 个整数的教组

int arr [10] [20] [30] = {0}; //将所有元素初始化为 0

如 3.5.1节（第 103 页）所介绍的，按照由内而外的顺序阅读此类定义有助于更好地理解 其真实含义。在第一条语句中，我们定义的名字是 ia，显然 ia 是一个含有 3 个元素的数 组。接着观察右边发现，ia的元素也有自己的维度，所以 ia 的元素本身又都是含有 4 个 元素的数组。再观察左边知道，真正存储的元素是整数。因此最后可以明确第一条语句的 含义：它定义了一个大小为 3 的数组，该数组的每个元素都是含有 4 个整数的数组。

使用同样的方式理解 arr 的定义。首先 arr 是一个大小为 10 的数组，它的每个元素 都是大小为 20 的数组，这些数组的元素又都是含有 30 个整数的数组。实际上，定义数组 时对下标运算符的数量并没有限制，因此只要愿意就可以定义这样一个数组：它的元素还 是数组，下-级数组的元素还是数组，再下一级数组的元素还是数组，以此类推。

对予二维数组来说，常把第-•个维度称作行，第二个维度称作列。

多维数组的初始化

允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初 始化形式中，多维数组的每一行分别用花括号括了起来：

int ia[3][4] = {



//三个元素，每个元素都是大小为 4 的数组



{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}



//第 1 行的初始值 //第 2 行的初始值 //第 3 行的初始值



其中内层嵌套着的花括号并非必需的，例如下面的初始化语句，形式上更为简洁，完成的 功能和上面这段代码完全一样：

//没有标识每行的花括号，与之前的初始化语句是等价的 int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

类似于一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表 之内。如果仅仅想初始化每一行的第一个元素，通过如下的语句即可：

//显式地初始化每行的首元素    <J27~|

int ia[3][4] = { { 0 }, { 4 }, { 8 } };

其他未列出的元素执行默认值初始化，这个过程和一维数组（参见 3.5.1节，第 102 页）

一样。在这种情况下如果再省略掉内层的花括号，结果就大不一样了。下面的代码

//显式地初始化第 1 行，其他元素执行值初始化 int ix[3][4] = {0, 3r 6, 9};

含义发生了变化，它初始化的是第一行的 4 个元素，其他元素被初始化为 0。

多维数组的下标引用

可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。

如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类 型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将 是给定索引处的一个内层数组：

//用 arr 的首元素为 ia 最后一行的最后一个元素蛾值 ia[2] [3] = arr[0][0] [0];

int （&row） [4] = ia [ 1] ; //把 row 绑定到 ia 的第二个 4 元素数组上

在第一个例子中，对于用到的两个数组来说，表达式提供的下标运算符数量都和它们各自 的维度相同。在等号左侧，ia[2]得到数组 ia 的最后一行，此吋返回的是表示 ia 最后 一行的那个一维数组而非任何实际元素；对这个一维数组再取下标，得到编号为[3]的元 素，也就是这一行的最后一个元素。

类似的，等号右侧的运算对象包含 3 个维度。首先通过索引 0 得到最外层的数组，它 是一个大小为 20 的（多维）数组：接着获取这 20 个元素数组的第一个元素，得到一个大 小为 30 的一维数组；最后再取出其中的第一个元素。

在第二个例子中，把 row 定义成一个含有 4 个整数的数组的引用，然后将其绑定到 ia的第 2 行。

再举一个例子，程序中经常会用到两层嵌套的 for 循环来处理多维数组的元素：

constexpr size t rowCnt



\3. colCnt



4;



int ia [rowCnt] [colCnt] ; // 12 个未初始化的元素 //对于每一行

for (size_t i = 0; i != rowCnt; ++i)    {

//对手行内的每一列

for (size_t j = 0; j != colCnt; ++j)    {

//将晃素的位置索引作为它的值 ia[i][j] = i * colCnt + j;

}

}

外层的 for 循环遍历 ia 的所有元素，注意这里的元素是一维数组：内层的 for 循环则 遍历那些一维数组的整数元素。此例中，我们将元素的值设为该元素在整个数组中的序号。

<§使用范围 for 语句处理多维数组

CJ28> 由于在 C^ll新标准中新增了范围 for 语句，所以前一个程序可以简化为如下形式:

size_t cnt = 0;

for (auto &row : ia)

for (auto &col : row)

col = cnt;

++cnt;



//对于外层数组的每一个元素 {    //对于内层数组的每一个元素

II将下一个值赋给该元素 //将 cnt 加 1

这个循环赋给 ia 元素的值和之前那个循环是完全相同的，区别之处是通过使用范围 for 语句把管理数组索引的任务交给了系统来完成。因为要改变元素的值，所以得把控制变量 row和 col 声明成引用类型(参见 3.2.3节，第 83 页)„第一个 for 循环遍历 ia 的所有 元素，这些元素是大小为 4 的数组，因此 row 的类型就应该是含有 4 个整数的数组的引 用。第二个 for 循环遍历那些 4 元素数组中的某一个，因此 col 的类型是整数的引用。 每次迭代把 cnt 的值赋给 ia 的当前元素，然后将 cnt 加 1。

在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变 量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环：

for (const auto &row : ia) //对于外层数组的每一个元素 for (auto col : row)    //对于内层数组的每一个元素

cout << col << endl;

这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型， 这是为了避免数组被自动转成指针(参见 3.5.3节，第 105 页)。假设不用引用类型，则循 环如下述形式：

for (auto row-: ia)

for (auto col : row)

程序将无法通过编译。这是因为，像之前一样第一个循环遍历 ia 的所有元素，注意这些 元素实际上是大小为 4 的数组。因为 row 不是引用类型，所以编译器初始化 row 时会自 动将这些数组形式的元素(和其他类型的数组一样)转换成指向该数组内首元素的指针。 这样得到的 row 的类型就是 int*，显然内层的循环就不合法了，编译器将试图在一个 int*内遍历，这显然和程序的初衷相去甚远。

![img](C++  Primer 5-45.jpg)



要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的 控制变量都应该是引用类型。

指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组••，    <J29~I

因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向 第一个内层数组的指针：

int ia[3] [4] ;    //大小为 3 的数组，每个元素是含有 4 个整数的数组

int (*p) [4] = ia;    // p指向含有 4 个整教的数组

p = &ia [2] ;    // p指向 ia 的尾元素

根据 3.5.1节(第 103 页)提出的策略，我们首先明确(*p)意味着 p 是一个指针。接着观 察右边发现，指针 p 所指的是一个维度为 4 的数组；再观察左边知道，数组中的元素是整 数。因此，p就是指向含有 4 个整数的数组的指针。

在上述声明中，圆括号必不可少：

/    int *ip[4] ;    //整型指针的数组

int (*ip) [4];    //指向含有 4 个整数的数组

随着 C++11新标准的提出，通过使用 auto 或者 decltype (参见 2.5.2节，第 61 页)就能尽可能地避免在数组前面加上一个指针类型了：

//输出 ia 中每个元素的值，每个内层数组各占一行

// p指向含有 4 个整数的数组

for (auto p = ia; p != ia + 3; ++p)    {

// q指向 4 个整数数组的首元素，也就是说，q指向一个整数 for (auto q = *p; q != *p + 4; ++q)

cout « *q « cout « endl;

外层的 for 循环首先声明一个指针 p 并令其指向 ia 的第一个内层数组，然后依次迭代直 到 ia 的全部 3 行都处理完为止。其中递增运算++P负责将指针 p 移动到 ia 的下一行。

内层的 for 循环负责输出内层数组所包含的值。它首先令指针 q 指向 p 当前所在行 的第一个元素。*p是一个含有 4 个整数的数组，像往常一样，数组名被自动地转换成指 向该数组首元素的指针。内层 for 循环不断迭代直到我们处理完了当前内层数组的所有 元素为止。为了获取内层 for 循环的终止条件，再一次解引用 P 得到指向内层数组首元 素的指针，给它加上 4 就得到了终止条件。

当然，使用标准库函数 begin 和 end (参见 3.5.3节，第 106 页)也能实现同样的功 能，而且看起来更简洁一些：

// p指向 ia 的第一个数组

for (auto p = begin(ia); p != end(ia); ++p)    {

// q指向内层数组的首元素

for (auto q = begin(*p); q != end(*p); ++q)

cout « *q <<'’；//输出 q 所指的整数值



cout « endl;

1~130>在这一版本的程序中，循环终止条件由 end 函数负责判断。虽然我们也能推断出 P 的类 型是指向含有 4 个整数的数组的指针，q的类型是指向整数的指针，但是使用 auto 关键 字我们就不必再烦心这些类型到底是什么了。

类型别名简化多维数组的指针

读、写和理解一个指向多维数组的指针是一个让人不胜其烦的工作，使用类型别名（参 见 2.5.1节，第 60 页）能让这项工作变得简单一点儿，例如：

using int_array = int [ 4 ] ; / /新标准下类型别名的声明，参见 2.5.1节（第 60 页） typedef int int_array [ 4 ] ; / / 等价的 typedef 声明，参见 2.5•丨节（第 60 页）

//输出 ia 中每个元素的值，每个内层数组各占一行 for （int_array *p = ia; p != ia 4- 3; ++p）    {

for （int *q = *p; q != *p + 4; ++q） cout << *q << '';

cout « endl;

}

程序将类型“4个整数组成的数组”命名为 int_array，用类型名 int_array定义外 层循环的控制变量让程序显得简洁明了。

###### 3.6节练习

练习 3.43：编写 3 个不同版本的程序，令其均能输出 ia 的元素。版本 1 使用范围 for 语句管理迭代过程；版本 2 和版本 3 都使用普通的 for 语句，其中版本 2 要求用下标 运算符，版本 3 要求用指针。此外，在所有 3 个版本的程序中都要直接写出数据类型， 而不能使用类型别名、auto关键字或 decltype 关键字。

练习 3.44:改写上一个练习中的程序，使用类型别名来代替循环控制变量的类型。

练习 3.45:再一次改写程序，这次使用 auto 关键字。

##### 小结

<J3E



string和 vector 是两种最重耍的标准库类型。string对象是一个可变长的字符 序列，vector对象是一组同类型対象的容器。

迭代器允许对容器中的对象进行间接访问，对于 string 对象和 vector 对象來说， 可以通过迭代器访问元素或者在元素间移动。

数组和指向数组元素的指针在一个较低的层次上实现了与标准库类型 string 和 vector类似的功能。一般来说，应该优先选用标准库提供的类型，之后再考虑 C++语言 内置的低层的替代品数组或指针。

##### 术语表

begin是 string 和 vector 的成员，返 回指向第• •个元素的迭代器。也是•个标 准庳函数，输入一个数组，返回指向该数 组首元素的指针。

缓冲区溢出(bufferoverflow) •种严重的

程序故障，：t耍的原因是试图通过一个越 界的索引访问容器内容，容器类型包括 string、vector 和数组等。

C风格字符串(C-style string)以空字符

结束的字符数组。字符串字面值是 C 风格 字符串，C风格字符串容易出错。

类模板(class template)用于创建具体类

类型的模板。要想使用类模板，必须提供 关于类型的辅助信息。例如，要定义一个 vector对象需要指定元素的类型： vector<int>包含 int 类型的元素。

编译器扩展(compilerextension)某个特

定的编译器为 C++语言额外增加的特性。 基于编译器扩展编写的程序不易移植到其 他编译器上。

容器(container)是一种樂型，其对象容 纳了…组给定类型的对象。vector是一 种容器类型。

拷贝初始化(copy initialization)使用赋

值号(=)的初始化形式。新创建的对象是 初始值的一个副本。

difference_type 由 string 和 vector 定 义的-种带符号整数类型，表示两个迭代 器之间的距离。

直接初始化(direct initialization)不使用

赋值号(=)的初始化形式。

empty是 string 和 vector 的成员，返 回一个布尔值。当对象的大小为 0 吋返冋 真否则返回假。

end是 string 和 vector 的成员，返回 一个尾后迭代器。也是一个标准库函数， 输入一个数组，返回指向该数组尾元素的 下-位置的指针。

getline在 string 头文件中定义的__ -个函 数，以一个 istream 对象和••-个 string 对象为输入参数。该函数首先读取输入流的 内容直到遇到换行符停止，然后将读入的数 据存入 string 对象，最后返回 istream 对象。其中换行符谈入何是不保留。

索引(index)是下标运算符使用的值。 表示耍在 string 对象、vector对象或 者数组中访问的…个位置。

实例化(instantiation)编译器生成_—个

指定的模板类或函数的过程》

迭代器(iterator)是•种类型，用于访问

容器中的元素或者在元素之間移动。

迭代器运算(iterator arithmetic )是

string或 vector 的迭代器的运算：迭 代器与整数相加或相减得到一个新的迭代 器，与原來的迭代器相比，新迭代器向前 或向后移动了若干个位置。两个迭代器相 减得到它们之间的距离，此时它们必须指 向同一个容器的元素或该容器尾元素的下 一位置。

以空字符结束的字符串(null-terminated string)是一个字符串，它的最后一个字 符后而还跟着一个空字符('\0，)0

尾后迭代器(off-the-end iterator) end

函数返冋的迭代器，指向•个并不存在的 元素，该元素位丁•容器尾元素的下一•位置。

指针运算(pointer arithmetic)是指针类

型支持的算术运算。指向数组的指针所支 持的运算种类与迭代器运算-样。

prtdiff_t是 cstddef 头支件中定义的一种 与机器实现有关的带符吁整数类型，它的 空间足够人，能够表示数组中任意两个指 针之间的距离。

push_back 是 vector 的成 izj，|nj vector对象的末嵐添加元素。

范围 for 语句(range for)    ••种控制语句，

讨以在值的一个特定集合内迭代。

size是 string 和 vector 的成员，分别 返问字符的数 S•或元素的数量。返回值的 类型是 size_typeo

size_t是 cstddef 头文件中定义的一•种 与机器实现有关的无符号整数类型，它的 空問足够大，能够表示任意数组的大小。

size」ype 是 string 和 vector 定义的 类型的名字，能存放下任意 string 对象 或 vector 对象的大小。在标准阵中， s i z e_type被定义为无符兮类型。 string是一种标准库类型，表示字符的序列。

using 声明(using declaration)令命名空

问中的某个名字可被程序直接使用。 using命名空间名字；

L:述语句的作用是令程序可以直接使用茗 字，而无须写它的前缀部分余名空 7 献：：。

值初始化(valueinitialization)是一-种初

始化过程。内置类型初始化为 0，类类型由

类的默认构造函数初始化。只有当类包含 默认构造函数吋，该类的对象才会被值初 始化。对于容器的初始化来说，如果只说 明了容器的大小而没有指定初始值的话， 就会执行值初始化。此时编译器会生成…-个值，而容器的元素被初始化为该值。

vector是一种标准库类型、容纳某指定类 型的-组元素。

++运算符 C++ operator)是迭代器和指针

定义的递增运算符。执行“加 1”操作使得 迭代器指向下-…个元素。

[]运算符([]operator)下标运算符。ob j [ j ] 得到容器对象 ob j中位置 j 的那个元素。 索引从 0 开始，第一个元素的索引是 0，

尾元素的索引是 obj . size ()-1。下标运 算符的返冋值是一个对象。如果 P 足指针、 n是整数，则 p [n]与* (p+n)等价。

->运算符> operator)箭头运算符，该运

算符综合了解引用操作和点操作。a->b等 价于(*a) ,b.

<<运算符(《 operator)标准阼类型 string 定义的输出运算符，负。责输出 string 对 象中的字符。

\>>运算符(>> operator)标准库类型

string定义的输入运算符，负责读入一 组字符，遇到空 fi 停止，读入的内容赋给 运算符右侧的运算对象，该运算对象应该 是一个 string 对象。

!运算符(！ operator)逻辑非运算符，将它

的运算对象的布尔值取反，如果运算对象 是假，则结果为真，如果运算对象是真， 则结果为假。

&&运算符(&& operator)逻辑与运算符，

如果两个运算对象都是真，结果为真。只 有当左侧运算对象为真时才会检査右侧运 算对象。

II运算符(|| operator)逻辑或运算符，任

何一个运算对象是真，结果就为真。只有 当左侧运算对象为假吋才会检査右侧运算 对象。
