---
title: 02 两个数的和
toc: true
date: 2019-06-26
---
# 可以补充进来的

- 对于 dict 的在查找问题中的使用还是要总结下的。

# 两个数的和


数学课上，老师出了一道题目，要求在给定的一些数字中找出两个数，使得它们的和为 $N$ ，前提是这些数据中保证有答案，并且只有一个答案。例如给定 5 个数字：3、4、5、7、10，从中选择两个数使它们的和为 11，可以选择 4 和 7，如图 3.3所示，这个问题该如何解决呢？


<center>

![](http://images.iterate.site/blog/image/20190626/nUnsP5rKSRl8.png?imageslim){ width=55% }

</center>

## 问题求解 1

在上面的例子中，可以把数据放到一个数组中，并设置目标值 target，问题就变成了在数组中寻找两个数使得它们的和为目标数，并返回它们的编号，还要注意编号不是下标，而是数组的下标 +1。

先来看第一个办法，可以使用第 2 章中介绍的双指针的方法来解决这个问题。为了找到两个元素的和为目标值，先将数组从小到大排序。由于最后要得到的是两个数的原有编号，而不是两个数本身，因此需要保留原有数据的下标，那么，排序时就需要把数据复制到一个新的数组中，然后对新的数组进行排序。

数组排序后，就可以开始查找了。建立两个指针 left 和 right，分别指向新数组的第一个元素和最后一个元素。如果两个指针指向的两个数据相加的和等于目标值，那么查找结束，返回这两个数的下标；如果它们的和小于目标值，则说明 left 指向的数据太小了，需要让 left 指针向右移动一位；如果它们的和大于目标值，这说明 right 指向的数据太大了，需要让 right 指针向左移动一位。重复这个过程，直到找到答案。查找过程如图 3.4、图 3.5 和图 3.6 所示。

初始状态：

<center>

![](http://images.iterate.site/blog/image/20190626/Qa454w101K4o.png?imageslim){ width=55% }
</center>

数据和大了移动右指针：

<center>

![](http://images.iterate.site/blog/image/20190626/Xv5pNqdk0Dh3.png?imageslim){ width=55% }
</center>

数据和小了移动左指针：

<center>

![](http://images.iterate.site/blog/image/20190626/2AAIOiugxkQ2.png?imageslim){ width=55% }
</center>

由于 left 一直向右移动，right 一直向左移动，总有一个时刻 left 和 right 会重合甚至 left 比 right 还要大，那么这说明数组中没有两个数的和是目标值。由于数据里一定存在两个数的和为目标值，因此这种情况并不会出现。

使用这种方法找到的两个元素的下标是新数组的下标，并不是原始数据的下标。为了得到想要的答案，还需要在原始数组中查找这两个元素的位置，并存储到 res 数组中。来看一下最终代码吧。

## 解法 1 的最终代码

解法 1 的最终代码如下所示。

```py
def two_sum(nums, target):
    res = []  # 存放结果编号数据
    newnums = nums[:]  # 深拷贝，把原数据拷贝到 newnums 里
    newnums.sort()  # 对新数组排序
    print(newnums)
    left = 0
    right = len(newnums) - 1  # 定义 left 和 right 指针分别指向新数组的开头和结尾
    while left < right:
        if newnums[left] + newnums[right] == target:
            for i in range(0, len(nums)):  # 在原始数组中寻找第一个元素的原始下标
                if nums[i] == newnums[left]:
                    res.append(i)  # 下标加入到结果集
                    break
            for i in range(len(nums) - 1, -1, -1):  # 在原始数组中寻找第二个元素的原始下标
                if nums[i] == newnums[right]:
                    res.append(i)  # 下标加入到结果集
                    break
            res.sort()
            break
        elif newnums[left] + newnums[right] < target:
            left = left + 1  # 让 left 指针向右移动一位
        elif newnums[left] + newnums[right] > target:
            right = right - 1  # 让 right 指针向左移动一位
    return (res[0] + 1, res[1] + 1)  # 返回结果集


nums = [3, 4, 5, 7, 10]
target = 11
res = two_sum(nums, target)
print(res)
```

输出：

```
[3, 4, 5, 7, 10]
(2, 4)
```

<span style="color:red;">这样找只能找到一对呀？多对的时候怎么处理？</span>

这种算法的前提是要先进行一次排序，查找效率不是很高，如何才能提高查找效率呢，是不是有更好的算法呢？

## 问题求解 2

在第一种解法的基础上，我们接下来研究更加高效的算法，来看一下哈希函数是怎么帮助解决这个问题的。<span style="color:red;">嗯嗯，好的，想知道这个怎么使用 hash 的。</span>

首先，看一下在双指针解法中，时间都浪费在了哪里。双指针算法的前提是数据有序，所以解法 1 的第一步是对数据排序，即便是使用最优秀的排序算法也是比较耗时的。接下来，为了寻找答案，左指针和右指针在不断移动，当左右指针发现了答案时，由于需要返回原始数据的位置，还要去原始数组中去寻找这两个数据的位置。这两处操作都是比较耗时的，而且没有必要。<span style="color:red;">是的，的确是耗时的。</span>

那么，有什么办法不需要排序数据，而且不需要寻找原始位置呢？答案就是哈希算法了。

为了使用哈希算法，我们需要先建立一个字典，用于存放数据和下标的对应关系，如下所示。注意：字典是一个键值对的集合。

那么，这个字典是如何帮助我们解决问题的呢？本题是寻找两个数使得它们的和为目标数，每当给定一个数 m，其实问题就变成了数据集合中是否有一个数是 target-m，可以通过使用字典记录目前已经出现过哪些数字，这样每次出现一个新的数字时，就去字典中查找有没有对应的数字，如果有则说明找到了，没有的话就把该数放到字典中去，以备之后查询使用。注意：字典使用 `dict[key]=value` 来记录键值对的关系。

使用字典记录数据，再去字典中查找数据的方式就是我们所说的哈希方法，使用统一的哈希函数把数据对存储到字典中，再使用统一的哈希函数从字典中把数据取出来，理论上是可以达到常数级别的查询速度的。

让我们来看一下最终代码吧。

## 解法 2 的最终代码

解法 2 的最终代码如下所示：

```py
def two_sum(nums, target):
    dict = {}
    for i in range(len(nums)):
        m = nums[i]  # 定义 m 为当前待查询数字
        if target - m in dict:  # 判定 target-m是否已经在字典之中
            return (dict[target - m] + 1, i + 1)  # 如果已经存在，则返回这两个数的下标回来
        dict[m] = i  # 如果不存在则记录键值对


nums = [3, 4, 5, 7, 10]
target = 11
res = two_sum(nums, target)
print(res)
```


输出：

```
(2, 4)
```

<span style="color:red;">哈哈，哇塞，原来是这个，之前我看到过这个的，嗯，之前知道他是用键值对的方式来减少查找时间的，嗯，归属于 hash 也对，不错，很好。nice。对于 dict 的在查找问题中的使用还是要总结下的。</span>

显而易见，使用哈希算法解决查找问题，不仅效率高、代码少而且容易理解，日后遇到查询问题能用哈希算法的时候，一定要记得使用哈希算法。本问题还有一些后续问题，比如求三个数的和以及求四个数的和的问题，有兴趣的读者可以继续研究这些问题。



# 相关

- 《你也能看得懂的 python 算法书》
