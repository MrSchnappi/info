---
title: 05 树的右侧
toc: true
date: 2019-07-01
---
5.5 树的右侧
到了秋天，采摘园里的柠檬都熟了，看着这硕果累累的景象，小朗朗和小伙伴贝贝相约去采摘园摘柠檬。为了提高采摘速度，小朗朗和贝贝约定每人采摘每棵树一半的柠檬，同时为了可持续发展，只采摘柠檬树最外层的柠檬。
假如柠檬树的每个树干只有两个树枝、一个树枝、零个树枝三种可能，那么一棵树可以被看作一棵二叉树，小朗朗的任务是摘树的右侧的柠檬，让我们来帮小朗朗数一下，他可以摘到哪些柠檬吧。
5.5.1 问题求解
这个问题可以用二叉树来表示，如图 5.11和图 5.12所示。

对于上面的柠檬树 1 来说，小朗朗可以摘到的柠檬为 1、3、6、7这 4 个柠檬。对于柠檬树 2 来说，小朗朗可以摘到的柠檬为 1、3、5、7，也就是说要摘下站在柠檬树右边能看到的柠檬。注意：二叉树是每个节点最多有两个子树的树结构。
那么，此时，本题的问题变成了给定一棵二叉树，想象你自己站在该二叉树的右侧，按照从根节点到底端叶子节点的顺序，找出可以获取的节点的值的问题。
为了表示这样的柠檬树，需要定义一个二叉树的结构，代码如下：
根据前面的分析，为了找出二叉树右侧的节点的值，我们需要一层一层地取出每一层的数据，然后把每层的数据放入最终结果中。我们为每个节点设定一个层级，比如根节点的层级是第 1 层，根节点的子节点的层级是第 2 层，再往下的节点的层级依次递增，如图 5.13所示。
对于树的遍历问题，我们通常会使用广度优先遍历算法或者深度优先遍历算法，对于这个问题，该选择哪一种算法呢？由于最终的结果是每一层节点的最后一个节点，那么使用广度优先遍历会更好一些。
图 5.13 二叉树的层次结构
这个题目同样是遍历问题，或者说是求二叉树广度优先遍历的一种变形，我们只需要保存每一层最右边的数字即可。既然是广度优先遍历算法，那么一定要用到队列，使用队列来保存待处理的节点。首先处理根节点，存储根节点的值，同时建立存放结果的列表，代码的框架如下：
使用广度优先遍历算法的时候，需要先取出每层的节点，然后处理该节点，之后把下一层的左右子节点都存入队列，依此类推，到队列为空，处理就完毕了。
那么本题的核心问题是如何找到每层的最后一个节点，为了解决这个问题，可以在处理每层数据的时候记录一下当前层的节点数 N，那么本层最后一个节点就是当前队列里的第 N 个数据。在寻找每层最后一个元素的同时，把每个节点的左右节点加入队列，一直到这一层的所有元素都分析完为止。对于每层节点的分析，使用一个 for 循环来处理。整个程序在队列为空时结束：


注意：数组下标从 0 开始，所以代码中每层最后一个元素是 N-1。
在上面的例子中，通过广度优先遍历就可以自顶向下找到这些具有下画线的节点，每条线上的数字代表访问它们的顺序。如图 5.14所示。
图 5.14 二叉树的广度优先遍历
5.5.2 最终代码
整合上面的代码，我们来看完整的代码，如代码 5.4所示。
代码 5.4 利用广度优先遍历解决树的右侧问题
当然，本题还有其他解法。比如，可以改变遍历的顺序，即按先访问当前节点，再访问右节点，最后访问左节点的顺序。每次都将节点放进队列，但是在取节点的时候，只需记录第一个节点即可，其他的都可以释放掉，这个方法留给读者自己去实现。
