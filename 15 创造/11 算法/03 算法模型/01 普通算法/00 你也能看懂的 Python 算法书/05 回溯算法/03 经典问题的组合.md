---
title: 03 经典问题的组合
toc: true
date: 2019-07-01
---
6.3 经典问题的组合
小朗朗这学期想上两门选修课，他有 4 种选择：A。微积分，B。音乐，C。烹饪，D。设计。小朗朗一共有多少种不同的选课组合呢？用数学方法很容易得出一共有种不同的选课组合，不过，我们想用计算机把这些组合一一输出。
6.3.1 问题求解
如图 6.9所示，有两个空位，4个选项。下面模拟一下选课，以便找到解题思路。
首先，第一次选课的时候有 4 种选择，A、B、C、D。假设选择 A，那么，第二次选课时剩余三个选择：B、C、D，如图 6.10所示。
图 6.9 选课
图 6.10 第一次选课
假设选择了 B，得出的是 AB 这个选课组合，如图 6.11所示。
再来看看其他的组合。这次我们首先选择 B。在第二次选课的时候，我们的选项中没有 A，因为从 A 开始的时候我们已经得出 AB 这个选课组合了。所以，第二次选课我们的选项是：C、D，如图 6.12所示。
图 6.11 第二门课选择 B
图 6.12 第一次选择 B
假设第二门课选择了 C，得到 BC 这个选课组合，如图 6.13所示。
同样的，我们也可以从 C 和 D 开始。从 C 开始的话，第二门课只有 D 一个选项。从 D 开始的话，A、B、C都不再是选项，如图 6.14所示。
图 6.13 BC组合
图 6.14 从 D 开始的情况
综上可总结出，第一门课程有 4 种选项，第二门课程的选项不包括第一门课程以及第一门课程之前的课程。
有了这个思路，让我们看一下不用回溯写出来的代码是什么样的。


注意，我们没有把课程加入原本的组合列表，而是每一次都创建一个新的组合列表。这样做是因为每一次加的课程都是不同的。加入第一门课时，创建了组合列表[A],[B],[C],[D]，加入第二门课时，创建了组合列表[A,B],[A,C],[A,D],[B,C],[B,D],[C,D]。
另外注意，我们加入第一门课后更新了课程列表：
06　newArray=array[i+1:]　　　　　　　　 #更新课程列表
也就是说，第二门课的选择是已选的第一门课之后的课程。比如，第一门课选了 B，更新后的课程列表是[C,D]。
这是不用回溯的写法，如果 n 的值很小，这样写没什么问题，前提是你要知道 n 是多少。但是，一旦 n 变大，代码就会变得烦琐，所以我们应该利用回溯来改善以上代码。
6.3.2 最终代码
定义一个 helper 方法帮我们概括上面重复的代码。以下是 helper 方法的完整代码。你可以先看一看它和上面的代码有什么区别，下面我们会详细解释。
首先我们来看一下 helper 方法的参数。
array，课程列表，存储可选课程。如果第一次调用时 array=[A,B,C,D]，那么第二次调用时 array 可能等于[B,C,D]、[C,D]或者[D]。
n，选课数量。在这 4 门课中选择 2 门的话，n=2。n是一个常量，不会改变。
solution，当前的组合列表。solution一开始为空，随着每一门课程的加入慢慢增长。
接下来看一下 helper 方法履行的任务。
1.向组合列表中加入一门课程。
01　 def helper（self,array,n,solution）:
02　　　 for i in range（len（array））:　　　　　　　　　 #array中的科目选项
03　　　　　newSolution=solution+[array[i]]　　　 #加入组合列表
array中是我们剩余的可选科目，solution是我们现有的、未满的组合列表。依次把 array 中的可选科目加入新创建的组合列表中。我们没有继续使用原有的组合列表，因为每一次加入的课程不同。
2.更新课程列表。
04　　newArray=array[i+1:]　　　　　　　　　　 #创建新课程列表，更新列表
newArray 是下一门课可选的课程。我们新建了一个列表，而不是更新原有的列表，因为每一次剩下的可选课程都不同。
3.继续选择剩余课程。
05　　self.helper（newArray,n,newSolution）　　　　 #调用 helper 方法选择剩余课程
有了 newSolution 与 newArray 后就可以调用 helper 方法继续选择剩余的课程了。
4.检查是否已选择 n 门课程。
01　 def helper（self,array,n,solution）:
02　　　 if len（solution）==n:　　　　　　　　　　#如果 solution 中有 n 门课程
03　　　　　print（solution）　　　　　　　　　　　#输出结果
04　　　　　return　　　　　　　　　　　　　　　　 #返回
如果不设定一个结束条件的话，helper 方法不知道什么时候返回结果。所以，在一开始就要明确，如果 solution 中已经有了 n门课程，就输出组合列表。输出后，返回上一次被调用的地方，继续没有走完的 for 循环，输出其他组合。
有了 helper 方法，只需要一开始的时候调用一次它就可以了。
01　def solveCombination（self,array,n）:
02　　　 self.helper（array,n,[]）　　　　　　 #调用 helper 方法注意：一开始传入的 solution 是一个空的列表，因为还没有开始选课。
其实，和不用回溯的代码对照一下你会发现两者没有本质上的区别。不用回溯就是把 helper 方法展开，那样写会十分麻烦但逻辑上和回溯的代码没有差别。
来看一下完整的代码，如代码 6.3所示。
代码 6.3 用回溯算法解决组合问题


来试试解决小朗朗的问题：
Solution（）.solveCombination（[＇A＇,＇B＇,＇C＇,＇D＇],2）
下面是输出结果：
[＇A＇,＇B＇]
[＇A＇,＇C＇]
[＇A＇,＇D＇]
[＇B＇,＇C＇]
[＇B＇,＇D＇]
[＇C＇,＇D＇]
