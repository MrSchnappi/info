---
title: 05 八皇后问题
toc: true
date: 2019-07-01
---
6.5 八皇后问题
保安部负责人小安面临着一个难题，他需要在一个 8×8公里的区域里修建 8 个保安站点，并确保每一行、每一列和每一条斜线上都只有一个保安站点。苦恼的小安尝试着布置了很多遍，但每一次都不符合要求。小安只好求助编程部的小朗朗，没过多久，小朗朗就把好几个布置方案（实际上，这个问题有 92 种答案）发给了小安，其中包括图 6.22与图 6.23所示的这两个示例。摆脱了难题的小安想知道小朗朗是怎么做到的。
图 6.22 布置图样一
图 6.23 布置图样二
小安的问题其实就是八皇后问题。在国际象棋中，皇后能够上下左右斜无束缚地进行攻击。八皇后问题的原题是如何在一个 8×8的棋盘中放置 8 个皇后，并令她们互相攻击不到对方。八皇后问题是回溯算法的代表性问题之一。希望通过这个问题，可以让你更好地领会回溯算法的思想。
6.5.1 问题求解
首先，我们分析一下这个问题。问题中说到每一行、每一列和每一条斜线上都必须有且只能有一个保安站。它告诉了我们第一行的 8 个格子中肯定有一名保安，可以从这里入手。
那么，利用“每一行都必须有一个保安”的前提条件，假设第 1 行有一个保安 A。我们首先假设保安 A 在（1,1）格，如图 6.24所示，然后再判断这个假设是否成立。
然而我们并没有办法直接判断保安 A 是否能够留在（1,1）格，因为其他几个保安还没有被安置，如图 6.25所示。
图 6.24 假设保安 A 在（1,1）格因为其他几个保安还没有被安置，如图 6.25所示。

图 6.25 未被安置的 7 名保安
所以只能继续假设下去。假设第 2 行有一个保安 B，他在第 2 行的（2,3）格；假设第 3 行有一个保安 C，他在第 3 行的（3,5）格……就这样一直假设下去，如图 6.26所示。
这个假设的过程有两种可能的结果。
第一种结果：我们成功地假设到了第 8 行，也就是说，找到了正确答案之一。
第二种结果：在还没到第 8 行的时候就走不下去了，也就是说，陷入了死局，如图 6.27所示。
图 6.26 继续假设剩余保安的位置
图 6.27 陷入死局的情况示例
如果是第一种可能，那就太好了，我们直接把结果输出。但如果是第二种可能，我们则需要退一步，重新假设前一行保安的位置。在必要的情况下，我们会一直退回到第一行，重新假设保安 A 的位置。
总结一下思路，如图 6.28所示。以第一行为起点，假设保安位置，目标是一直成功地假设出有效的第 8 行保安的位置。如果中途陷入死局，则改变上一行保安的位置。
图 6.28 解题思路图
现在尝试不用回溯的方法把思路写出来。
用笨代码也能得到正确的 92 种答案，但为什么希望用回溯算法写呢？首先，笨代码违背代码应有的简单性。再有，笨代码只适用于一个 8×8的区域，如果小安下次需要安排一个 10×10的区域就不合适了。我们希望代码能够用于不同大小的区域。
其实可以发现上面的代码很多地方都是重复的。如图 6.29所示，代码一环套一环，每一环的结构都是一样的。每一次做完一行保安位置的假设后，都在继续做剩余行保安位置的假设。
那么是不是可以构造一个方法，其功能就是概括这些重复的部分呢？那样，只要传进不同的参数就可以重复使用这个方法了。


6.5.2 最终代码
上面说到了创建一个回溯方法来概括“假设当前行的保安位置→检查是否成立→假设剩余行的保安位置”这一过程，我们称这个方法为 helper 方法。来看一下 helper 方法的完整代码，后面我们会详细解释。
首先，来看一下 helper 方法的参数：columnPositions、rowIndex和 n。
columnPositions，用于存储保安位置的数组。columnPositions的坐标代表第几行，存储值代表第几列。
rowIndex，记录当前行数。从 rowIndex=0 开始到 rowIndex=8 时结束。
n，区域的大小。这里的 n 为 8。
现在，来看一下 helper 方法履行的任务：
1.假设当前行保安可在的不同位置：
假设当前保安在（rowIndex,column）位置，更新 columnPositions。注意：写代码时，保安的坐标值需要减 1，因为 python 的列表索引从 0 开始。如果当前行是第 1 行，rowIndex则为 0。
2.判断假设的保安位置是否合理。
04 if self.isValid（columnPositions,rowIndex）: #检查假设是否成立
需要创建一个 isValid 方法来判断当前的假设是否合理。比如，第 1 行的保安 A 在（1,1），假设第 2 行保安 B 的位置在（2,1），两名保安被放置在同一列，isValid方法会返回 False，所以也就不会浪费时间去假设第 3 行的保安 C 的位置了，而是重新假设保安 B 的位置。注意：如果 n 个坐标都不符合规则，程序会自动跳回到上一次调用 helper 方法的地方。它会继续没走完的 for 循环，重新假设上一行的保安位置。
3.如果合理，继续假设下面几行的保安位置。
05　　self.helper（columnPositions,rowIndex+1,n）#继续假设
需要重新调用 helper 方法，传入下一行的参数。比如，假设完第一行保安 A 在（1,1）格，并且假设成立，则继续调用 helper 方法，传入更新后的 columnPositions 与 rowIndex+1，假设第 2 行到第 8 行的保安位置。
4.判断 8 名保安是否都已被安置成功。
01 def helper（self,columnPositions,rowIndex,n）:
02　if rowIndex==n:　　　　　　　　　　　　　　　#如果 8 名保安都被安置
03　　self.printSolution（columnPositions,n）　　　 #输出结果
04　 return　　　　　　　　　　　　　　　　　　　　 #返回上一行的假设
如果 8 名保安都成功地被安置在了这个 8×8的区域，则输出结果。如果目的是输出一个结果，便可在此终止程序。如果需要输出所有的结果，则在输出完这个结果后返回到第 7 行，重新假设第 7 名保安的位置。
设计完 helper 方法，只需要调用它一次就可以解决小安的问题了。
01　 def solveNQueens（self,n）:
02　　　 self.helper（[-1]*n,0,n）注意：因为我们还没有开始布置保安位置，所以一开始传入的 columnPositions 是一个长度为 n，且所有值都为-1的数组。
以下代码是用笨方法写出来的死代码，适用于 4×4的棋盘。其实仔细看一看，笨的代码就是把 helper 方法展开了，输出的结果和使用 helper 方法输出的结果完全一致。


代码 6.5所示的就是小多多为了解决小安的问题写出的完整代码。小多多考虑得很周到，她想小安可能在其他城市安排保安站时还会面临相似的问题，所以她的代码适用于任何 n×n的区域。
代码 6.5 用回溯算法解决八皇后问题
图 6.30至图 6.32所示的是得出的 92 个结果的前 3 个。
图 6.30 输出结果 1
图 6.31 输出结果 2
图 6.32 输出结果
