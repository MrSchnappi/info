---
title: 06 教你解数独
toc: true
date: 2019-07-01
---
6.6 教你解数独
小朗朗最近对数独着了迷。在玩游戏的时候，计算机程序能够立刻得出答案，好奇的他想知道计算机是怎么得出结果的。数独的游戏规则是根据盘面上的已知数字推理出空格里的数字，要求每一行、每一列、每一个粗线格中均含数字 1～9，且不重复，如图 6.33所示。
图 6.33 数独游戏
6.6.1 问题求解
面对这样的问题，没有像公式一样的直接解决方式，所以只能靠尝试。如图 6.34所示，就像在走迷宫，没有地图，所以面对每一个岔路口都只能以探索的形式深入，一旦发现路线不对就返回岔路口，选择另一个分支。
图 6.34 迷宫
把这个比喻用在数独上的话，每一个空格就是一个岔路口，而每一个岔路口都有 9 种选择。我们肯定末端有一个出口。那么，从第 1 个岔路口出发。如图 6.35至图 6.37所示，假设第 1 个空格中的数字：1不可以，2也不可以，3可以。

图 6.36 假设第一个空格的数字为 2
接下来假设第 2 个空格，1、2、3都不可以，4可以，如图 6.38所示。
图 6.37 假设第 1 个空格的数字为 3
图 6.38 假设第 2 个空格的数字
接下来假设第 3 个空格：1不可以，2可以。接着假设第 4 个空格：糟糕，1～9都不可以。看来是陷入了死局，如图 6.39所示。
怎么办？只能退回一步。如图 6.40所示，重新假设第 3 个空格中的数字：1～5都不可以，6可以。
图 6.39 第 4 个空格没有选择

就这样一直假设下去，如果盘面上的数字相互矛盾则改变上一格的数字，再次尝试。当我们到达最后一个空格并且成功填入数字时，即可输出答案。注意：输出答案的前提是题目有解。如果题目有两个或更多答案，程序可输出所有答案。
其实这个问题和八皇后问题本质上没有什么区别，这两个问题都是循环“假设—检查—假设”这一过程。图 6.41 总结了我们的解题思路。
图 6.41 数独解题思路图
和八皇后问题一样，我们来看一下如果不用回溯写出来的代码是什么样的：注意：每一次假设后都要把格子还原回 0，以便下一次假设时盘面上的数字不冲突。如果不归零，那么可能陷入死局后退回到第 1 个空格时，第 2 个空格里已经有了 9，这会影响我们的判断。
不用回溯的话，需要把 81 个格子的假设过程全部写出来。上面的代码只是写了前两个格子的代码，可想要写到第 81 格代码会有多长。虽然这样也能返回正确答案，但这样写太费事，并且很累赘。
6.6.2 最终代码
观察图 6.42，你会发现每一个格子都是在重复上一个格子的代码，就像俄罗斯套娃，娃娃们除了格子坐标不同之外其他完全一致。

利用回溯算法，可以把这些重复的代码概括一下，这样当传入不同的参数时就可以避免重复。下面我们定义一个 helper 方法来帮助概括重复的代码，以下是 helper 方法的完整代码，下面会详细解释。
首先，来看一下 helper 方法的两个参数：
index，当前空格的坐标。index=0 时在第 1 格，index=80 时在最后一格。
board，存储盘面数字的数组，由数字 0～9组成，0代表空格。数组的坐标依行排序，例如，第 1 行第 1 格的坐标为 0，第 3 行第 1 格的坐标为 18。
看一下 helper 方法履行的几个任务：
1.如果当前格为空格，假设数字。
if语句建立假设前提，记住我们用 0 代表空格。
2.验证假设是否成立。
04　　　 if self.isValid（board,index,i）:　　#如果假设成立
05　　　　　board[index]=i　　　　　　　　　#填入数字
需要建立一个 isValid 方法。当传入当前盘面、当前格坐标和当前格的假设数字时，如果假设数字与盘面上的其他数字不冲突，方法会返回 True。只要假设成立，我们就在盘面上填入数字。注意：如果数字 1～9都不符合规则，程序会自动跳回到上一次调用 helper 方法的地方。它会继续上一格没走完的 for 循环，重新假设上一格的数字。
3.如果成立，继续假设剩余盘面。
06　　　 self.helper（board,index+1）　 #继续假设
07　　　 board[index]=0
需要再次调用 helper 方法，传入不同的参数。比如，假设第 1 个空格中的数字为 2，并且数字成立，那么调用 helper（board,1）就代表继续从第 2 格假设到最后一格。第 2 格假设完后，调用 helper（board,2）就代表继续从第 3 格假设到最后一格。
我们调用 helper 方法后跳了回来，走到了第 7 行代码，就证明当前假设的数字 i 不成立，或者已经输出了结果，这时需要把格子改回空格，以便继续假设其他数字。
4.检查盘面是否已满。
在假设当前格中数字之前要先检查一下我们是否已经得出答案。如果 index=81就代表 81 个格子中都填上了


成立的数字。那么，只需要输出答案就可以了。注意：返回上一行的目的是输出可能的其他答案，因为数独有时答案不唯一。
现在解决数独问题只需要调用一次 helper 方法就可以了。
01　def solveSudoku（self,board）:
02　　 self.helper（board,0）　　　　 #index=0，从第 1 格开始
下面让我们来看一下完整的代码，如代码 6.6所示。
代码 6.6 用回溯算法解决数独问题
让我们解决数独问题：
图 6.43所示是输出结果。
