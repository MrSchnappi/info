---
title: 02 旷工挖矿问题
toc: true
date: 2019-07-01
---


8.2 矿工挖矿问题
矿工挖矿问题是为了解决在给定金矿和矿工数量的前提下，能够获得最多黄金的挖矿策略。
8.2.1 问题描述
某一地区发现了 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。假设参与挖矿工人的总数是 10 人，且每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？
金矿的黄金储量与所需挖掘工人的数量如表 8.5所示。
表 8.5 黄金储量与所需工人数量表
续表
如果要用动态规划算法解决该问题，需要定位用于解题的三要素：最优子结构、边界和状态转移函数。
首先寻找最优子结构。我们的解题目标是确定 10 个工人挖 5 座金矿时能够获得的最多的黄金数量，该结果可以从 10 个工人挖 4 座金矿的子问题中递归求解。
在解决 10 个工人挖 4 座金矿的过程中，存在两种选择，一种是放弃第 5 座金矿，将 10 个工人全部投放到前 4 座金矿的挖掘中，如图 8.3所示。
图 8.3 放弃第 5 座金矿的情况
另一种选择是对第 5 座金矿进行挖掘，因此需要从 10 人中分配 3 个人加入第 5 座金矿的挖掘工作中，如图 8.4所示。
图 8.4 挖掘第 5 座金矿的情况
因此，最终的最优解应该是这两种选择中获得黄金数量较多的那个，即为图 8.3所描述的场景与图 8.4所描述场景中的最大值。
为了方便描述，假设金矿的数量为 n，工人的数量为 w，当前获得的黄金数量为 G[n]，当前所用矿工的数量为 P[n]，则根据上述分析，要获得 10 个矿工挖掘第 5 座金矿的最优解 F（5,10），需要在 F（4,10）和 F（4,10-P[4]）+G[4]中获取较大的值，即
F（5,10）=max（F（4,10）,F（4,10-P[4]）+G[4]）


因此，针对该问题而言，以上便是 F（5,10）情况下的最优子结构。
之后，我们来考虑该问题的边界。对于一座金矿的情况，若当前的矿工数量不能满足该金矿的挖掘需要，则获得的黄金数量为 0，若能满足矿工数量要求，则获得的黄金数量为 G[0]。因此，该问题的边界条件可表述为：
当 n=1,w>=P[0]时，F（n,w）=G[0]；
当 n=1,w<P[0]时，F（n,w）=0。
综上，可以得到该问题的状态转移函数：
F（n,w）=0（n<=1,w<p[0]）
F（n,w）=G[0]（n==1,w>=P[0]）
F（n,w）=F（n-1,w）（n>1,w<P[n-1]）
F（n,w）=max（F（n-1,w）,F（n-1,w-P[n-1]）+G[n-1]）（n>1,w>=P[n-1]）
至此，定义了用动态规划算法解决该问题的三个要素，下面要做的是利用边界、最优子结构和状态转移函数对该问题进行求解。
在初始化阶段，利用表格分析求解思路。如表 8.6所示，表格的第一列代表挖掘金矿数，即 n 的取值情况；表格的第一行代表占用工人数，即 w 的取值情况；中间各空白区域是需要通过计算填入的对应的黄金数量，即 F（n,w）的取值。
表 8.6 初始黄金数量表
在挖掘第一座金矿时，由于其所需的工人数量为 5，所以当 w 的取值小于 5 时，根据公式 F（n,w）=0（n<=1,w<p[0]），获得的黄金数量均为 0。当 w 的取值大于或等于 5 时，根据公式 F（n,w）=G[0]（n==1,w>=p[0]），黄金数量的取值为 400，如表 8.7所示。此时确定了该问题的边界。
表 8.7 挖掘第 1 座金矿时的黄金数量表
在挖掘第 2 座金矿时，由于其需要 5 个人进行挖掘，因此当 w 取值小于 5 时，根据公式 F（n,w）=F（n-1,w）（n>1,w<P[n-1]）,F（2,w）=F（1,w）=0；当 w 取值大于或等于 5 时，根据公式 F（n,w）=max（F（n-1,w）,F（n-1,w-P[n-1]）+G[n-1]）（n>1,w>=P[n-1]），在 5～9人的区间里，获得的黄金数量为 500，即所有人都去参加第 2 座金矿的挖掘时获得的黄金量，在参与人数为 10 时，可以两座金矿同时挖掘，因此获得的黄金数量为 900，如表 8.8所示。
表 8.8 挖掘第 2 座金矿时的黄金数量表
同理，在挖掘第 3 座金矿时，黄金产出量为 200，需要的工人数量为 3，根据上述计算方式可得黄金产出量，如表 8.9所示。
表 8.9 挖掘第 3 座金矿时的黄金数量表

第 4 座金矿的黄金产出量为 300，需要的工人数量为 4，根据上述计算方式，可得黄金产出量，如表 8.10所示。
表 8.10 挖掘第 4 座金矿时的黄金数量表
针对第 5 座金矿的黄金产出量计算与上述过程一致，具体产出量如表 8.11所示。
表 8.11 挖掘第 5 座金矿时的黄金数量表
通过以上的计算过程，我们不难发现，除了第 1 座金矿的相关数据，表格中的其他数据都可以由前一行的一个或两个格子中的数推导而来。例如，3座金矿 8 个人挖掘的黄金量 F（3,8）就来自 2 座金矿 8 个人挖掘的黄金量 F（2,8）和 2 座金矿 5 个人挖掘的黄金量 F（2,5），即 F（3,8）=max（F（2,8）,F（2,5）+200）=max（500,500+200）=700。
再比如，4座金矿 10 个人挖掘的黄金量 F（4,10），来自 3 座金矿 10 个人挖掘的黄金量 F（3,10）和 3 座金矿 6 个人挖掘的黄金量 F（3,6），即 F（4,10）=max（F（3,10）,F（3,6）+300）=max（900,500+300）=900，如表 8.12所示。
表 8.12 2-5座金矿黄金产量计算依赖于之前的计算量
续表
根据以上思路，在用程序实现该算法的过程中，采用自底向上的方式进行计算，像填表过程一样从左至右、从上到下逐渐获得计算结果。这样，可以不需要存储整个表格的内容，仅需要存储前一行的结果，就可以推导出


下一行的内容。
我们现在来把这个过程转换为程序。
我们定义函数 goldMining（n,w,g,p）来计算挖掘第 n 座金矿、有 w 个工人参与时能获得的黄金量，其中 g 和 p 分别为数组，分别存放对应各座金矿的黄金量及所需工人数。在正式迭代之前，首先界定边界的情况。当工人数量小于 p[0]时，说明目前工人数量不能开始任何金矿的挖掘，获得的黄金数量为 0；当工人数量大于或等于 p[0]时，获得的黄金数量即为 g[0]。
之后即进入循环的迭代过程。在迭代中，根据之前的分析，我们仅需要关注前一行 preResults 的取值，即可通过状态转移函数 F（n,w）=F（n-1,w）（n>1,w<P[n-1]）或 F（n,w）=max（F（n-1,w）,F（n-1,w-P[n-1]）+G[n-1]）（n>1,w>=P[n-1]）获得 F（n,w）的值，因此，整个迭代过程仅需要引入 preResults 数组保存前一行的值即可。
由此可见，该解决方案的时间复杂度为 O（n*w），而空间复杂度只有 O（w）。
8.2.2 最终代码
挖金矿问题的动态规划求解代码如代码 8.2所示。
代码 8.2 挖金矿问题的动态规划求解
首先定义边界值，确定数组 preResults 中各个元素的取值，同时初始化数组 results。之后，通过函

数 goldMining（n,w,g,p）迭代计算各座金矿数量与工人数量组合的黄金量，最终获得问题的解。
