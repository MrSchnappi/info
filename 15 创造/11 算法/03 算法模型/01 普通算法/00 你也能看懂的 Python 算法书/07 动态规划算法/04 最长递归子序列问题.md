---
title: 04 最长递归子序列问题
toc: true
date: 2019-07-01
---
8.4 最长递归子序列问题
最长递归子序列问题也是经典的动态规划问题之一。
8.4.1 问题描述
最长递增子序列（Longest Increasing Subsequence,LIS）问题即给定一个序列，求解其中最长的递增的子序列的长度。
要求长度为 i 的序列 Ai{a1,a2,…,ai}的最长递增子序列，需要先求出序列 Ai-1{a1,a2,…,ai-1}中以各元素（a1,a2,…,ai-1）作为最大元素的最长递增序列，然后把所有这些递增序列与 ai进行比较。如果某个长度为 m 的序列的末尾元素 a（j j<i）比 ai 要小，则将元素 ai 加入这个递增子序列，得到一个新的长度为 m+1的新序列，否则其长度不变，将处理后的所有 i 个序列的长度进行比较，其中最长的序列就是要求的最长递增子序列。
举例说明，对于序列 A{3,1,4,5,9,2,6,5,0}，当处理到第 7 个元素“6”时，以 3,1,4,5,9,2为最末元素的最长递增序列分别为
3
1
3,4
3,4,5
3,4,5,9
1,2
因此，“6”可以加入到以“5”作为结尾的序列中，形成以“6”为结尾的最长递增序列{3,4,5,6}。
当新加入第 8 个元素“5”时，这些序列变为
3,5
1,5
3,4,5
3,4,5
3,4,5,9
1,2,5
可见此时的以第 8 个元素“5”为结尾的最长递增序列仍为{3,4,5}。由于最后一个元素取值为 0，其加入对原序列的最长递增子序列无影响，因此，可得该序列的最长递增子序列为
3,4,5,9
所以序列 A 的最长递增子序列的长度为 4。注意：在解决最长递增子序列问题中，求解到的最长递增子序列可能不止一个。
令 f（i）表示序列中以 ai为末元素的最长递增子序列的长度，则在求以 ai为末元素的最长递增子序列时，找到所有序号在 i 前面且小于 ai 的元素 aj，即 j<i且 aj<ai。
如果这样的元素存在，那么对所有的 aj，都有一个以 aj 为末元素的最长递增子序列的长度 f（j）。把其中最大的 f（j）选出来，f（i）就等于最大的 f（j）加上 1，即以 ai 为末元素的最长递增子序列，等于在使 f（j）最大的那个 aj 为末元素的递增子序列最后再加上 ai；如果这样的元素不存在，那么 ai 自身构成一个长度为 1 的以 ai 为末元素的递增子序列。
上述问题的代码如代码 8.4所示。
代码 8.4 最长递增子序列的动态规划求解


该算法的时间复杂度为 O（n2），下面介绍可以将时间复杂度降为 O（nlogn）的改进算法。
8.4.2 改进算法
在基本算法中我们发现，当需要计算前 i 个元素的最长递增子序列时，前 i-1个元素作为最大元素的各递增序列，无论是长度，还是最大元素值，都毫无规律可循，所以开始计算前 i个元素的时候只能遍历前 i-1个元素，以找到满足条件的 j 值，使得 aj< ai，且在所有满足条件的 j 中，以 aj 作为最大元素的递增子序列最长。
在本节中，我们实现一个更高效的算法。
在一个序列中，长度为 n 的递增子序列可能不止一个，但是在所有长度为 n 的子序列中，有一个子序列是比较特殊的，那就是最大元素最小的递增子序列。如在 8.4.1节的示例中，当处理到第 7 个元素“6”时，在当前已生成的子序列中，长度为 2 的子序列有两个，即序列{3,4}和序列{1,2}，则此时对长度为 2 的序列而言，{1,2}就是最大元素最小的递增子序列。随着元素的不断加入，满足条件的子序列会不断变化。
如果将这些子序列按照长度由短到长排列，将它们的最大元素放在一起，形成新序列 B{b1,b2,…,bj}，则序列 B 满足 b1< b2< … < bj。
这个关系比较容易说明，假设 bxy 表示序列 A 中长度为 x 的递增序列中的第 y 个元素，显然，如果在序列 B 中存在元素 bmm> bnn，且 m < n，则说明子序列 Bn 的最大元素小于序列 Bm 的最大元素，因为序列是严格递增的，所以在递增序列 Bn 中存在元素 bnm< bnn，且从 bn0 到 bnm 形成了一个新的长度为 m 的递增序列。
因为 bmm> bnn，所以 bmm> bnm，这就说明在序列 B 中还存在一个长度为 m，最大元素为 bnm< bmm的递增子序列，这与序列的定义，bmm是所有长度为 m 的递增序列中第 m 个元素最小的序列不符，所以序列 B 中的各元素严格递增。
发现了如此一个严格递增的序列，这让我们眼前一亮，可以利用此序列的严格递增性，使用二分查找，找到最大元素刚好小于 aj 的元素 bk，将 aj 加入这个序列尾部，形成长度为 k+1但是最大元素又小于 bk+1的新序列，取代之前的 bk+1。如果 aj 比 Bn 中的所有元素都要大，说明发现了以 aj 为最大元素，长度为 n+1的递增序列，将 aj 作为 Bn+1的第 n+1个元素。从 b1 依次递推，就可以在 O（nlogn）的时间内找出序列 A 的最长递增子序列。
理论说明比较枯燥，来看一个例子，以序列{6,7,8,9,10,1,2,3,4,5,6}来说明改进算法的步骤。
程序开始时，最长递增序列长度为 1（每个元素都是一个长度为 1 的递增序列），当处理第 2 个元素时发现 7 比最长递增序列 6 的最大元素还要大，所以将 6 和 7 结合生成长度为 2 的递增序列，说明已经发现了长度为 2 的递增序列，依次处理，到第 5 个元素“10”，这一过程中 B 数组的变化过程是
6
6,7
6,7,8
6,7,8,9
6,7,8,9,10
第 6 个元素是“1”，查找比“1”大的最小元素，发现是长度为 1 的子序列的最大元素 6，说明 1 是最大元素更小的长度为 1 的递增序列，用 1 替换 6，形成新序列（1,7,8,9,10）。然后查找比第 7 个元素“2”大的最小元素，发现是“7”，说明存在长度为 2 的序列，其末元素 2 比 7 更小，用 2 替换 7，依次执行，直到所有元素处理完毕，生成新的序列（1,2,3,4,5），最后将“6”加入 B 数组，形成长度为 6 的最长递增子序列。
这一过程中，B数组的变化过程是
1,7,8,9,10
1,2,8,9,10
1,2,3,9,10
1,2,3,4,10
1,2,3,4,5
1,2,3,4,5,6
当处理第 10 个元素“5”时，传统算法需要查看 9 个元素（6,7,8,9,10,1,2,3,4），而改进算法只需用二分查找法查找数组 B 中的两个元素（3,4），可见效率可以大幅提升。
8.4.3 最终代码
最长递增子序列的动态规划求解改进算法的代码如代码 8.5所示。
代码 8.5 最长递增子序列的动态规划求解改进算法


二分查找的结果，目的是找到这样一个 j，使满足 A[B[j]]> A[i]的所有 j 中，j取得最小值。但是在二分查找的时候可能会发生两种特殊情况，B数组中的所有元素都不小于 A[i],B数组中的所有元素都比 A[i]小，对于这两种情况需要专门处理。
对于 B 中所有元素都不小于 A[i]的情况，要将 A[i]更新到 B[0]的位置。
对于 B 中所有元素都小于 A[i]的情况，要将 A[i]更新到 B[max]的位置，同时将 max 值增加，说明找到了比当前最长的递增序列更长的结果。
对于其他情况，在更新新节点的前驱节点时，要注意当前元素的前驱节点是 B[j-1]，而不是 pre[B[j]]，这一点要格外留意，后者看似有道理，但实际上在之前的更新中可能已经被变更过。
