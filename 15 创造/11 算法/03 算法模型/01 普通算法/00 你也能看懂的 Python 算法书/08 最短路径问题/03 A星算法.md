---
title: 03 A星算法
toc: true
date: 2019-07-01
---


9.3 A*算法
A*算法，也称 A 星算法，由迪可斯特朗算法演变而来，用于寻求有权图中的最短路径。A*算法与迪可斯特朗算法的区别在于，A*算法通过评估函数来预估完整路线的距离，而迪可斯特朗算法只关心当前距离，而并非完整路线的距离。因为利用评估函数，可减少遍历的节点数量，从而可更快地到达终点。输入边的权重和一个起点，A*算法能够比迪可斯特朗算法更快地得出从该起点到任何其他节点的最短路径。评估函数输出的距离估算值与实际值的接近程度决定算法的最终搜索速度。
9.3.1 算法核心：迪可斯特朗算法
在学习 A*算法之前，请先理解迪可斯特朗算法。这两个算法的结构和逻辑几乎一模一样，只不过 A*算法多了一个预估函数。其实，迪可斯特朗算法可视为 A*算法的一个特例，其预估函数为 0。
简单概括一下迪可斯特朗算法。定义两个节点集合：临时节点集合和永久节点集合。临时节点集合用于存储距离值和改变空间的节点；永久节点集合用于存储距离值已经固定的节点。在算法起始，临时集合只存放起点 A，永久集合则为空。接下来循环两个步骤直到临时节点集合为空：首先，找到临时节点集合中距离值最小的节点，把它迁移到永久集合里；其次，检查该节点的相邻节点集合。如果相邻节点不属于永久集合，则尝试更新其距离值，一旦更新成功便把该相邻节点加入临时节点集合。最后，从终点节点回溯到起点就可以得到最短路线。
再来看一下迪可斯特朗算法的核心代码。
9.3.2 算法核心：预估函数
A*算法利用一个预估函数来估算完整路线的距离，这个预估函数也是 A*算法与迪可斯特朗算法的不同之处。让我们用变量 d 来表示当前距离（从起点到当前节点的距离），变量 h 表示预估剩余距离（当前节点到终点的距离），变量 f 表示预估完整路线距离，也就是 d+h。在迪可斯特朗算法中，所谓的距离值指的是变量 d，而在 A*算法中，指的是变量 f。
变量 d 是当前路线经过的边的权重总和，变量 h 是用预估函数得出的一个数值。预估函数随着算法用途改变，但一个必要条件是输出数值必须小于实际数值。预估函数的精确性决定 A*算法的表现，优先最贴近实际数值的预估函数。
代码几乎没有变化，只需将所有当前完整距离改为预估完整路线距离。

9.3.3 算法核心：选择预估函数
以上没有定义预估函数 heuristic（），这是因为它的定义会根据算法的用途而改变。例如，寻找城市之间的最短路线，可以定义预估函数为两个城市之间的直线距离。在允许 4 个或 6 个方向操作的几何路网中，常定义预估函数为曼哈顿距离。在允许 8 个方向操作的几何路网中，常定义预估函数为对角线距离。不过，不论怎样定义预估函数，必须确保估算值比实际值小。如果估算值比实际值大，有可能漏掉正确路线。之前说过，预估函数越精确越好，也就是说，用来计算估算值时的约束条件越多越好。但是，约束条件越多程序就会花越多的时间进行计算，这个问题在游戏开发中需要注意，预估函数应该在精确度和计算量中寻找平衡。
9.3.4 A*算法的兄弟们
严格来说，我们一直说的 A*算法应该被称为 A 算法。如果预估函数的估算值偶尔比实际值大，算法称为 A*算法；如果估算值永远比实际值小，算法称为 A 算法；如果估算值永远等于实际值，还是称之为 A 算法。最后，如果预估函数的估算值永远为 0，称这个算法为迪可斯特朗算法。第三种可能不常见，因为很少能够做出完美的估算。为了方便，编程界将 A*算法与 A 算法统称为 A*算法。
如果预估函数的估算值偶尔比实际值大，有可能漏掉准确路线，不过没有关系，有的时候我们更关心时间复杂度。比起花较长的时间得到“完美的”路线，我们宁可花较少的时间得到一条“还可以”的路线。
