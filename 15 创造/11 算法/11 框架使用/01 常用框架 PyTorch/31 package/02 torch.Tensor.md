---
title: 02 torch.Tensor
toc: true
date: 2019-06-29
---
# TORCH.TENSOR

A [`torch.Tensor`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor) is a multi-dimensional matrix containing elements of a single data type.

Torch defines eight CPU tensor types and eight GPU tensor types:

| Data type                | dtype                             | CPU tensor                                                   | GPU tensor                |
| ------------------------ | --------------------------------- | ------------------------------------------------------------ | ------------------------- |
| 32-bit floating point    | `torch.float32` or `torch.float`  | `torch.FloatTensor`                                          | `torch.cuda.FloatTensor`  |
| 64-bit floating point    | `torch.float64` or `torch.double` | `torch.DoubleTensor`                                         | `torch.cuda.DoubleTensor` |
| 16-bit floating point    | `torch.float16` or `torch.half`   | `torch.HalfTensor`                                           | `torch.cuda.HalfTensor`   |
| 8-bit integer (unsigned) | `torch.uint8`                     | [`torch.ByteTensor`](https://pytorch.org/docs/stable/tensors.html#torch.ByteTensor) | `torch.cuda.ByteTensor`   |
| 8-bit integer (signed)   | `torch.int8`                      | `torch.CharTensor`                                           | `torch.cuda.CharTensor`   |
| 16-bit integer (signed)  | `torch.int16` or `torch.short`    | `torch.ShortTensor`                                          | `torch.cuda.ShortTensor`  |
| 32-bit integer (signed)  | `torch.int32` or `torch.int`      | `torch.IntTensor`                                            | `torch.cuda.IntTensor`    |
| 64-bit integer (signed)  | `torch.int64` or `torch.long`     | `torch.LongTensor`                                           | `torch.cuda.LongTensor`   |

[`torch.Tensor`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor) is an alias for the default tensor type (`torch.FloatTensor`).

A tensor can be constructed from a python [`list`](https://docs.python.org/3/library/stdtypes.html#list) or sequence using the [`torch.tensor()`](https://pytorch.org/docs/stable/torch.html#torch.tensor) constructor:

```
>>> torch.tensor([[1., -1.], [1., -1.]])
tensor([[ 1.0000, -1.0000],
        [ 1.0000, -1.0000]])
>>> torch.tensor(np.array([[1, 2, 3], [4, 5, 6]]))
tensor([[ 1,  2,  3],
        [ 4,  5,  6]])
```

WARNING

[`torch.tensor()`](https://pytorch.org/docs/stable/torch.html#torch.tensor) always copies `data`. If you have a Tensor `data` and just want to change its `requires_grad` flag, use [`requires_grad_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.requires_grad_) or [`detach()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.detach) to avoid a copy. If you have a numpy array and want to avoid a copy, use [`torch.as_tensor()`](https://pytorch.org/docs/stable/torch.html#torch.as_tensor).

A tensor of specific data type can be constructed by passing a [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and/or a [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) to a constructor or tensor creation op:

```
>>> torch.zeros([2, 4], dtype=torch.int32)
tensor([[ 0,  0,  0,  0],
        [ 0,  0,  0,  0]], dtype=torch.int32)
>>> cuda0 = torch.device('cuda:0')
>>> torch.ones([2, 4], dtype=torch.float64, device=cuda0)
tensor([[ 1.0000,  1.0000,  1.0000,  1.0000],
        [ 1.0000,  1.0000,  1.0000,  1.0000]], dtype=torch.float64, device='cuda:0')
```

The contents of a tensor can be accessed and modified using python’s indexing and slicing notation:

```
>>> x = torch.tensor([[1, 2, 3], [4, 5, 6]])
>>> print(x[1][2])
tensor(6)
>>> x[0][1] = 8
>>> print(x)
tensor([[ 1,  8,  3],
        [ 4,  5,  6]])
```

Use [`torch.Tensor.item()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.item) to get a python number from a tensor containing a single value:

```
>>> x = torch.tensor([[1]])
>>> x
tensor([[ 1]])
>>> x.item()
1
>>> x = torch.tensor(2.5)
>>> x
tensor(2.5000)
>>> x.item()
2.5
```

A tensor can be created with `requires_grad=True` so that [`torch.autograd`](https://pytorch.org/docs/stable/autograd.html#module-torch.autograd) records operations on them for automatic differentiation.

```
>>> x = torch.tensor([[1., -1.], [1., 1.]], requires_grad=True)
>>> out = x.pow(2).sum()
>>> out.backward()
>>> x.grad
tensor([[ 2.0000, -2.0000],
        [ 2.0000,  2.0000]])
```

Each tensor has an associated `torch.Storage`, which holds its data. The tensor class provides multi-dimensional, [strided](https://en.wikipedia.org/wiki/Stride_of_an_array) view of a storage and defines numeric operations on it.

NOTE

For more information on the [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype), [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device), and [`torch.layout`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.layout) attributes of a [`torch.Tensor`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor), see [Tensor Attributes](https://pytorch.org/docs/stable/tensor_attributes.html#tensor-attributes-doc).

NOTE

Methods which mutate a tensor are marked with an underscore suffix. For example, `torch.FloatTensor.abs_()` computes the absolute value in-place and returns the modified tensor, while `torch.FloatTensor.abs()` computes the result in a new tensor.

NOTE

To change an existing tensor’s [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) and/or [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype), consider using [`to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to) method on the tensor.

- *CLASS*`torch.``Tensor`

  There are a few main ways to create a tensor, depending on your use case.To create a tensor with pre-existing data, use [`torch.tensor()`](https://pytorch.org/docs/stable/torch.html#torch.tensor).To create a tensor with specific size, use `torch.*` tensor creation ops (see [Creation Ops](https://pytorch.org/docs/stable/torch.html#tensor-creation-ops)).To create a tensor with the same size (and similar types) as another tensor, use `torch.*_like`tensor creation ops (see [Creation Ops](https://pytorch.org/docs/stable/torch.html#tensor-creation-ops)).To create a tensor with similar type but different size as another tensor, use `tensor.new_*`creation ops.`new_tensor`(*data*, *dtype=None*, *device=None*, *requires_grad=False*) → TensorReturns a new Tensor with `data` as the tensor data. By default, the returned Tensor has the same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.WARNING[`new_tensor()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.new_tensor) always copies `data`. If you have a Tensor `data` and want to avoid a copy, use [`torch.Tensor.requires_grad_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.requires_grad_) or [`torch.Tensor.detach()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.detach). If you have a numpy array and want to avoid a copy, use [`torch.from_numpy()`](https://pytorch.org/docs/stable/torch.html#torch.from_numpy).WARNINGWhen data is a tensor x, [`new_tensor()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.new_tensor) reads out ‘the data’ from whatever it is passed, and constructs a leaf variable. Therefore `tensor.new_tensor(x)` is equivalent to `x.clone().detach()` and `tensor.new_tensor(x,requires_grad=True)` is equivalent to `x.clone().detach().requires_grad_(True)`. The equivalents using `clone()` and `detach()` are recommended.Parameters**data** (*array_like*) – The returned Tensor copies `data`.**dtype** ([`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype), optional) – the desired type of returned tensor. Default: if None, same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) as this tensor.**device** ([`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device), optional) – the desired device of returned tensor. Default: if None, same [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.**requires_grad** ([*bool*](https://docs.python.org/3/library/functions.html#bool)*,* *optional*) – If autograd should record operations on the returned tensor. Default: `False`.Example:`>>> tensor = torch.ones((2,), dtype=torch.int8) >>> data = [[0, 1], [2, 3]] >>> tensor.new_tensor(data) tensor([[ 0,  1],         [ 2,  3]], dtype=torch.int8) ``new_full`(*size*, *fill_value*, *dtype=None*, *device=None*, *requires_grad=False*) → TensorReturns a Tensor of size [`size`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.size) filled with `fill_value`. By default, the returned Tensor has the same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.Parameters**fill_value** (*scalar*) – the number to fill the output tensor with.**dtype** ([`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype), optional) – the desired type of returned tensor. Default: if None, same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) as this tensor.**device** ([`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device), optional) – the desired device of returned tensor. Default: if None, same [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.**requires_grad** ([*bool*](https://docs.python.org/3/library/functions.html#bool)*,* *optional*) – If autograd should record operations on the returned tensor. Default: `False`.Example:`>>> tensor = torch.ones((2,), dtype=torch.float64) >>> tensor.new_full((3, 4), 3.141592) tensor([[ 3.1416,  3.1416,  3.1416,  3.1416],         [ 3.1416,  3.1416,  3.1416,  3.1416],         [ 3.1416,  3.1416,  3.1416,  3.1416]], dtype=torch.float64) ``new_empty`(*size*, *dtype=None*, *device=None*, *requires_grad=False*) → TensorReturns a Tensor of size [`size`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.size) filled with uninitialized data. By default, the returned Tensor has the same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.Parameters**dtype** ([`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype), optional) – the desired type of returned tensor. Default: if None, same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) as this tensor.**device** ([`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device), optional) – the desired device of returned tensor. Default: if None, same [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.**requires_grad** ([*bool*](https://docs.python.org/3/library/functions.html#bool)*,* *optional*) – If autograd should record operations on the returned tensor. Default: `False`.Example:`>>> tensor = torch.ones(()) >>> tensor.new_empty((2, 3)) tensor([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],         [ 3.0949e-41,  4.4842e-44,  0.0000e+00]]) ``new_ones`(*size*, *dtype=None*, *device=None*, *requires_grad=False*) → TensorReturns a Tensor of size [`size`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.size) filled with `1`. By default, the returned Tensor has the same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.Parameters**size** (*int...*) – a list, tuple, or `torch.Size` of integers defining the shape of the output tensor.**dtype** ([`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype), optional) – the desired type of returned tensor. Default: if None, same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) as this tensor.**device** ([`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device), optional) – the desired device of returned tensor. Default: if None, same [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.**requires_grad** ([*bool*](https://docs.python.org/3/library/functions.html#bool)*,* *optional*) – If autograd should record operations on the returned tensor. Default: `False`.Example:`>>> tensor = torch.tensor((), dtype=torch.int32) >>> tensor.new_ones((2, 3)) tensor([[ 1,  1,  1],         [ 1,  1,  1]], dtype=torch.int32) ``new_zeros`(*size*, *dtype=None*, *device=None*, *requires_grad=False*) → TensorReturns a Tensor of size [`size`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.size) filled with `0`. By default, the returned Tensor has the same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.Parameters**size** (*int...*) – a list, tuple, or `torch.Size` of integers defining the shape of the output tensor.**dtype** ([`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype), optional) – the desired type of returned tensor. Default: if None, same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) as this tensor.**device** ([`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device), optional) – the desired device of returned tensor. Default: if None, same [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as this tensor.**requires_grad** ([*bool*](https://docs.python.org/3/library/functions.html#bool)*,* *optional*) – If autograd should record operations on the returned tensor. Default: `False`.Example:`>>> tensor = torch.tensor((), dtype=torch.float64) >>> tensor.new_zeros((2, 3)) tensor([[ 0.,  0.,  0.],         [ 0.,  0.,  0.]], dtype=torch.float64) ``is_cuda`Is `True` if the Tensor is stored on the GPU, `False` otherwise.`device`Is the [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) where this Tensor is.`grad`This attribute is `None` by default and becomes a Tensor the first time a call to [`backward()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.backward)computes gradients for `self`. The attribute will then contain the gradients computed and future calls to [`backward()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.backward) will accumulate (add) gradients into it.`abs`() → TensorSee [`torch.abs()`](https://pytorch.org/docs/stable/torch.html#torch.abs)`abs_`() → TensorIn-place version of [`abs()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.abs)`acos`() → TensorSee [`torch.acos()`](https://pytorch.org/docs/stable/torch.html#torch.acos)`acos_`() → TensorIn-place version of [`acos()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.acos)`add`(*value*) → Tensoradd(value=1, other) -> TensorSee [`torch.add()`](https://pytorch.org/docs/stable/torch.html#torch.add)`add_`(*value*) → Tensoradd_(value=1, other) -> TensorIn-place version of [`add()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.add)`addbmm`(*beta=1*, *alpha=1*, *batch1*, *batch2*) → TensorSee [`torch.addbmm()`](https://pytorch.org/docs/stable/torch.html#torch.addbmm)`addbmm_`(*beta=1*, *alpha=1*, *batch1*, *batch2*) → TensorIn-place version of [`addbmm()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.addbmm)`addcdiv`(*value=1*, *tensor1*, *tensor2*) → TensorSee [`torch.addcdiv()`](https://pytorch.org/docs/stable/torch.html#torch.addcdiv)`addcdiv_`(*value=1*, *tensor1*, *tensor2*) → TensorIn-place version of [`addcdiv()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.addcdiv)`addcmul`(*value=1*, *tensor1*, *tensor2*) → TensorSee [`torch.addcmul()`](https://pytorch.org/docs/stable/torch.html#torch.addcmul)`addcmul_`(*value=1*, *tensor1*, *tensor2*) → TensorIn-place version of [`addcmul()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.addcmul)`addmm`(*beta=1*, *alpha=1*, *mat1*, *mat2*) → TensorSee [`torch.addmm()`](https://pytorch.org/docs/stable/torch.html#torch.addmm)`addmm_`(*beta=1*, *alpha=1*, *mat1*, *mat2*) → TensorIn-place version of [`addmm()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.addmm)`addmv`(*beta=1*, *alpha=1*, *mat*, *vec*) → TensorSee [`torch.addmv()`](https://pytorch.org/docs/stable/torch.html#torch.addmv)`addmv_`(*beta=1*, *alpha=1*, *mat*, *vec*) → TensorIn-place version of [`addmv()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.addmv)`addr`(*beta=1*, *alpha=1*, *vec1*, *vec2*) → TensorSee [`torch.addr()`](https://pytorch.org/docs/stable/torch.html#torch.addr)`addr_`(*beta=1*, *alpha=1*, *vec1*, *vec2*) → TensorIn-place version of [`addr()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.addr)`allclose`(*other*, *rtol=1e-05*, *atol=1e-08*, *equal_nan=False*) → TensorSee [`torch.allclose()`](https://pytorch.org/docs/stable/torch.html#torch.allclose)`apply_`(*callable*) → TensorApplies the function `callable` to each element in the tensor, replacing each element with the value returned by `callable`.NOTEThis function only works with CPU tensors and should not be used in code sections that require high performance.`argmax`(*dim=None*, *keepdim=False*) → LongTensorSee [`torch.argmax()`](https://pytorch.org/docs/stable/torch.html#torch.argmax)`argmin`(*dim=None*, *keepdim=False*) → LongTensorSee [`torch.argmin()`](https://pytorch.org/docs/stable/torch.html#torch.argmin)`argsort`(*dim=-1*, *descending=False*) → LongTensorSee :func: torch.argsort`asin`() → TensorSee [`torch.asin()`](https://pytorch.org/docs/stable/torch.html#torch.asin)`asin_`() → TensorIn-place version of [`asin()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.asin)`atan`() → TensorSee [`torch.atan()`](https://pytorch.org/docs/stable/torch.html#torch.atan)`atan2`(*other*) → TensorSee [`torch.atan2()`](https://pytorch.org/docs/stable/torch.html#torch.atan2)`atan2_`(*other*) → TensorIn-place version of [`atan2()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.atan2)`atan_`() → TensorIn-place version of [`atan()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.atan)`backward`(*gradient=None*, *retain_graph=None*, *create_graph=False*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.backward)Computes the gradient of current tensor w.r.t. graph leaves.The graph is differentiated using the chain rule. If the tensor is non-scalar (i.e. its data has more than one element) and requires gradient, the function additionally requires specifying `gradient`. It should be a tensor of matching type and location, that contains the gradient of the differentiated function w.r.t. `self`.This function accumulates gradients in the leaves - you might need to zero them before calling it.Parameters**gradient** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor) *or* [*None*](https://docs.python.org/3/library/constants.html#None)) – Gradient w.r.t. the tensor. If it is a tensor, it will be automatically converted to a Tensor that does not require grad unless `create_graph` is True. None values can be specified for scalar Tensors or ones that don’t require grad. If a None value would be acceptable then this argument is optional.**retain_graph** ([*bool*](https://docs.python.org/3/library/functions.html#bool)*,* *optional*) – If `False`, the graph used to compute the grads will be freed. Note that in nearly all cases setting this option to True is not needed and often can be worked around in a much more efficient way. Defaults to the value of `create_graph`.**create_graph** ([*bool*](https://docs.python.org/3/library/functions.html#bool)*,* *optional*) – If `True`, graph of the derivative will be constructed, allowing to compute higher order derivative products. Defaults to `False`.`baddbmm`(*beta=1*, *alpha=1*, *batch1*, *batch2*) → TensorSee [`torch.baddbmm()`](https://pytorch.org/docs/stable/torch.html#torch.baddbmm)`baddbmm_`(*beta=1*, *alpha=1*, *batch1*, *batch2*) → TensorIn-place version of [`baddbmm()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.baddbmm)`bernoulli`(***, *generator=None*) → TensorReturns a result tensor where each \texttt{result[i]}result[i] is independently sampled from \text{Bernoulli}(\texttt{self[i]})Bernoulli(self[i]). `self` must have floating point `dtype`, and the result will have the same `dtype`.See [`torch.bernoulli()`](https://pytorch.org/docs/stable/torch.html#torch.bernoulli)`bernoulli_`()`bernoulli_`(*p=0.5*, ***, *generator=None*) → TensorFills each location of `self` with an independent sample from \text{Bernoulli}(\texttt{p})Bernoulli(p). `self` can have integral `dtype`.`bernoulli_`(*p_tensor*, ***, *generator=None*) → Tensor`p_tensor` should be a tensor containing probabilities to be used for drawing the binary random number.The \text{i}^{th}ith element of `self` tensor will be set to a value sampled from \text{Bernoulli}(\texttt{p\_tensor[i]})Bernoulli(p_tensor[i]).`self` can have integral `dtype`, but `p_tensor` must have floating point `dtype`.See also [`bernoulli()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.bernoulli) and [`torch.bernoulli()`](https://pytorch.org/docs/stable/torch.html#torch.bernoulli)`bincount`(*weights=None*, *minlength=0*) → TensorSee [`torch.bincount()`](https://pytorch.org/docs/stable/torch.html#torch.bincount)`bmm`(*batch2*) → TensorSee [`torch.bmm()`](https://pytorch.org/docs/stable/torch.html#torch.bmm)`byte`() → Tensor`self.byte()` is equivalent to `self.to(torch.uint8)`. See [`to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to).`btrifact`(*pivot=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.btrifact)See [`torch.lu()`](https://pytorch.org/docs/stable/torch.html#torch.lu)`btrifact_with_info`(*pivot=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.btrifact_with_info)See [`torch.lu()`](https://pytorch.org/docs/stable/torch.html#torch.lu)`btrisolve`(*LU_data*, *LU_pivots*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.btrisolve)See [`torch.lu_solve()`](https://pytorch.org/docs/stable/torch.html#torch.lu_solve)`cauchy_`(*median=0*, *sigma=1*, ***, *generator=None*) → TensorFills the tensor with numbers drawn from the Cauchy distribution:f(x) = \dfrac{1}{\pi} \dfrac{\sigma}{(x - \text{median})^2 + \sigma^2}f(x)=π1(x−median)2+σ2σ`ceil`() → TensorSee [`torch.ceil()`](https://pytorch.org/docs/stable/torch.html#torch.ceil)`ceil_`() → TensorIn-place version of [`ceil()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.ceil)`char`() → Tensor`self.char()` is equivalent to `self.to(torch.int8)`. See [`to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to).`cholesky`(*upper=False*) → TensorSee [`torch.cholesky()`](https://pytorch.org/docs/stable/torch.html#torch.cholesky)`cholesky_inverse`(*upper=False*) → TensorSee [`torch.cholesky_inverse()`](https://pytorch.org/docs/stable/torch.html#torch.cholesky_inverse)`cholesky_solve`(*input2*, *upper=False*) → TensorSee [`torch.cholesky_solve()`](https://pytorch.org/docs/stable/torch.html#torch.cholesky_solve)`chunk`(*chunks*, *dim=0*) → List of TensorsSee [`torch.chunk()`](https://pytorch.org/docs/stable/torch.html#torch.chunk)`clamp`(*min*, *max*) → TensorSee [`torch.clamp()`](https://pytorch.org/docs/stable/torch.html#torch.clamp)`clamp_`(*min*, *max*) → TensorIn-place version of [`clamp()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.clamp)`clone`() → TensorReturns a copy of the `self` tensor. The copy has the same size and data type as `self`.NOTEUnlike copy_(), this function is recorded in the computation graph. Gradients propagating to the cloned tensor will propagate to the original tensor.`contiguous`() → TensorReturns a contiguous tensor containing the same data as `self` tensor. If `self` tensor is contiguous, this function returns the `self` tensor.`copy_`(*src*, *non_blocking=False*) → TensorCopies the elements from `src` into `self` tensor and returns `self`.The `src` tensor must be [broadcastable](https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics) with the `self` tensor. It may be of a different data type or reside on a different device.Parameters**src** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the source tensor to copy from**non_blocking** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – if `True` and this copy is between CPU and GPU, the copy may occur asynchronously with respect to the host. For other cases, this argument has no effect.`cos`() → TensorSee [`torch.cos()`](https://pytorch.org/docs/stable/torch.html#torch.cos)`cos_`() → TensorIn-place version of [`cos()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.cos)`cosh`() → TensorSee [`torch.cosh()`](https://pytorch.org/docs/stable/torch.html#torch.cosh)`cosh_`() → TensorIn-place version of [`cosh()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.cosh)`cpu`() → TensorReturns a copy of this object in CPU memory.If this object is already in CPU memory and on the correct device, then no copy is performed and the original object is returned.`cross`(*other*, *dim=-1*) → TensorSee [`torch.cross()`](https://pytorch.org/docs/stable/torch.html#torch.cross)`cuda`(*device=None*, *non_blocking=False*) → TensorReturns a copy of this object in CUDA memory.If this object is already in CUDA memory and on the correct device, then no copy is performed and the original object is returned.Parameters**device** ([`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device)) – The destination GPU device. Defaults to the current CUDA device.**non_blocking** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – If `True` and the source is in pinned memory, the copy will be asynchronous with respect to the host. Otherwise, the argument has no effect. Default: `False`.`cumprod`(*dim*, *dtype=None*) → TensorSee [`torch.cumprod()`](https://pytorch.org/docs/stable/torch.html#torch.cumprod)`cumsum`(*dim*, *dtype=None*) → TensorSee [`torch.cumsum()`](https://pytorch.org/docs/stable/torch.html#torch.cumsum)`data_ptr`() → intReturns the address of the first element of `self` tensor.`dequantize`() → TensorGiven a quantized Tensor, dequantize it and return the dequantized float Tensor.`det`() → TensorSee [`torch.det()`](https://pytorch.org/docs/stable/torch.html#torch.det)`dense_dim`() → intIf `self` is a sparse COO tensor (i.e., with `torch.sparse_coo` layout), this returns a the number of dense dimensions. Otherwise, this throws an error.See also [`Tensor.sparse_dim()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.sparse_dim).`detach`()Returns a new Tensor, detached from the current graph.The result will never require gradient.NOTEReturned Tensor shares the same storage with the original one. In-place modifications on either of them will be seen, and may trigger errors in correctness checks. IMPORTANT NOTE: Previously, in-place size / stride / storage changes (such as resize_ / resize_as_ / set_ / transpose_) to the returned tensor also update the original tensor. Now, these in-place changes will not update the original tensor anymore, and will instead trigger an error. For sparse tensors: In-place indices / values changes (such as zero_ / copy_ / add_) to the returned tensor will not update the original tensor anymore, and will instead trigger an error.`detach_`()Detaches the Tensor from the graph that created it, making it a leaf. Views cannot be detached in-place.`diag`(*diagonal=0*) → TensorSee [`torch.diag()`](https://pytorch.org/docs/stable/torch.html#torch.diag)`diag_embed`(*offset=0*, *dim1=-2*, *dim2=-1*) → TensorSee [`torch.diag_embed()`](https://pytorch.org/docs/stable/torch.html#torch.diag_embed)`diagflat`(*diagonal=0*) → TensorSee [`torch.diagflat()`](https://pytorch.org/docs/stable/torch.html#torch.diagflat)`diagonal`(*offset=0*, *dim1=0*, *dim2=1*) → TensorSee [`torch.diagonal()`](https://pytorch.org/docs/stable/torch.html#torch.diagonal)`digamma`() → TensorSee [`torch.digamma()`](https://pytorch.org/docs/stable/torch.html#torch.digamma)`digamma_`() → TensorIn-place version of [`digamma()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.digamma)`dim`() → intReturns the number of dimensions of `self` tensor.`dist`(*other*, *p=2*) → TensorSee [`torch.dist()`](https://pytorch.org/docs/stable/torch.html#torch.dist)`div`(*value*) → TensorSee [`torch.div()`](https://pytorch.org/docs/stable/torch.html#torch.div)`div_`(*value*) → TensorIn-place version of [`div()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.div)`dot`(*tensor2*) → TensorSee [`torch.dot()`](https://pytorch.org/docs/stable/torch.html#torch.dot)`double`() → Tensor`self.double()` is equivalent to `self.to(torch.float64)`. See [`to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to).`eig`(*eigenvectors=False) -> (Tensor*, *Tensor*)See [`torch.eig()`](https://pytorch.org/docs/stable/torch.html#torch.eig)`element_size`() → intReturns the size in bytes of an individual element.Example:`>>> torch.tensor([]).element_size() 4 >>> torch.tensor([], dtype=torch.uint8).element_size() 1 ``eq`(*other*) → TensorSee [`torch.eq()`](https://pytorch.org/docs/stable/torch.html#torch.eq)`eq_`(*other*) → TensorIn-place version of [`eq()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.eq)`equal`(*other*) → boolSee [`torch.equal()`](https://pytorch.org/docs/stable/torch.html#torch.equal)`erf`() → TensorSee [`torch.erf()`](https://pytorch.org/docs/stable/torch.html#torch.erf)`erf_`() → TensorIn-place version of [`erf()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.erf)`erfc`() → TensorSee [`torch.erfc()`](https://pytorch.org/docs/stable/torch.html#torch.erfc)`erfc_`() → TensorIn-place version of [`erfc()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.erfc)`erfinv`() → TensorSee [`torch.erfinv()`](https://pytorch.org/docs/stable/torch.html#torch.erfinv)`erfinv_`() → TensorIn-place version of [`erfinv()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.erfinv)`exp`() → TensorSee [`torch.exp()`](https://pytorch.org/docs/stable/torch.html#torch.exp)`exp_`() → TensorIn-place version of [`exp()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.exp)`expm1`() → TensorSee [`torch.expm1()`](https://pytorch.org/docs/stable/torch.html#torch.expm1)`expm1_`() → TensorIn-place version of [`expm1()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.expm1)`expand`(**sizes*) → TensorReturns a new view of the `self` tensor with singleton dimensions expanded to a larger size.Passing -1 as the size for a dimension means not changing the size of that dimension.Tensor can be also expanded to a larger number of dimensions, and the new ones will be appended at the front. For the new dimensions, the size cannot be set to -1.Expanding a tensor does not allocate new memory, but only creates a new view on the existing tensor where a dimension of size one is expanded to a larger size by setting the `stride` to 0. Any dimension of size 1 can be expanded to an arbitrary value without allocating new memory.Parameters***sizes** (*torch.Size* *or* *int...*) – the desired expanded sizeWARNINGMore than one element of an expanded tensor may refer to a single memory location. As a result, in-place operations (especially ones that are vectorized) may result in incorrect behavior. If you need to write to the tensors, please clone them first.Example:`>>> x = torch.tensor([[1], [2], [3]]) >>> x.size() torch.Size([3, 1]) >>> x.expand(3, 4) tensor([[ 1,  1,  1,  1],         [ 2,  2,  2,  2],         [ 3,  3,  3,  3]]) >>> x.expand(-1, 4)   # -1 means not changing the size of that dimension tensor([[ 1,  1,  1,  1],         [ 2,  2,  2,  2],         [ 3,  3,  3,  3]]) ``expand_as`(*other*) → TensorExpand this tensor to the same size as `other`. `self.expand_as(other)` is equivalent to `self.expand(other.size())`.Please see [`expand()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.expand) for more information about `expand`.Parameters**other** ([`torch.Tensor`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – The result tensor has the same size as `other`.`exponential_`(*lambd=1*, ***, *generator=None*) → TensorFills `self` tensor with elements drawn from the exponential distribution:f(x) = \lambda e^{-\lambda x}f(x)=λe−λx`fft`(*signal_ndim*, *normalized=False*) → TensorSee [`torch.fft()`](https://pytorch.org/docs/stable/torch.html#torch.fft)`fill_`(*value*) → TensorFills `self` tensor with the specified value.`flatten`(*input*, *start_dim=0*, *end_dim=-1*) → Tensorsee [`torch.flatten()`](https://pytorch.org/docs/stable/torch.html#torch.flatten)`flip`(*dims*) → TensorSee [`torch.flip()`](https://pytorch.org/docs/stable/torch.html#torch.flip)`float`() → Tensor`self.float()` is equivalent to `self.to(torch.float32)`. See [`to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to).`floor`() → TensorSee [`torch.floor()`](https://pytorch.org/docs/stable/torch.html#torch.floor)`floor_`() → TensorIn-place version of [`floor()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.floor)`fmod`(*divisor*) → TensorSee [`torch.fmod()`](https://pytorch.org/docs/stable/torch.html#torch.fmod)`fmod_`(*divisor*) → TensorIn-place version of [`fmod()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.fmod)`frac`() → TensorSee [`torch.frac()`](https://pytorch.org/docs/stable/torch.html#torch.frac)`frac_`() → TensorIn-place version of [`frac()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.frac)`gather`(*dim*, *index*) → TensorSee [`torch.gather()`](https://pytorch.org/docs/stable/torch.html#torch.gather)`ge`(*other*) → TensorSee [`torch.ge()`](https://pytorch.org/docs/stable/torch.html#torch.ge)`ge_`(*other*) → TensorIn-place version of [`ge()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.ge)`gels`(*A*) → TensorSee [`torch.gels()`](https://pytorch.org/docs/stable/torch.html#torch.gels)`geometric_`(*p*, ***, *generator=None*) → TensorFills `self` tensor with elements drawn from the geometric distribution:f(X=k) = (1 - p)^{k - 1} pf(X=k)=(1−p)k−1p`geqrf`(*) -> (Tensor*, *Tensor*)See [`torch.geqrf()`](https://pytorch.org/docs/stable/torch.html#torch.geqrf)`ger`(*vec2*) → TensorSee [`torch.ger()`](https://pytorch.org/docs/stable/torch.html#torch.ger)`gesv`(*A*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.gesv)See [`torch.solve()`](https://pytorch.org/docs/stable/torch.html#torch.solve)`get_device`(*) -> Device ordinal (Integer*)For CUDA tensors, this function returns the device ordinal of the GPU on which the tensor resides. For CPU tensors, an error is thrown.Example:`>>> x = torch.randn(3, 4, 5, device='cuda:0') >>> x.get_device() 0 >>> x.cpu().get_device()  # RuntimeError: get_device is not implemented for type torch.FloatTensor ``gt`(*other*) → TensorSee [`torch.gt()`](https://pytorch.org/docs/stable/torch.html#torch.gt)`gt_`(*other*) → TensorIn-place version of [`gt()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.gt)`half`() → Tensor`self.half()` is equivalent to `self.to(torch.float16)`. See [`to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to).`hardshrink`(*lambd=0.5*) → TensorSee [`torch.nn.functional.hardshrink()`](https://pytorch.org/docs/stable/nn.html#torch.nn.functional.hardshrink)`histc`(*bins=100*, *min=0*, *max=0*) → TensorSee [`torch.histc()`](https://pytorch.org/docs/stable/torch.html#torch.histc)`ifft`(*signal_ndim*, *normalized=False*) → TensorSee [`torch.ifft()`](https://pytorch.org/docs/stable/torch.html#torch.ifft)`index_add_`(*dim*, *index*, *tensor*) → TensorAccumulate the elements of [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) into the `self` tensor by adding to the indices in the order given in `index`. For example, if `dim == 0` and `index[i] == j`, then the `i`th row of [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) is added to the `j`th row of `self`.The [`dim`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.dim)th dimension of [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) must have the same size as the length of `index` (which must be a vector), and all other dimensions must match `self`, or an error will be raised.NOTEWhen using the CUDA backend, this operation may induce nondeterministic behaviour that is not easily switched off. Please see the notes on [Reproducibility](https://pytorch.org/docs/stable/notes/randomness.html) for background.Parameters**dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – dimension along which to index**index** (*LongTensor*) – indices of [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) to select from**tensor** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the tensor containing values to addExample:`>>> x = torch.ones(5, 3) >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float) >>> index = torch.tensor([0, 4, 2]) >>> x.index_add_(0, index, t) tensor([[  2.,   3.,   4.],         [  1.,   1.,   1.],         [  8.,   9.,  10.],         [  1.,   1.,   1.],         [  5.,   6.,   7.]]) ``index_add`(*dim*, *index*, *tensor*) → TensorOut-of-place version of [`torch.Tensor.index_add_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.index_add_)`index_copy_`(*dim*, *index*, *tensor*) → TensorCopies the elements of [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) into the `self` tensor by selecting the indices in the order given in `index`. For example, if `dim == 0` and `index[i] == j`, then the `i`th row of [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) is copied to the `j`th row of `self`.The [`dim`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.dim)th dimension of [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) must have the same size as the length of `index` (which must be a vector), and all other dimensions must match `self`, or an error will be raised.Parameters**dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – dimension along which to index**index** (*LongTensor*) – indices of [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) to select from**tensor** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the tensor containing values to copyExample:`>>> x = torch.zeros(5, 3) >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float) >>> index = torch.tensor([0, 4, 2]) >>> x.index_copy_(0, index, t) tensor([[ 1.,  2.,  3.],         [ 0.,  0.,  0.],         [ 7.,  8.,  9.],         [ 0.,  0.,  0.],         [ 4.,  5.,  6.]]) ``index_copy`(*dim*, *index*, *tensor*) → TensorOut-of-place version of [`torch.Tensor.index_copy_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.index_copy_)`index_fill_`(*dim*, *index*, *val*) → TensorFills the elements of the `self` tensor with value `val` by selecting the indices in the order given in `index`.Parameters**dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – dimension along which to index**index** (*LongTensor*) – indices of `self` tensor to fill in**val** ([*float*](https://docs.python.org/3/library/functions.html#float)) – the value to fill withExample::`>>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float) >>> index = torch.tensor([0, 2]) >>> x.index_fill_(1, index, -1) tensor([[-1.,  2., -1.],         [-1.,  5., -1.],         [-1.,  8., -1.]]) ``index_fill`(*dim*, *index*, *value*) → TensorOut-of-place version of [`torch.Tensor.index_fill_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.index_fill_)`index_put_`(*indices*, *value*, *accumulate=False*) → TensorPuts values from the tensor `value` into the tensor `self` using the indices specified in [`indices`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.indices) (which is a tuple of Tensors). The expression `tensor.index_put_(indices,value)` is equivalent to `tensor[indices] = value`. Returns `self`.If `accumulate` is `True`, the elements in [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) are added to `self`. If accumulate is `False`, the behavior is undefined if indices contain duplicate elements.Parameters**indices** (*tuple of LongTensor*) – tensors used to index into self.**value** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – tensor of same dtype as self.**accumulate** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – whether to accumulate into self`index_put`(*indices*, *value*, *accumulate=False*) → TensorOut-place version of [`index_put_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.index_put_)`index_select`(*dim*, *index*) → TensorSee [`torch.index_select()`](https://pytorch.org/docs/stable/torch.html#torch.index_select)`indices`() → TensorIf `self` is a sparse COO tensor (i.e., with `torch.sparse_coo` layout), this returns a view of the contained indices tensor. Otherwise, this throws an error.See also [`Tensor.values()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.values).NOTEThis method can only be called on a coalesced sparse tensor. See`Tensor.coalesce()` for details.`int`() → Tensor`self.int()` is equivalent to `self.to(torch.int32)`. See [`to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to).`int_repr`() → TensorGiven a quantized Tensor, `self.int_repr()` returns a CPU Tensor with uint8_t as data type that stores the underlying uint8_t values of the given Tensor.`inverse`() → TensorSee [`torch.inverse()`](https://pytorch.org/docs/stable/torch.html#torch.inverse)`irfft`(*signal_ndim*, *normalized=False*, *onesided=True*, *signal_sizes=None*) → TensorSee [`torch.irfft()`](https://pytorch.org/docs/stable/torch.html#torch.irfft)`is_contiguous`() → boolReturns True if `self` tensor is contiguous in memory in C order.`is_floating_point`() → boolReturns True if the data type of `self` is a floating point data type.`is_leaf`()All Tensors that have [`requires_grad`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.requires_grad) which is `False` will be leaf Tensors by convention.For Tensors that have [`requires_grad`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.requires_grad) which is `True`, they will be leaf Tensors if they were created by the user. This means that they are not the result of an operation and so`grad_fn` is None.Only leaf Tensors will have their [`grad`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.grad) populated during a call to [`backward()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.backward). To get [`grad`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.grad)populated for non-leaf Tensors, you can use [`retain_grad()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.retain_grad).Example:`>>> a = torch.rand(10, requires_grad=True) >>> a.is_leaf True >>> b = torch.rand(10, requires_grad=True).cuda() >>> b.is_leaf False # b was created by the operation that cast a cpu Tensor into a cuda Tensor >>> c = torch.rand(10, requires_grad=True) + 2 >>> c.is_leaf False # c was created by the addition operation >>> d = torch.rand(10).cuda() >>> d.is_leaf True # d does not require gradients and so has no operation creating it (that is tracked by the autograd engine) >>> e = torch.rand(10).cuda().requires_grad_() >>> e.is_leaf True # e requires gradients and has no operations creating it >>> f = torch.rand(10, requires_grad=True, device="cuda") >>> f.is_leaf True # f requires grad, has no operation creating it ``is_pinned`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.is_pinned)Returns true if this tensor resides in pinned memory`is_set_to`(*tensor*) → boolReturns True if this object refers to the same `THTensor` object from the Torch C API as the given tensor.`is_shared`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.is_shared)Checks if tensor is in shared memory.This is always `True` for CUDA tensors.`is_signed`() → boolReturns True if the data type of `self` is a signed data type.`is_sparse`()`item`() → numberReturns the value of this tensor as a standard python number. This only works for tensors with one element. For other cases, see [`tolist()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.tolist).This operation is not differentiable.Example:`>>> x = torch.tensor([1.0]) >>> x.item() 1.0 ``kthvalue`(*k*, *dim=None*, *keepdim=False) -> (Tensor*, *LongTensor*)See [`torch.kthvalue()`](https://pytorch.org/docs/stable/torch.html#torch.kthvalue)`le`(*other*) → TensorSee [`torch.le()`](https://pytorch.org/docs/stable/torch.html#torch.le)`le_`(*other*) → TensorIn-place version of [`le()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.le)`lerp`(*end*, *weight*) → TensorSee [`torch.lerp()`](https://pytorch.org/docs/stable/torch.html#torch.lerp)`lerp_`(*end*, *weight*) → TensorIn-place version of [`lerp()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.lerp)`log`() → TensorSee [`torch.log()`](https://pytorch.org/docs/stable/torch.html#torch.log)`log_`() → TensorIn-place version of [`log()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.log)`logdet`() → TensorSee [`torch.logdet()`](https://pytorch.org/docs/stable/torch.html#torch.logdet)`log10`() → TensorSee [`torch.log10()`](https://pytorch.org/docs/stable/torch.html#torch.log10)`log10_`() → TensorIn-place version of [`log10()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.log10)`log1p`() → TensorSee [`torch.log1p()`](https://pytorch.org/docs/stable/torch.html#torch.log1p)`log1p_`() → TensorIn-place version of [`log1p()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.log1p)`log2`() → TensorSee [`torch.log2()`](https://pytorch.org/docs/stable/torch.html#torch.log2)`log2_`() → TensorIn-place version of [`log2()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.log2)`log_normal_`(*mean=1*, *std=2*, ***, *generator=None*)Fills `self` tensor with numbers samples from the log-normal distribution parameterized by the given mean \muμ and standard deviation \sigmaσ. Note that [`mean`](https://pytorch.org/docs/stable/torch.html#torch.mean) and [`std`](https://pytorch.org/docs/stable/torch.html#torch.std) are the mean and standard deviation of the underlying normal distribution, and not of the returned distribution:f(x) = \dfrac{1}{x \sigma \sqrt{2\pi}}\ e^{-\frac{(\ln x - \mu)^2}{2\sigma^2}}f(x)=xσ2π1 e−2σ2(lnx−μ)2`logsumexp`(*dim*, *keepdim=False*) → TensorSee [`torch.logsumexp()`](https://pytorch.org/docs/stable/torch.html#torch.logsumexp)`long`() → Tensor`self.long()` is equivalent to `self.to(torch.int64)`. See [`to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to).`lt`(*other*) → TensorSee [`torch.lt()`](https://pytorch.org/docs/stable/torch.html#torch.lt)`lt_`(*other*) → TensorIn-place version of [`lt()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.lt)`lu`(*pivot=True*, *get_infos=False*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.lu)See [`torch.lu()`](https://pytorch.org/docs/stable/torch.html#torch.lu)`lu_solve`(*LU_data*, *LU_pivots*) → TensorSee [`torch.lu_solve()`](https://pytorch.org/docs/stable/torch.html#torch.lu_solve)`map_`(*tensor*, *callable*)Applies `callable` for each element in `self` tensor and the given [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) and stores the results in `self` tensor. `self` tensor and the given [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) must be [broadcastable](https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics).The `callable` should have the signature:`def callable(a, b) -> number ``masked_scatter_`(*mask*, *source*)Copies elements from `source` into `self` tensor at positions where the `mask` is one. The shape of `mask` must be [broadcastable](https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics) with the shape of the underlying tensor. The `source`should have at least as many elements as the number of ones in `mask`Parameters**mask** ([*ByteTensor*](https://pytorch.org/docs/stable/tensors.html#torch.ByteTensor)) – the binary mask**source** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the tensor to copy fromNOTEThe `mask` operates on the `self` tensor, not on the given `source` tensor.`masked_scatter`(*mask*, *tensor*) → TensorOut-of-place version of [`torch.Tensor.masked_scatter_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.masked_scatter_)`masked_fill_`(*mask*, *value*)Fills elements of `self` tensor with `value` where `mask` is one. The shape of `mask` must be[broadcastable](https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics) with the shape of the underlying tensor.Parameters**mask** ([*ByteTensor*](https://pytorch.org/docs/stable/tensors.html#torch.ByteTensor)) – the binary mask**value** ([*float*](https://docs.python.org/3/library/functions.html#float)) – the value to fill in with`masked_fill`(*mask*, *value*) → TensorOut-of-place version of [`torch.Tensor.masked_fill_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.masked_fill_)`masked_select`(*mask*) → TensorSee [`torch.masked_select()`](https://pytorch.org/docs/stable/torch.html#torch.masked_select)`matmul`(*tensor2*) → TensorSee [`torch.matmul()`](https://pytorch.org/docs/stable/torch.html#torch.matmul)`matrix_power`(*n*) → TensorSee [`torch.matrix_power()`](https://pytorch.org/docs/stable/torch.html#torch.matrix_power)`max`(*dim=None*, *keepdim=False) -> Tensor or (Tensor*, *Tensor*)See [`torch.max()`](https://pytorch.org/docs/stable/torch.html#torch.max)`mean`(*dim=None*, *keepdim=False) -> Tensor or (Tensor*, *Tensor*)See [`torch.mean()`](https://pytorch.org/docs/stable/torch.html#torch.mean)`median`(*dim=None*, *keepdim=False) -> (Tensor*, *LongTensor*)See [`torch.median()`](https://pytorch.org/docs/stable/torch.html#torch.median)`min`(*dim=None*, *keepdim=False) -> Tensor or (Tensor*, *Tensor*)See [`torch.min()`](https://pytorch.org/docs/stable/torch.html#torch.min)`mm`(*mat2*) → TensorSee [`torch.mm()`](https://pytorch.org/docs/stable/torch.html#torch.mm)`mode`(*dim=None*, *keepdim=False) -> (Tensor*, *LongTensor*)See [`torch.mode()`](https://pytorch.org/docs/stable/torch.html#torch.mode)`mul`(*value*) → TensorSee [`torch.mul()`](https://pytorch.org/docs/stable/torch.html#torch.mul)`mul_`(*value*)In-place version of [`mul()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.mul)`multinomial`(*num_samples*, *replacement=False*, ***, *generator=None*) → TensorSee [`torch.multinomial()`](https://pytorch.org/docs/stable/torch.html#torch.multinomial)`mv`(*vec*) → TensorSee [`torch.mv()`](https://pytorch.org/docs/stable/torch.html#torch.mv)`mvlgamma`(*p*) → TensorSee [`torch.mvlgamma()`](https://pytorch.org/docs/stable/torch.html#torch.mvlgamma)`mvlgamma_`(*p*) → TensorIn-place version of [`mvlgamma()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.mvlgamma)`narrow`(*dimension*, *start*, *length*) → TensorSee [`torch.narrow()`](https://pytorch.org/docs/stable/torch.html#torch.narrow)Example:`>>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> x.narrow(0, 0, 2) tensor([[ 1,  2,  3],         [ 4,  5,  6]]) >>> x.narrow(1, 1, 2) tensor([[ 2,  3],         [ 5,  6],         [ 8,  9]]) ``narrow_copy`(*dimension*, *start*, *length*) → TensorSame as [`Tensor.narrow()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.narrow) except returning a copy rather than shared storage. This is primarily for sparse tensors, which do not have a shared-storage narrow method. Calling ``narrow_copy` with ``dimemsion > self.sparse_dim()`` will return a copy with the relevant dense dimension narrowed, and ``self.shape`` updated accordingly.`ndimension`() → intAlias for [`dim()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.dim)`ne`(*other*) → TensorSee [`torch.ne()`](https://pytorch.org/docs/stable/torch.html#torch.ne)`ne_`(*other*) → TensorIn-place version of [`ne()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.ne)`neg`() → TensorSee [`torch.neg()`](https://pytorch.org/docs/stable/torch.html#torch.neg)`neg_`() → TensorIn-place version of [`neg()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.neg)`nelement`() → intAlias for [`numel()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.numel)`nonzero`() → LongTensorSee [`torch.nonzero()`](https://pytorch.org/docs/stable/torch.html#torch.nonzero)`norm`(*p='fro'*, *dim=None*, *keepdim=False*, *dtype=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.norm)See [`torch.norm()`](https://pytorch.org/docs/stable/torch.html#torch.norm)`normal_`(*mean=0*, *std=1*, ***, *generator=None*) → TensorFills `self` tensor with elements samples from the normal distribution parameterized by [`mean`](https://pytorch.org/docs/stable/torch.html#torch.mean) and [`std`](https://pytorch.org/docs/stable/torch.html#torch.std).`numel`() → intSee [`torch.numel()`](https://pytorch.org/docs/stable/torch.html#torch.numel)`numpy`() → numpy.ndarrayReturns `self` tensor as a NumPy `ndarray`. This tensor and the returned `ndarray` share the same underlying storage. Changes to `self` tensor will be reflected in the `ndarray` and vice versa.`orgqr`(*input2*) → TensorSee [`torch.orgqr()`](https://pytorch.org/docs/stable/torch.html#torch.orgqr)`ormqr`(*input2*, *input3*, *left=True*, *transpose=False*) → TensorSee [`torch.ormqr()`](https://pytorch.org/docs/stable/torch.html#torch.ormqr)`permute`(**dims*) → TensorPermute the dimensions of this tensor.Parameters***dims** (*int...*) – The desired ordering of dimensionsExample`>>> x = torch.randn(2, 3, 5) >>> x.size() torch.Size([2, 3, 5]) >>> x.permute(2, 0, 1).size() torch.Size([5, 2, 3]) ``pin_memory`() → TensorCopies the tensor to pinned memory, if it’s not already pinned.`pinverse`() → TensorSee [`torch.pinverse()`](https://pytorch.org/docs/stable/torch.html#torch.pinverse)`potrf`(*upper=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.potrf)See [`torch.cholesky()`](https://pytorch.org/docs/stable/torch.html#torch.cholesky)`potri`(*upper=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.potri)See [`torch.cholesky_inverse()`](https://pytorch.org/docs/stable/torch.html#torch.cholesky_inverse)`potrs`(*u*, *upper=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.potrs)See [`torch.cholesky_solve()`](https://pytorch.org/docs/stable/torch.html#torch.cholesky_solve)`pow`(*exponent*) → TensorSee [`torch.pow()`](https://pytorch.org/docs/stable/torch.html#torch.pow)`pow_`(*exponent*) → TensorIn-place version of [`pow()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.pow)`prod`(*dim=None*, *keepdim=False*, *dtype=None*) → TensorSee [`torch.prod()`](https://pytorch.org/docs/stable/torch.html#torch.prod)`pstrf`(*upper=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.pstrf)See [`torch.pstrf()`](https://pytorch.org/docs/stable/torch.html#torch.pstrf)`put_`(*indices*, *tensor*, *accumulate=False*) → TensorCopies the elements from [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) into the positions specified by indices. For the purpose of indexing, the `self` tensor is treated as if it were a 1-D tensor.If `accumulate` is `True`, the elements in [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor) are added to `self`. If accumulate is `False`, the behavior is undefined if indices contain duplicate elements.Parameters**indices** (*LongTensor*) – the indices into self**tensor** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the tensor containing values to copy from**accumulate** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – whether to accumulate into selfExample:`>>> src = torch.tensor([[4, 3, 5],                         [6, 7, 8]]) >>> src.put_(torch.tensor([1, 3]), torch.tensor([9, 10])) tensor([[  4,   9,   5],         [ 10,   7,   8]]) ``qr`(*) -> (Tensor*, *Tensor*)See [`torch.qr()`](https://pytorch.org/docs/stable/torch.html#torch.qr)`quantize_linear`(*scale*, *zero_point*) → TensorQuantize a float Tensor using affine quantization scheme with given scale and zero_point. returns the quantized Tensor.`q_scale`() → floatGiven a Tensor quantized by linear(affine) quantization, returns the scale of the underlying quantizer().`q_zero_point`() → intGiven a Tensor quantized by linear(affine) quantization, returns the zero_point of the underlying quantizer().`random_`(*from=0*, *to=None*, ***, *generator=None*) → TensorFills `self` tensor with numbers sampled from the discrete uniform distribution over `[from, to - 1]`. If not specified, the values are usually only bounded by `self` tensor’s data type. However, for floating point types, if unspecified, range will be `[0, 2^mantissa]`to ensure that every value is representable. For example, torch.tensor(1, dtype=torch.double).random_() will be uniform in `[0, 2^53]`.`reciprocal`() → TensorSee [`torch.reciprocal()`](https://pytorch.org/docs/stable/torch.html#torch.reciprocal)`reciprocal_`() → TensorIn-place version of [`reciprocal()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.reciprocal)`register_hook`(*hook*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.register_hook)Registers a backward hook.The hook will be called every time a gradient with respect to the Tensor is computed. The hook should have the following signature:`hook(grad) -> Tensor or None `The hook should not modify its argument, but it can optionally return a new gradient which will be used in place of [`grad`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.grad).This function returns a handle with a method `handle.remove()` that removes the hook from the module.Example:`>>> v = torch.tensor([0., 0., 0.], requires_grad=True) >>> h = v.register_hook(lambda grad: grad * 2)  # double the gradient >>> v.backward(torch.tensor([1., 2., 3.])) >>> v.grad   2  4  6 [torch.FloatTensor of size (3,)]  >>> h.remove()  # removes the hook ``remainder`(*divisor*) → TensorSee [`torch.remainder()`](https://pytorch.org/docs/stable/torch.html#torch.remainder)`remainder_`(*divisor*) → TensorIn-place version of [`remainder()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.remainder)`renorm`(*p*, *dim*, *maxnorm*) → TensorSee [`torch.renorm()`](https://pytorch.org/docs/stable/torch.html#torch.renorm)`renorm_`(*p*, *dim*, *maxnorm*) → TensorIn-place version of [`renorm()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.renorm)`repeat`(**sizes*) → TensorRepeats this tensor along the specified dimensions.Unlike [`expand()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.expand), this function copies the tensor’s data.WARNING`torch.repeat()` behaves differently from [numpy.repeat](https://docs.scipy.org/doc/numpy/reference/generated/numpy.repeat.html), but is more similar to[numpy.tile](https://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html). For the operator similar to numpy.repeat, see [`torch.repeat_interleave()`](https://pytorch.org/docs/stable/torch.html#torch.repeat_interleave).Parameters**sizes** (*torch.Size* *or* *int...*) – The number of times to repeat this tensor along each dimensionExample:`>>> x = torch.tensor([1, 2, 3]) >>> x.repeat(4, 2) tensor([[ 1,  2,  3,  1,  2,  3],         [ 1,  2,  3,  1,  2,  3],         [ 1,  2,  3,  1,  2,  3],         [ 1,  2,  3,  1,  2,  3]]) >>> x.repeat(4, 2, 1).size() torch.Size([4, 2, 3]) ``repeat_interleave`(*repeats*, *dim=None*) → TensorSee [`torch.repeat_interleave()`](https://pytorch.org/docs/stable/torch.html#torch.repeat_interleave).`requires_grad`()Is `True` if gradients need to be computed for this Tensor, `False` otherwise.NOTEThe fact that gradients need to be computed for a Tensor do not mean that the [`grad`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.grad) attribute will be populated, see [`is_leaf`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.is_leaf) for more details.`requires_grad_`(*requires_grad=True*) → TensorChange if autograd should record operations on this tensor: sets this tensor’s[`requires_grad`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.requires_grad) attribute in-place. Returns this tensor.`require_grad_()`’s main use case is to tell autograd to begin recording operations on a Tensor `tensor`. If `tensor` has `requires_grad=False` (because it was obtained through a DataLoader, or required preprocessing or initialization), `tensor.requires_grad_()` makes it so that autograd will begin to record operations on `tensor`.Parameters**requires_grad** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – If autograd should record operations on this tensor. Default: `True`.Example:`>>> # Let's say we want to preprocess some saved weights and use >>> # the result as new weights. >>> saved_weights = [0.1, 0.2, 0.3, 0.25] >>> loaded_weights = torch.tensor(saved_weights) >>> weights = preprocess(loaded_weights)  # some function >>> weights tensor([-0.5503,  0.4926, -2.1158, -0.8303])  >>> # Now, start to record operations done to weights >>> weights.requires_grad_() >>> out = weights.pow(2).sum() >>> out.backward() >>> weights.grad tensor([-1.1007,  0.9853, -4.2316, -1.6606]) ``reshape`(**shape*) → TensorReturns a tensor with the same data and number of elements as `self` but with the specified shape. This method returns a view if `shape` is compatible with the current shape. See [`torch.Tensor.view()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.view) on when it is possible to return a view.See [`torch.reshape()`](https://pytorch.org/docs/stable/torch.html#torch.reshape)Parameters**shape** (*tuple of python:ints* *or* *int...*) – the desired shape`reshape_as`(*other*) → TensorReturns this tensor as the same shape as `other`. `self.reshape_as(other)` is equivalent to `self.reshape(other.sizes())`. This method returns a view if `other.sizes()` is compatible with the current shape. See [`torch.Tensor.view()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.view) on when it is possible to return a view.Please see [`reshape()`](https://pytorch.org/docs/stable/torch.html#torch.reshape) for more information about `reshape`.Parameters**other** ([`torch.Tensor`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – The result tensor has the same shape as `other`.`resize_`(**sizes*) → TensorResizes `self` tensor to the specified size. If the number of elements is larger than the current storage size, then the underlying storage is resized to fit the new number of elements. If the number of elements is smaller, the underlying storage is not changed. Existing elements are preserved but any new memory is uninitialized.WARNINGThis is a low-level method. The storage is reinterpreted as C-contiguous, ignoring the current strides (unless the target size equals the current size, in which case the tensor is left unchanged). For most purposes, you will instead want to use [`view()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.view), which checks for contiguity, or [`reshape()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.reshape), which copies data if needed. To change the size in-place with custom strides, see [`set_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.set_).Parameters**sizes** (*torch.Size* *or* *int...*) – the desired sizeExample:`>>> x = torch.tensor([[1, 2], [3, 4], [5, 6]]) >>> x.resize_(2, 2) tensor([[ 1,  2],         [ 3,  4]]) ``resize_as_`(*tensor*) → TensorResizes the `self` tensor to be the same size as the specified [`tensor`](https://pytorch.org/docs/stable/torch.html#torch.tensor). This is equivalent to `self.resize_(tensor.size())`.`retain_grad`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.retain_grad)Enables .grad attribute for non-leaf Tensors.`rfft`(*signal_ndim*, *normalized=False*, *onesided=True*) → TensorSee [`torch.rfft()`](https://pytorch.org/docs/stable/torch.html#torch.rfft)`roll`(*shifts*, *dims*) → TensorSee [`torch.roll()`](https://pytorch.org/docs/stable/torch.html#torch.roll)`rot90`(*k*, *dims*) → TensorSee [`torch.rot90()`](https://pytorch.org/docs/stable/torch.html#torch.rot90)`round`() → TensorSee [`torch.round()`](https://pytorch.org/docs/stable/torch.html#torch.round)`round_`() → TensorIn-place version of [`round()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.round)`rsqrt`() → TensorSee [`torch.rsqrt()`](https://pytorch.org/docs/stable/torch.html#torch.rsqrt)`rsqrt_`() → TensorIn-place version of [`rsqrt()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.rsqrt)`scatter`(*dim*, *index*, *source*) → TensorOut-of-place version of [`torch.Tensor.scatter_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.scatter_)`scatter_`(*dim*, *index*, *src*) → TensorWrites all values from the tensor `src` into `self` at the indices specified in the `index`tensor. For each value in `src`, its output index is specified by its index in `src` for `dimension != dim` and by the corresponding value in `index` for `dimension = dim`.For a 3-D tensor, `self` is updated as:`self[index[i][j][k]][j][k] = src[i][j][k]  # if dim == 0 self[i][index[i][j][k]][k] = src[i][j][k]  # if dim == 1 self[i][j][index[i][j][k]] = src[i][j][k]  # if dim == 2 `This is the reverse operation of the manner described in [`gather()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.gather).`self`, `index` and `src` (if it is a Tensor) should have same number of dimensions. It is also required that `index.size(d) <= src.size(d)` for all dimensions `d`, and that `index.size(d) <= self.size(d)` for all dimensions `d != dim`.Moreover, as for [`gather()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.gather), the values of `index` must be between `0` and `self.size(dim)- 1` inclusive, and all values in a row along the specified dimension [`dim`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.dim) must be unique.Parameters**dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the axis along which to index**index** (*LongTensor*) – the indices of elements to scatter, can be either empty or the same size of src. When empty, the operation returns identity**src** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the source element(s) to scatter, incase value is not specified**value** ([*float*](https://docs.python.org/3/library/functions.html#float)) – the source element(s) to scatter, incase src is not specifiedExample:`>>> x = torch.rand(2, 5) >>> x tensor([[ 0.3992,  0.2908,  0.9044,  0.4850,  0.6004],         [ 0.5735,  0.9006,  0.6797,  0.4152,  0.1732]]) >>> torch.zeros(3, 5).scatter_(0, torch.tensor([[0, 1, 2, 0, 0], [2, 0, 0, 1, 2]]), x) tensor([[ 0.3992,  0.9006,  0.6797,  0.4850,  0.6004],         [ 0.0000,  0.2908,  0.0000,  0.4152,  0.0000],         [ 0.5735,  0.0000,  0.9044,  0.0000,  0.1732]])  >>> z = torch.zeros(2, 4).scatter_(1, torch.tensor([[2], [3]]), 1.23) >>> z tensor([[ 0.0000,  0.0000,  1.2300,  0.0000],         [ 0.0000,  0.0000,  0.0000,  1.2300]]) ``scatter_add_`(*dim*, *index*, *other*) → TensorAdds all values from the tensor `other` into `self` at the indices specified in the `index`tensor in a similar fashion as [`scatter_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.scatter_). For each value in `other`, it is added to an index in `self` which is specified by its index in `other` for `dimension != dim` and by the corresponding value in `index` for `dimension = dim`.For a 3-D tensor, `self` is updated as:`self[index[i][j][k]][j][k] += other[i][j][k]  # if dim == 0 self[i][index[i][j][k]][k] += other[i][j][k]  # if dim == 1 self[i][j][index[i][j][k]] += other[i][j][k]  # if dim == 2 ``self`, `index` and `other` should have same number of dimensions. It is also required that `index.size(d) <= other.size(d)` for all dimensions `d`, and that `index.size(d) <=self.size(d)` for all dimensions `d != dim`.Moreover, as for [`gather()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.gather), the values of `index` must be between `0` and `self.size(dim)- 1` inclusive, and all values in a row along the specified dimension [`dim`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.dim) must be unique.NOTEWhen using the CUDA backend, this operation may induce nondeterministic behaviour that is not easily switched off. Please see the notes on [Reproducibility](https://pytorch.org/docs/stable/notes/randomness.html) for background.Parameters**dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the axis along which to index**index** (*LongTensor*) – the indices of elements to scatter and add, can be either empty or the same size of src. When empty, the operation returns identity.**other** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the source elements to scatter and addExample:`>>> x = torch.rand(2, 5) >>> x tensor([[0.7404, 0.0427, 0.6480, 0.3806, 0.8328],         [0.7953, 0.2009, 0.9154, 0.6782, 0.9620]]) >>> torch.ones(3, 5).scatter_add_(0, torch.tensor([[0, 1, 2, 0, 0], [2, 0, 0, 1, 2]]), x) tensor([[1.7404, 1.2009, 1.9154, 1.3806, 1.8328],         [1.0000, 1.0427, 1.0000, 1.6782, 1.0000],         [1.7953, 1.0000, 1.6480, 1.0000, 1.9620]]) ``scatter_add`(*dim*, *index*, *source*) → TensorOut-of-place version of [`torch.Tensor.scatter_add_()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.scatter_add_)`select`(*dim*, *index*) → TensorSlices the `self` tensor along the selected dimension at the given index. This function returns a tensor with the given dimension removed.Parameters**dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the dimension to slice**index** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the index to select withNOTE[`select()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.select) is equivalent to slicing. For example, `tensor.select(0, index)` is equivalent to `tensor[index]` and `tensor.select(2, index)` is equivalent to `tensor[:,:,index]`.`set_`(*source=None*, *storage_offset=0*, *size=None*, *stride=None*) → TensorSets the underlying storage, size, and strides. If `source` is a tensor, `self` tensor will share the same storage and have the same size and strides as `source`. Changes to elements in one tensor will be reflected in the other.If `source` is a `Storage`, the method sets the underlying storage, offset, size, and stride.Parameters**source** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor) *or* *Storage*) – the tensor or storage to use**storage_offset** ([*int*](https://docs.python.org/3/library/functions.html#int)*,* *optional*) – the offset in the storage**size** (*torch.Size**,* *optional*) – the desired size. Defaults to the size of the source.**stride** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*,* *optional*) – the desired stride. Defaults to C-contiguous strides.`share_memory_`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.share_memory_)Moves the underlying storage to shared memory.This is a no-op if the underlying storage is already in shared memory and for CUDA tensors. Tensors in shared memory cannot be resized.`short`() → Tensor`self.short()` is equivalent to `self.to(torch.int16)`. See [`to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to).`sigmoid`() → TensorSee [`torch.sigmoid()`](https://pytorch.org/docs/stable/torch.html#torch.sigmoid)`sigmoid_`() → TensorIn-place version of [`sigmoid()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.sigmoid)`sign`() → TensorSee [`torch.sign()`](https://pytorch.org/docs/stable/torch.html#torch.sign)`sign_`() → TensorIn-place version of [`sign()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.sign)`sin`() → TensorSee [`torch.sin()`](https://pytorch.org/docs/stable/torch.html#torch.sin)`sin_`() → TensorIn-place version of [`sin()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.sin)`sinh`() → TensorSee [`torch.sinh()`](https://pytorch.org/docs/stable/torch.html#torch.sinh)`sinh_`() → TensorIn-place version of [`sinh()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.sinh)`size`() → torch.SizeReturns the size of the `self` tensor. The returned value is a subclass of [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple).Example:`>>> torch.empty(3, 4, 5).size() torch.Size([3, 4, 5]) ``slogdet`(*) -> (Tensor*, *Tensor*)See [`torch.slogdet()`](https://pytorch.org/docs/stable/torch.html#torch.slogdet)`solve`(*A*) → Tensor, TensorSee [`torch.solve()`](https://pytorch.org/docs/stable/torch.html#torch.solve)`sort`(*dim=-1*, *descending=False) -> (Tensor*, *LongTensor*)See [`torch.sort()`](https://pytorch.org/docs/stable/torch.html#torch.sort)`split`(*split_size*, *dim=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.split)See [`torch.split()`](https://pytorch.org/docs/stable/torch.html#torch.split)`sparse_mask`(*input*, *mask*) → TensorReturns a new SparseTensor with values from Tensor `input` filtered by indices of `mask`and values are ignored. `input` and `mask` must have the same shape.Parameters**input** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – an input Tensor**mask** (*SparseTensor*) – a SparseTensor which we filter `input` based on its indicesExample:`>>> nnz = 5 >>> dims = [5, 5, 2, 2] >>> I = torch.cat([torch.randint(0, dims[0], size=(nnz,)),                    torch.randint(0, dims[1], size=(nnz,))], 0).reshape(2, nnz) >>> V = torch.randn(nnz, dims[2], dims[3]) >>> size = torch.Size(dims) >>> S = torch.sparse_coo_tensor(I, V, size).coalesce() >>> D = torch.randn(dims) >>> D.sparse_mask(S) tensor(indices=tensor([[0, 0, 0, 2],                        [0, 1, 4, 3]]),        values=tensor([[[ 1.6550,  0.2397],                        [-0.1611, -0.0779]],                        [[ 0.2326, -1.0558],                        [ 1.4711,  1.9678]],                        [[-0.5138, -0.0411],                        [ 1.9417,  0.5158]],                        [[ 0.0793,  0.0036],                        [-0.2569, -0.1055]]]),        size=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo) ``sparse_dim`() → intIf `self` is a sparse COO tensor (i.e., with `torch.sparse_coo` layout), this returns a the number of sparse dimensions. Otherwise, this throws an error.See also [`Tensor.dense_dim()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.dense_dim).`sqrt`() → TensorSee [`torch.sqrt()`](https://pytorch.org/docs/stable/torch.html#torch.sqrt)`sqrt_`() → TensorIn-place version of [`sqrt()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.sqrt)`squeeze`(*dim=None*) → TensorSee [`torch.squeeze()`](https://pytorch.org/docs/stable/torch.html#torch.squeeze)`squeeze_`(*dim=None*) → TensorIn-place version of [`squeeze()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.squeeze)`std`(*dim=None*, *unbiased=True*, *keepdim=False*) → TensorSee [`torch.std()`](https://pytorch.org/docs/stable/torch.html#torch.std)`stft`(*n_fft*, *hop_length=None*, *win_length=None*, *window=None*, *center=True*, *pad_mode='reflect'*, *normalized=False*, *onesided=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.stft)See [`torch.stft()`](https://pytorch.org/docs/stable/torch.html#torch.stft)WARNINGThis function changed signature at version 0.4.1. Calling with the previous signature may cause error or return incorrect result.`storage`() → torch.StorageReturns the underlying storage.`storage_offset`() → intReturns `self` tensor’s offset in the underlying storage in terms of number of storage elements (not bytes).Example:`>>> x = torch.tensor([1, 2, 3, 4, 5]) >>> x.storage_offset() 0 >>> x[3:].storage_offset() 3 ``storage_type`() → typeReturns the type of the underlying storage.`stride`(*dim*) → tuple or intReturns the stride of `self` tensor.Stride is the jump necessary to go from one element to the next one in the specified dimension [`dim`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.dim). A tuple of all strides is returned when no argument is passed in. Otherwise, an integer value is returned as the stride in the particular dimension [`dim`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.dim).Parameters**dim** ([*int*](https://docs.python.org/3/library/functions.html#int)*,* *optional*) – the desired dimension in which stride is requiredExample:`>>> x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]) >>> x.stride() (5, 1) >>>x.stride(0) 5 >>> x.stride(-1) 1 ``sub`(*value*, *other*) → TensorSubtracts a scalar or tensor from `self` tensor. If both `value` and `other` are specified, each element of `other` is scaled by `value` before being used.When `other` is a tensor, the shape of `other` must be [broadcastable](https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics) with the shape of the underlying tensor.`sub_`(*x*) → TensorIn-place version of [`sub()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.sub)`sum`(*dim=None*, *keepdim=False*, *dtype=None*) → TensorSee [`torch.sum()`](https://pytorch.org/docs/stable/torch.html#torch.sum)`sum_to_size`(**size*) → TensorSum `this` tensor to [`size`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.size). [`size`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.size) must be broadcastable to `this` tensor size. :param other: The result tensor has the same sizeas `other`.`svd`(*some=True*, *compute_uv=True) -> (Tensor*, *Tensor*, *Tensor*)See [`torch.svd()`](https://pytorch.org/docs/stable/torch.html#torch.svd)`symeig`(*eigenvectors=False*, *upper=True) -> (Tensor*, *Tensor*)See [`torch.symeig()`](https://pytorch.org/docs/stable/torch.html#torch.symeig)`t`() → TensorSee [`torch.t()`](https://pytorch.org/docs/stable/torch.html#torch.t)`t_`() → TensorIn-place version of [`t()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.t)`to`(**args*, **\*kwargs*) → TensorPerforms Tensor dtype and/or device conversion. A [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) are inferred from the arguments of `self.to(*args, **kwargs)`.NOTEIf the `self` Tensor already has the correct [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device), then `self` is returned. Otherwise, the returned tensor is a copy of `self` with the desired[`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device).Here are the ways to call `to`:`to`(*dtype*, *non_blocking=False*, *copy=False*) → TensorReturns a Tensor with the specified `dtype``to`(*device=None*, *dtype=None*, *non_blocking=False*, *copy=False*)→ TensorReturns a Tensor with the specified [`device`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.device) and (optional) `dtype`. If `dtype` is `None` it is inferred to be `self.dtype`. When `non_blocking`, tries to convert asynchronously with respect to the host if possible, e.g., converting a CPU Tensor with pinned memory to a CUDA Tensor. When `copy` is set, a new Tensor is created even when the Tensor already matches the desired conversion.`to`(*other*, *non_blocking=False*, *copy=False*) → TensorReturns a Tensor with same [`torch.dtype`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.dtype) and [`torch.device`](https://pytorch.org/docs/stable/tensor_attributes.html#torch.torch.device) as the Tensor `other`. When `non_blocking`, tries to convert asynchronously with respect to the host if possible, e.g., converting a CPU Tensor with pinned memory to a CUDA Tensor. When `copy` is set, a new Tensor is created even when the Tensor already matches the desired conversion.Example:`>>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu >>> tensor.to(torch.float64) tensor([[-0.5044,  0.0005],         [ 0.3310, -0.0584]], dtype=torch.float64)  >>> cuda0 = torch.device('cuda:0') >>> tensor.to(cuda0) tensor([[-0.5044,  0.0005],         [ 0.3310, -0.0584]], device='cuda:0')  >>> tensor.to(cuda0, dtype=torch.float64) tensor([[-0.5044,  0.0005],         [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')  >>> other = torch.randn((), dtype=torch.float64, device=cuda0) >>> tensor.to(other, non_blocking=True) tensor([[-0.5044,  0.0005],         [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0') ``to_mkldnn`() → TensorReturns a copy of the tensor in `torch.mkldnn` layout.`take`(*indices*) → TensorSee [`torch.take()`](https://pytorch.org/docs/stable/torch.html#torch.take)`tan`() → TensorSee [`torch.tan()`](https://pytorch.org/docs/stable/torch.html#torch.tan)`tan_`() → TensorIn-place version of [`tan()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.tan)`tanh`() → TensorSee [`torch.tanh()`](https://pytorch.org/docs/stable/torch.html#torch.tanh)`tanh_`() → TensorIn-place version of [`tanh()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.tanh)`tolist`()” tolist() -> list or numberReturns the tensor as a (nested) list. For scalars, a standard python number is returned, just like with [`item()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.item). Tensors are automatically moved to the CPU first if necessary.This operation is not differentiable.Examples:`>>> a = torch.randn(2, 2) >>> a.tolist() [[0.012766935862600803, 0.5415473580360413],  [-0.08909505605697632, 0.7729271650314331]] >>> a[0,0].tolist() 0.012766935862600803 ``topk`(*k*, *dim=None*, *largest=True*, *sorted=True) -> (Tensor*, *LongTensor*)See [`torch.topk()`](https://pytorch.org/docs/stable/torch.html#torch.topk)`to_sparse`(*sparseDims*) → TensorReturns a sparse copy of the tensor. PyTorch supports sparse tensors in [coordinate format](https://pytorch.org/docs/stable/sparse.html#sparse-docs).Parameters**sparseDims** ([*int*](https://docs.python.org/3/library/functions.html#int)*,* *optional*) – the number of sparse dimensions to include in the new sparse tensorExample:`>>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]]) >>> d tensor([[ 0,  0,  0],         [ 9,  0, 10],         [ 0,  0,  0]]) >>> d.to_sparse() tensor(indices=tensor([[1, 1],                        [0, 2]]),        values=tensor([ 9, 10]),        size=(3, 3), nnz=2, layout=torch.sparse_coo) >>> d.to_sparse(1) tensor(indices=tensor([[1]]),        values=tensor([[ 9,  0, 10]]),        size=(3, 3), nnz=1, layout=torch.sparse_coo) ``trace`() → TensorSee [`torch.trace()`](https://pytorch.org/docs/stable/torch.html#torch.trace)`transpose`(*dim0*, *dim1*) → TensorSee [`torch.transpose()`](https://pytorch.org/docs/stable/torch.html#torch.transpose)`transpose_`(*dim0*, *dim1*) → TensorIn-place version of [`transpose()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.transpose)`triangular_solve`(*A*, *upper=True*, *transpose=False*, *unitriangular=False) -> (Tensor*, *Tensor*)See [`torch.triangular_solve()`](https://pytorch.org/docs/stable/torch.html#torch.triangular_solve)`tril`(*k=0*) → TensorSee [`torch.tril()`](https://pytorch.org/docs/stable/torch.html#torch.tril)`tril_`(*k=0*) → TensorIn-place version of [`tril()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.tril)`triu`(*k=0*) → TensorSee [`torch.triu()`](https://pytorch.org/docs/stable/torch.html#torch.triu)`triu_`(*k=0*) → TensorIn-place version of [`triu()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.triu)`trtrs`(*A*, *upper=True*, *transpose=False*, *unitriangular=False*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.trtrs)See [`torch.triangular_solve()`](https://pytorch.org/docs/stable/torch.html#torch.triangular_solve)`trunc`() → TensorSee [`torch.trunc()`](https://pytorch.org/docs/stable/torch.html#torch.trunc)`trunc_`() → TensorIn-place version of [`trunc()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.trunc)`type`(*dtype=None*, *non_blocking=False*, **\*kwargs*) → str or TensorReturns the type if dtype is not provided, else casts this object to the specified type.If this is already of the correct type, no copy is performed and the original object is returned.Parameters**dtype** ([*type*](https://docs.python.org/3/library/functions.html#type) *or* *string*) – The desired type**non_blocking** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – If `True`, and the source is in pinned memory and destination is on the GPU or vice versa, the copy is performed asynchronously with respect to the host. Otherwise, the argument has no effect.***\*kwargs** – For compatibility, may contain the key `async` in place of the `non_blocking` argument. The `async` arg is deprecated.`type_as`(*tensor*) → TensorReturns this tensor cast to the type of the given tensor.This is a no-op if the tensor is already of the correct type. This is equivalent to `self.type(tensor.type())`Parameters**tensor** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the tensor which has the desired type`unbind`(*dim=0*) → seqSee [`torch.unbind()`](https://pytorch.org/docs/stable/torch.html#torch.unbind)`unfold`(*dimension*, *size*, *step*) → TensorReturns a tensor which contains all slices of size [`size`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.size) from `self` tensor in the dimension `dimension`.Step between two slices is given by `step`.If sizedim is the size of dimension `dimension` for `self`, the size of dimension `dimension`in the returned tensor will be (sizedim - size) / step + 1.An additional dimension of size [`size`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.size) is appended in the returned tensor.Parameters**dimension** ([*int*](https://docs.python.org/3/library/functions.html#int)) – dimension in which unfolding happens**size** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the size of each slice that is unfolded**step** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the step between each sliceExample:`>>> x = torch.arange(1., 8) >>> x tensor([ 1.,  2.,  3.,  4.,  5.,  6.,  7.]) >>> x.unfold(0, 2, 1) tensor([[ 1.,  2.],         [ 2.,  3.],         [ 3.,  4.],         [ 4.,  5.],         [ 5.,  6.],         [ 6.,  7.]]) >>> x.unfold(0, 2, 2) tensor([[ 1.,  2.],         [ 3.,  4.],         [ 5.,  6.]]) ``uniform_`(*from=0*, *to=1*) → TensorFills `self` tensor with numbers sampled from the continuous uniform distribution:P(x) = \dfrac{1}{\text{to} - \text{from}}P(x)=to−from1`unique`(*sorted=True*, *return_inverse=False*, *return_counts=False*, *dim=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.unique)Returns the unique elements of the input tensor.See [`torch.unique()`](https://pytorch.org/docs/stable/torch.html#torch.unique)`unique_consecutive`(*return_inverse=False*, *return_counts=False*, *dim=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.unique_consecutive)Eliminates all but the first element from every consecutive group of equivalent elements.See [`torch.unique_consecutive()`](https://pytorch.org/docs/stable/torch.html#torch.unique_consecutive)`unsqueeze`(*dim*) → TensorSee [`torch.unsqueeze()`](https://pytorch.org/docs/stable/torch.html#torch.unsqueeze)`unsqueeze_`(*dim*) → TensorIn-place version of [`unsqueeze()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.unsqueeze)`values`() → TensorIf `self` is a sparse COO tensor (i.e., with `torch.sparse_coo` layout), this returns a view of the contained values tensor. Otherwise, this throws an error.See also [`Tensor.indices()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.indices).NOTEThis method can only be called on a coalesced sparse tensor. See`Tensor.coalesce()` for details.`var`(*dim=None*, *unbiased=True*, *keepdim=False*) → TensorSee [`torch.var()`](https://pytorch.org/docs/stable/torch.html#torch.var)`view`(**shape*) → TensorReturns a new tensor with the same data as the `self` tensor but of a different `shape`.The returned tensor shares the same data and must have the same number of elements, but may have a different size. For a tensor to be viewed, the new view size must be compatible with its original size and stride, i.e., each new view dimension must either be a subspace of an original dimension, or only span across original dimensions d, d+1, \dots, d+kd,d+1,…,d+k that satisfy the following contiguity-like condition that \forall i = 0, \dots, k-1∀i=0,…,k−1,\text{stride}[i] = \text{stride}[i+1] \times \text{size}[i+1]stride[i]=stride[i+1]×size[i+1]Otherwise, [`contiguous()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.contiguous) needs to be called before the tensor can be viewed. See also: [`reshape()`](https://pytorch.org/docs/stable/torch.html#torch.reshape), which returns a view if the shapes are compatible, and copies (equivalent to calling [`contiguous()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.contiguous)) otherwise.Parameters**shape** (*torch.Size* *or* *int...*) – the desired sizeExample:`>>> x = torch.randn(4, 4) >>> x.size() torch.Size([4, 4]) >>> y = x.view(16) >>> y.size() torch.Size([16]) >>> z = x.view(-1, 8)  # the size -1 is inferred from other dimensions >>> z.size() torch.Size([2, 8])  >>> a = torch.randn(1, 2, 3, 4) >>> a.size() torch.Size([1, 2, 3, 4]) >>> b = a.transpose(1, 2)  # Swaps 2nd and 3rd dimension >>> b.size() torch.Size([1, 3, 2, 4]) >>> c = a.view(1, 3, 2, 4)  # Does not change tensor layout in memory >>> c.size() torch.Size([1, 3, 2, 4]) >>> torch.equal(b, c) False ``view_as`(*other*) → TensorView this tensor as the same size as `other`. `self.view_as(other)` is equivalent to `self.view(other.size())`.Please see [`view()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.view) for more information about `view`.Parameters**other** ([`torch.Tensor`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – The result tensor has the same size as `other`.`where`(*condition*, *y*) → Tensor`self.where(condition, y)` is equivalent to `torch.where(condition, self, y)`. See [`torch.where()`](https://pytorch.org/docs/stable/torch.html#torch.where)`zero_`() → TensorFills `self` tensor with zeros.

- *CLASS*`torch.``ByteTensor`

  The following methods are unique to [`torch.ByteTensor`](https://pytorch.org/docs/stable/tensors.html#torch.ByteTensor).`all`()`all`() → boolReturns True if all elements in the tensor are non-zero, False otherwise.Example:`>>> a = torch.randn(1, 3).byte() % 2 >>> a tensor([[1, 0, 0]], dtype=torch.uint8) >>> a.all() tensor(0, dtype=torch.uint8) ``all`(*dim*, *keepdim=False*, *out=None*) → TensorReturns True if all elements in each row of the tensor in the given dimension `dim` are non-zero, False otherwise.If `keepdim` is `True`, the output tensor is of the same size as `input` except in the dimension `dim` where it is of size 1. Otherwise, `dim` is squeezed (see [`torch.squeeze()`](https://pytorch.org/docs/stable/torch.html#torch.squeeze)), resulting in the output tensor having 1 fewer dimension than `input`.Parameters**dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the dimension to reduce**keepdim** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – whether the output tensor has `dim` retained or not**out** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)*,* *optional*) – the output tensorExample:`>>> a = torch.randn(4, 2).byte() % 2 >>> a tensor([[0, 0],         [0, 0],         [0, 1],         [1, 1]], dtype=torch.uint8) >>> a.all(dim=1) tensor([0, 0, 0, 1], dtype=torch.uint8) ``any`()`any`() → boolReturns True if any elements in the tensor are non-zero, False otherwise.Example:`>>> a = torch.randn(1, 3).byte() % 2 >>> a tensor([[0, 0, 1]], dtype=torch.uint8) >>> a.any() tensor(1, dtype=torch.uint8) ``any`(*dim*, *keepdim=False*, *out=None*) → TensorReturns True if any elements in each row of the tensor in the given dimension `dim` are non-zero, False otherwise.If `keepdim` is `True`, the output tensor is of the same size as `input` except in the dimension `dim` where it is of size 1. Otherwise, `dim` is squeezed (see [`torch.squeeze()`](https://pytorch.org/docs/stable/torch.html#torch.squeeze)), resulting in the output tensor having 1 fewer dimension than `input`.Parameters**dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the dimension to reduce**keepdim** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – whether the output tensor has `dim` retained or not**out** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)*,* *optional*) – the output tensorExample:`>>> a = torch.randn(4, 2).byte() % 2 >>> a tensor([[1, 0],         [0, 0],         [0, 1],         [0, 0]], dtype=torch.uint8) >>> a.any(dim=1) tensor([1, 0, 1, 0], dtype=torch.uint8)`
