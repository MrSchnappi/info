---
title: 14 torch.distributions
toc: true
date: 2019-06-29
---
# PROBABILITY DISTRIBUTIONS - TORCH.DISTRIBUTIONS

The `distributions` package contains parameterizable probability distributions and sampling functions. This allows the construction of stochastic computation graphs and stochastic gradient estimators for optimization. This package generally follows the design of the [TensorFlow Distributions](https://arxiv.org/abs/1711.10604) package.

It is not possible to directly backpropagate through random samples. However, there are two main methods for creating surrogate functions that can be backpropagated through. These are the score function estimator/likelihood ratio estimator/REINFORCE and the pathwise derivative estimator. REINFORCE is commonly seen as the basis for policy gradient methods in reinforcement learning, and the pathwise derivative estimator is commonly seen in the reparameterization trick in variational autoencoders. Whilst the score function only requires the value of samples f(x)f(x), the pathwise derivative requires the derivative f&#x27;(x)f′(x). The next sections discuss these two in a reinforcement learning example. For more details see[Gradient Estimation Using Stochastic Computation Graphs](https://arxiv.org/abs/1506.05254) .

## Score function

When the probability density function is differentiable with respect to its parameters, we only need `sample()`and `log_prob()` to implement REINFORCE:

\Delta\theta = \alpha r \frac{\partial\log p(a|\pi^\theta(s))}{\partial\theta}Δθ=αr∂θ∂logp(a∣πθ(s))

where \thetaθ are the parameters, \alphaα is the learning rate, rr is the reward and p(a|\pi^\theta(s))p(a∣πθ(s)) is the probability of taking action aa in state ss given policy \pi^\thetaπθ.

In practice we would sample an action from the output of a network, apply this action in an environment, and then use `log_prob` to construct an equivalent loss function. Note that we use a negative because optimizers use gradient descent, whilst the rule above assumes gradient ascent. With a categorical policy, the code for implementing REINFORCE would be as follows:

```
probs = policy_network(state)
# Note that this is equivalent to what used to be called multinomial
m = Categorical(probs)
action = m.sample()
next_state, reward = env.step(action)
loss = -m.log_prob(action) * reward
loss.backward()
```

## Pathwise derivative

The other way to implement these stochastic/policy gradients would be to use the reparameterization trick from the `rsample()` method, where the parameterized random variable can be constructed via a parameterized deterministic function of a parameter-free random variable. The reparameterized sample therefore becomes differentiable. The code for implementing the pathwise derivative would be as follows:

```
params = policy_network(state)
m = Normal(*params)
# Any distribution with .has_rsample == True could work based on the application
action = m.rsample()
next_state, reward = env.step(action)  # Assuming that reward is differentiable
loss = -reward
loss.backward()
```

## Distribution

- *CLASS*`torch.distributions.distribution.``Distribution`(*batch_shape=torch.Size([])*, *event_shape=torch.Size([])*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution)

  Bases: [`object`](https://docs.python.org/3/library/functions.html#object)Distribution is the abstract base class for probability distributions.`arg_constraints`Returns a dictionary from argument names to [`Constraint`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraints.Constraint) objects that should be satisfied by each argument of this distribution. Args that are not tensors need not appear in this dict.`batch_shape`Returns the shape over which parameters are batched.`cdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.cdf)Returns the cumulative density/mass function evaluated at value.Parameters**value** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) –`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.entropy)Returns entropy of distribution, batched over batch_shape.ReturnsTensor of shape batch_shape.`enumerate_support`(*expand=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.enumerate_support)Returns tensor containing all values supported by a discrete distribution. The result will enumerate over dimension 0, so the shape of the result will be (cardinality,) + batch_shape + event_shape (where event_shape = () for univariate distributions).Note that this enumerates over all batched tensors in lock-step [[0, 0], [1, 1], …]. With expand=False, enumeration happens along dim 0, but with the remaining batch dimensions being singleton dimensions, [[0], [1], ...To iterate over the full Cartesian product use itertools.product(m.enumerate_support()).Parameters**expand** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – whether to expand the support over the batch dims to match the distribution’s batch_shape.ReturnsTensor iterating over dimension 0.`event_shape`Returns the shape of a single sample (without batching).`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.expand)Returns a new distribution instance (or populates an existing instance provided by a derived class) with batch dimensions expanded to batch_shape. This method calls [`expand`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.expand)on the distribution’s parameters. As such, this does not allocate new memory for the expanded distribution instance. Additionally, this does not repeat any args checking or parameter broadcasting in __init__.py, when an instance is first created.Parameters**batch_shape** (*torch.Size*) – the desired expanded size.**_instance** – new instance provided by subclasses that need to override .expand.ReturnsNew distribution instance with batch dimensions expanded to batch_size.`icdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.icdf)Returns the inverse cumulative density/mass function evaluated at value.Parameters**value** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) –`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.log_prob)Returns the log of the probability density/mass function evaluated at value.Parameters**value** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) –`mean`Returns the mean of the distribution.`perplexity`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.perplexity)Returns perplexity of distribution, batched over batch_shape.ReturnsTensor of shape batch_shape.`rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.rsample)Generates a sample_shape shaped reparameterized sample or sample_shape shaped batch of reparameterized samples if the distribution parameters are batched.`sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.sample)Generates a sample_shape shaped sample or sample_shape shaped batch of samples if the distribution parameters are batched.`sample_n`(*n*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/distribution.html#Distribution.sample_n)Generates n samples or n batches of samples if the distribution parameters are batched.`stddev`Returns the standard deviation of the distribution.`support`Returns a [`Constraint`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraints.Constraint) object representing this distribution’s support.`variance`Returns the variance of the distribution.

## ExponentialFamily

- *CLASS*`torch.distributions.exp_family.``ExponentialFamily`(*batch_shape=torch.Size([])*, *event_shape=torch.Size([])*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/exp_family.html#ExponentialFamily)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)ExponentialFamily is the abstract base class for probability distributions belonging to an exponential family, whose probability mass/density function has the form is defined belowp_{F}(x; \theta) = \exp(\langle t(x), \theta\rangle - F(\theta) + k(x))pF(x;θ)=exp(⟨t(x),θ⟩−F(θ)+k(x))where \thetaθ denotes the natural parameters, t(x)t(x) denotes the sufficient statistic, F(\theta)F(θ) is the log normalizer function for a given family and k(x)k(x) is the carrier measure.NOTEThis class is an intermediary between the Distribution class and distributions which belong to an exponential family mainly to check the correctness of the .entropy() and analytic KL divergence methods. We use this class to compute the entropy and KL divergence using the AD framework and Bregman divergences (courtesy of: Frank Nielsen and Richard Nock, Entropies and Cross-entropies of Exponential Families).`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/exp_family.html#ExponentialFamily.entropy)Method to compute the entropy using Bregman divergence of the log normalizer.

## Bernoulli

- *CLASS*`torch.distributions.bernoulli.``Bernoulli`(*probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/bernoulli.html#Bernoulli)

  Bases: [`torch.distributions.exp_family.ExponentialFamily`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.exp_family.ExponentialFamily)Creates a Bernoulli distribution parameterized by [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.bernoulli.Bernoulli.probs) or [`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.bernoulli.Bernoulli.logits) (but not both).Samples are binary (0 or 1). They take the value 1 with probability p and 0 with probability 1 - p.Example:`>>> m = Bernoulli(torch.tensor([0.3])) >>> m.sample()  # 30% chance 1; 70% chance 0 tensor([ 0.]) `Parameters**probs** (*Number**,* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the probability of sampling 1**logits** (*Number**,* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the log-odds of sampling 1`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': INTERVAL(LOWER_BOUND=0.0, UPPER_BOUND=1.0)}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/bernoulli.html#Bernoulli.entropy)`enumerate_support`(*expand=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/bernoulli.html#Bernoulli.enumerate_support)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/bernoulli.html#Bernoulli.expand)`has_enumerate_support` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/bernoulli.html#Bernoulli.log_prob)`logits`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/bernoulli.html#Bernoulli.logits)`mean``param_shape``probs`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/bernoulli.html#Bernoulli.probs)`sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/bernoulli.html#Bernoulli.sample)`support` *= BOOLEAN()*`variance`

## Beta

- *CLASS*`torch.distributions.beta.``Beta`(*concentration1*, *concentration0*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/beta.html#Beta)

  Bases: [`torch.distributions.exp_family.ExponentialFamily`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.exp_family.ExponentialFamily)Beta distribution parameterized by [`concentration1`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.beta.Beta.concentration1) and [`concentration0`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.beta.Beta.concentration0).Example:`>>> m = Beta(torch.tensor([0.5]), torch.tensor([0.5])) >>> m.sample()  # Beta distributed with concentration concentration1 and concentration0 tensor([ 0.1046]) `Parameters**concentration1** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – 1st concentration parameter of the distribution (often referred to as alpha)**concentration0** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – 2nd concentration parameter of the distribution (often referred to as beta)`arg_constraints` *= {'CONCENTRATION0': GREATERTHAN(LOWER_BOUND=0.0), 'CONCENTRATION1': GREATERTHAN(LOWER_BOUND=0.0)}*`concentration0``concentration1``entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/beta.html#Beta.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/beta.html#Beta.expand)`has_rsample` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/beta.html#Beta.log_prob)`mean``rsample`(*sample_shape=()*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/beta.html#Beta.rsample)`support` *= INTERVAL(LOWER_BOUND=0.0, UPPER_BOUND=1.0)*`variance`

## Binomial

- *CLASS*`torch.distributions.binomial.``Binomial`(*total_count=1*, *probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/binomial.html#Binomial)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a Binomial distribution parameterized by `total_count` and either [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.binomial.Binomial.probs) or [`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.binomial.Binomial.logits) (but not both). `total_count` must be broadcastable with [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.binomial.Binomial.probs)/[`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.binomial.Binomial.logits).Example:`>>> m = Binomial(100, torch.tensor([0 , .2, .8, 1])) >>> x = m.sample() tensor([   0.,   22.,   71.,  100.])  >>> m = Binomial(torch.tensor([[5.], [10.]]), torch.tensor([0.5, 0.8])) >>> x = m.sample() tensor([[ 4.,  5.],         [ 7.,  6.]]) `Parameters**total_count** ([*int*](https://docs.python.org/3/library/functions.html#int) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – number of Bernoulli trials**probs** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Event probabilities**logits** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Event log-odds`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': INTERVAL(LOWER_BOUND=0.0, UPPER_BOUND=1.0), 'TOTAL_COUNT': INTEGERGREATERTHAN(LOWER_BOUND=0)}*`enumerate_support`(*expand=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/binomial.html#Binomial.enumerate_support)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/binomial.html#Binomial.expand)`has_enumerate_support` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/binomial.html#Binomial.log_prob)`logits`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/binomial.html#Binomial.logits)`mean``param_shape``probs`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/binomial.html#Binomial.probs)`sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/binomial.html#Binomial.sample)`support``variance`

## Categorical

- *CLASS*`torch.distributions.categorical.``Categorical`(*probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/categorical.html#Categorical)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a categorical distribution parameterized by either [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.categorical.Categorical.probs) or [`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.categorical.Categorical.logits) (but not both).NOTEIt is equivalent to the distribution that [`torch.multinomial()`](https://pytorch.org/docs/stable/torch.html#torch.multinomial) samples from.Samples are integers from \{0, \ldots, K-1\}{0,…,K−1} where K is `probs.size(-1)`.If [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.categorical.Categorical.probs) is 1D with length-K, each element is the relative probability of sampling the class at that index.If [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.categorical.Categorical.probs) is 2D, it is treated as a batch of relative probability vectors.NOTE[`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.categorical.Categorical.probs) must be non-negative, finite and have a non-zero sum, and it will be normalized to sum to 1.See also: [`torch.multinomial()`](https://pytorch.org/docs/stable/torch.html#torch.multinomial)Example:`>>> m = Categorical(torch.tensor([ 0.25, 0.25, 0.25, 0.25 ])) >>> m.sample()  # equal probability of 0, 1, 2, 3 tensor(3) `Parameters**probs** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – event probabilities**logits** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – event log probabilities`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': SIMPLEX()}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/categorical.html#Categorical.entropy)`enumerate_support`(*expand=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/categorical.html#Categorical.enumerate_support)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/categorical.html#Categorical.expand)`has_enumerate_support` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/categorical.html#Categorical.log_prob)`logits`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/categorical.html#Categorical.logits)`mean``param_shape``probs`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/categorical.html#Categorical.probs)`sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/categorical.html#Categorical.sample)`support``variance`

## Cauchy

- *CLASS*`torch.distributions.cauchy.``Cauchy`(*loc*, *scale*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/cauchy.html#Cauchy)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Samples from a Cauchy (Lorentz) distribution. The distribution of the ratio of independent normally distributed random variables with means 0 follows a Cauchy distribution.Example:`>>> m = Cauchy(torch.tensor([0.0]), torch.tensor([1.0])) >>> m.sample()  # sample from a Cauchy distribution with loc=0 and scale=1 tensor([ 2.3214]) `Parameters**loc** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – mode or median of the distribution.**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – half width at half maximum.`arg_constraints` *= {'LOC': REAL(), 'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`cdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/cauchy.html#Cauchy.cdf)`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/cauchy.html#Cauchy.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/cauchy.html#Cauchy.expand)`has_rsample` *= TRUE*`icdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/cauchy.html#Cauchy.icdf)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/cauchy.html#Cauchy.log_prob)`mean``rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/cauchy.html#Cauchy.rsample)`support` *= REAL()*`variance`

## Chi2

- *CLASS*`torch.distributions.chi2.``Chi2`(*df*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/chi2.html#Chi2)

  Bases: [`torch.distributions.gamma.Gamma`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.gamma.Gamma)Creates a Chi2 distribution parameterized by shape parameter [`df`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.chi2.Chi2.df). This is exactly equivalent to `Gamma(alpha=0.5*df, beta=0.5)`Example:`>>> m = Chi2(torch.tensor([1.0])) >>> m.sample()  # Chi2 distributed with shape df=1 tensor([ 0.1046]) `Parameters**df** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – shape parameter of the distribution`arg_constraints` *= {'DF': GREATERTHAN(LOWER_BOUND=0.0)}*`df``expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/chi2.html#Chi2.expand)

## Dirichlet

- *CLASS*`torch.distributions.dirichlet.``Dirichlet`(*concentration*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/dirichlet.html#Dirichlet)

  Bases: [`torch.distributions.exp_family.ExponentialFamily`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.exp_family.ExponentialFamily)Creates a Dirichlet distribution parameterized by concentration `concentration`.Example:`>>> m = Dirichlet(torch.tensor([0.5, 0.5])) >>> m.sample()  # Dirichlet distributed with concentrarion concentration tensor([ 0.1046,  0.8954]) `Parameters**concentration** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – concentration parameter of the distribution (often referred to as alpha)`arg_constraints` *= {'CONCENTRATION': GREATERTHAN(LOWER_BOUND=0.0)}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/dirichlet.html#Dirichlet.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/dirichlet.html#Dirichlet.expand)`has_rsample` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/dirichlet.html#Dirichlet.log_prob)`mean``rsample`(*sample_shape=()*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/dirichlet.html#Dirichlet.rsample)`support` *= SIMPLEX()*`variance`

## Exponential

- *CLASS*`torch.distributions.exponential.``Exponential`(*rate*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/exponential.html#Exponential)

  Bases: [`torch.distributions.exp_family.ExponentialFamily`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.exp_family.ExponentialFamily)Creates a Exponential distribution parameterized by `rate`.Example:`>>> m = Exponential(torch.tensor([1.0])) >>> m.sample()  # Exponential distributed with rate=1 tensor([ 0.1046]) `Parameters**rate** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – rate = 1 / scale of the distribution`arg_constraints` *= {'RATE': GREATERTHAN(LOWER_BOUND=0.0)}*`cdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/exponential.html#Exponential.cdf)`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/exponential.html#Exponential.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/exponential.html#Exponential.expand)`has_rsample` *= TRUE*`icdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/exponential.html#Exponential.icdf)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/exponential.html#Exponential.log_prob)`mean``rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/exponential.html#Exponential.rsample)`stddev``support` *= GREATERTHAN(LOWER_BOUND=0.0)*`variance`

## FisherSnedecor

- *CLASS*`torch.distributions.fishersnedecor.``FisherSnedecor`(*df1*, *df2*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/fishersnedecor.html#FisherSnedecor)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a Fisher-Snedecor distribution parameterized by `df1` and `df2`.Example:`>>> m = FisherSnedecor(torch.tensor([1.0]), torch.tensor([2.0])) >>> m.sample()  # Fisher-Snedecor-distributed with df1=1 and df2=2 tensor([ 0.2453]) `Parameters**df1** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – degrees of freedom parameter 1**df2** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – degrees of freedom parameter 2`arg_constraints` *= {'DF1': GREATERTHAN(LOWER_BOUND=0.0), 'DF2': GREATERTHAN(LOWER_BOUND=0.0)}*`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/fishersnedecor.html#FisherSnedecor.expand)`has_rsample` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/fishersnedecor.html#FisherSnedecor.log_prob)`mean``rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/fishersnedecor.html#FisherSnedecor.rsample)`support` *= GREATERTHAN(LOWER_BOUND=0.0)*`variance`

## Gamma

- *CLASS*`torch.distributions.gamma.``Gamma`(*concentration*, *rate*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/gamma.html#Gamma)

  Bases: [`torch.distributions.exp_family.ExponentialFamily`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.exp_family.ExponentialFamily)Creates a Gamma distribution parameterized by shape `concentration` and `rate`.Example:`>>> m = Gamma(torch.tensor([1.0]), torch.tensor([1.0])) >>> m.sample()  # Gamma distributed with concentration=1 and rate=1 tensor([ 0.1046]) `Parameters**concentration** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – shape parameter of the distribution (often referred to as alpha)**rate** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – rate = 1 / scale of the distribution (often referred to as beta)`arg_constraints` *= {'CONCENTRATION': GREATERTHAN(LOWER_BOUND=0.0), 'RATE': GREATERTHAN(LOWER_BOUND=0.0)}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/gamma.html#Gamma.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/gamma.html#Gamma.expand)`has_rsample` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/gamma.html#Gamma.log_prob)`mean``rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/gamma.html#Gamma.rsample)`support` *= GREATERTHAN(LOWER_BOUND=0.0)*`variance`

## Geometric

- *CLASS*`torch.distributions.geometric.``Geometric`(*probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/geometric.html#Geometric)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a Geometric distribution parameterized by [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.geometric.Geometric.probs), where [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.geometric.Geometric.probs) is the probability of success of Bernoulli trials. It represents the probability that in k + 1k+1 Bernoulli trials, the first kktrials failed, before seeing a success.Samples are non-negative integers [0, \infinf).Example:`>>> m = Geometric(torch.tensor([0.3])) >>> m.sample()  # underlying Bernoulli has 30% chance 1; 70% chance 0 tensor([ 2.]) `Parameters**probs** (*Number**,* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the probability of sampling 1. Must be in range (0, 1]**logits** (*Number**,* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the log-odds of sampling 1.`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': INTERVAL(LOWER_BOUND=0.0, UPPER_BOUND=1.0)}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/geometric.html#Geometric.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/geometric.html#Geometric.expand)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/geometric.html#Geometric.log_prob)`logits`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/geometric.html#Geometric.logits)`mean``probs`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/geometric.html#Geometric.probs)`sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/geometric.html#Geometric.sample)`support` *= INTEGERGREATERTHAN(LOWER_BOUND=0)*`variance`

## Gumbel

- *CLASS*`torch.distributions.gumbel.``Gumbel`(*loc*, *scale*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/gumbel.html#Gumbel)

  Bases: [`torch.distributions.transformed_distribution.TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution)Samples from a Gumbel Distribution.Examples:`>>> m = Gumbel(torch.tensor([1.0]), torch.tensor([2.0])) >>> m.sample()  # sample from Gumbel distribution with loc=1, scale=2 tensor([ 1.0124]) `Parameters**loc** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Location parameter of the distribution**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Scale parameter of the distribution`arg_constraints` *= {'LOC': REAL(), 'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/gumbel.html#Gumbel.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/gumbel.html#Gumbel.expand)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/gumbel.html#Gumbel.log_prob)`mean``stddev``support` *= REAL()*`variance`

## HalfCauchy

- *CLASS*`torch.distributions.half_cauchy.``HalfCauchy`(*scale*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_cauchy.html#HalfCauchy)

  Bases: [`torch.distributions.transformed_distribution.TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution)Creates a half-normal distribution parameterized by scale where:`X ~ Cauchy(0, scale) Y = |X| ~ HalfCauchy(scale) `Example:`>>> m = HalfCauchy(torch.tensor([1.0])) >>> m.sample()  # half-cauchy distributed with scale=1 tensor([ 2.3214]) `Parameters**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – scale of the full Cauchy distribution`arg_constraints` *= {'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`cdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_cauchy.html#HalfCauchy.cdf)`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_cauchy.html#HalfCauchy.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_cauchy.html#HalfCauchy.expand)`has_rsample` *= TRUE*`icdf`(*prob*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_cauchy.html#HalfCauchy.icdf)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_cauchy.html#HalfCauchy.log_prob)`mean``scale``support` *= GREATERTHAN(LOWER_BOUND=0.0)*`variance`

## HalfNormal

- *CLASS*`torch.distributions.half_normal.``HalfNormal`(*scale*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_normal.html#HalfNormal)

  Bases: [`torch.distributions.transformed_distribution.TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution)Creates a half-normal distribution parameterized by scale where:`X ~ Normal(0, scale) Y = |X| ~ HalfNormal(scale) `Example:`>>> m = HalfNormal(torch.tensor([1.0])) >>> m.sample()  # half-normal distributed with scale=1 tensor([ 0.1046]) `Parameters**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – scale of the full Normal distribution`arg_constraints` *= {'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`cdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_normal.html#HalfNormal.cdf)`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_normal.html#HalfNormal.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_normal.html#HalfNormal.expand)`has_rsample` *= TRUE*`icdf`(*prob*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_normal.html#HalfNormal.icdf)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/half_normal.html#HalfNormal.log_prob)`mean``scale``support` *= GREATERTHAN(LOWER_BOUND=0.0)*`variance`

## Independent

- *CLASS*`torch.distributions.independent.``Independent`(*base_distribution*, *reinterpreted_batch_ndims*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/independent.html#Independent)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Reinterprets some of the batch dims of a distribution as event dims.This is mainly useful for changing the shape of the result of [`log_prob()`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.independent.Independent.log_prob). For example to create a diagonal Normal distribution with the same shape as a Multivariate Normal distribution (so they are interchangeable), you can:`>>> loc = torch.zeros(3) >>> scale = torch.ones(3) >>> mvn = MultivariateNormal(loc, scale_tril=torch.diag(scale)) >>> [mvn.batch_shape, mvn.event_shape] [torch.Size(()), torch.Size((3,))] >>> normal = Normal(loc, scale) >>> [normal.batch_shape, normal.event_shape] [torch.Size((3,)), torch.Size(())] >>> diagn = Independent(normal, 1) >>> [diagn.batch_shape, diagn.event_shape] [torch.Size(()), torch.Size((3,))] `Parameters**base_distribution** ([*torch.distributions.distribution.Distribution*](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)) – a base distribution**reinterpreted_batch_ndims** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the number of batch dims to reinterpret as event dims`arg_constraints` *= {}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/independent.html#Independent.entropy)`enumerate_support`(*expand=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/independent.html#Independent.enumerate_support)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/independent.html#Independent.expand)`has_enumerate_support``has_rsample``log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/independent.html#Independent.log_prob)`mean``rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/independent.html#Independent.rsample)`sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/independent.html#Independent.sample)`support``variance`

## Laplace

- *CLASS*`torch.distributions.laplace.``Laplace`(*loc*, *scale*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/laplace.html#Laplace)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a Laplace distribution parameterized by `loc` and :attr:’scale’.Example:`>>> m = Laplace(torch.tensor([0.0]), torch.tensor([1.0])) >>> m.sample()  # Laplace distributed with loc=0, scale=1 tensor([ 0.1046]) `Parameters**loc** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – mean of the distribution**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – scale of the distribution`arg_constraints` *= {'LOC': REAL(), 'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`cdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/laplace.html#Laplace.cdf)`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/laplace.html#Laplace.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/laplace.html#Laplace.expand)`has_rsample` *= TRUE*`icdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/laplace.html#Laplace.icdf)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/laplace.html#Laplace.log_prob)`mean``rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/laplace.html#Laplace.rsample)`stddev``support` *= REAL()*`variance`

## LogNormal

- *CLASS*`torch.distributions.log_normal.``LogNormal`(*loc*, *scale*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/log_normal.html#LogNormal)

  Bases: [`torch.distributions.transformed_distribution.TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution)Creates a log-normal distribution parameterized by [`loc`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.log_normal.LogNormal.loc) and [`scale`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.log_normal.LogNormal.scale) where:`X ~ Normal(loc, scale) Y = exp(X) ~ LogNormal(loc, scale) `Example:`>>> m = LogNormal(torch.tensor([0.0]), torch.tensor([1.0])) >>> m.sample()  # log-normal distributed with mean=0 and stddev=1 tensor([ 0.1046]) `Parameters**loc** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – mean of log of distribution**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – standard deviation of log of the distribution`arg_constraints` *= {'LOC': REAL(), 'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/log_normal.html#LogNormal.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/log_normal.html#LogNormal.expand)`has_rsample` *= TRUE*`loc``mean``scale``support` *= GREATERTHAN(LOWER_BOUND=0.0)*`variance`

## LowRankMultivariateNormal

- *CLASS*`torch.distributions.lowrank_multivariate_normal.``LowRankMultivariateNormal`(*loc*, *cov_factor*, *cov_diag*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/lowrank_multivariate_normal.html#LowRankMultivariateNormal)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a multivariate normal distribution with covariance matrix having a low-rank form parameterized by `cov_factor` and `cov_diag`:`covariance_matrix = cov_factor @ cov_factor.T + cov_diag `Example`>>> m = LowRankMultivariateNormal(torch.zeros(2), torch.tensor([1, 0]), torch.tensor([1, 1])) >>> m.sample()  # normally distributed with mean=`[0,0]`, cov_factor=`[1,0]`, cov_diag=`[1,1]` tensor([-0.2102, -0.5429]) `Parameters**loc** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – mean of the distribution with shape batch_shape + event_shape**cov_factor** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – factor part of low-rank form of covariance matrix with shapebatch_shape + event_shape + (rank,)**cov_diag** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – diagonal part of low-rank form of covariance matrix with shapebatch_shape + event_shapeNOTEThe computation for determinant and inverse of covariance matrix is avoided whencov_factor.shape[1] << cov_factor.shape[0] thanks to [Woodbury matrix identity](https://en.wikipedia.org/wiki/Woodbury_matrix_identity) and [matrix determinant lemma](https://en.wikipedia.org/wiki/Matrix_determinant_lemma). Thanks to these formulas, we just need to compute the determinant and inverse of the small size “capacitance” matrix:`capacitance = I + cov_factor.T @ inv(cov_diag) @ cov_factor ``arg_constraints` *= {'COV_DIAG': GREATERTHAN(LOWER_BOUND=0.0), 'COV_FACTOR': REAL(), 'LOC': REAL()}*`covariance_matrix`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/lowrank_multivariate_normal.html#LowRankMultivariateNormal.covariance_matrix)`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/lowrank_multivariate_normal.html#LowRankMultivariateNormal.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/lowrank_multivariate_normal.html#LowRankMultivariateNormal.expand)`has_rsample` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/lowrank_multivariate_normal.html#LowRankMultivariateNormal.log_prob)`mean``precision_matrix`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/lowrank_multivariate_normal.html#LowRankMultivariateNormal.precision_matrix)`rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/lowrank_multivariate_normal.html#LowRankMultivariateNormal.rsample)`scale_tril`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/lowrank_multivariate_normal.html#LowRankMultivariateNormal.scale_tril)`support` *= REAL()*`variance`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/lowrank_multivariate_normal.html#LowRankMultivariateNormal.variance)

## Multinomial

- *CLASS*`torch.distributions.multinomial.``Multinomial`(*total_count=1*, *probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multinomial.html#Multinomial)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a Multinomial distribution parameterized by `total_count` and either [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multinomial.Multinomial.probs) or [`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multinomial.Multinomial.logits) (but not both). The innermost dimension of [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multinomial.Multinomial.probs) indexes over categories. All other dimensions index over batches.Note that `total_count` need not be specified if only [`log_prob()`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multinomial.Multinomial.log_prob) is called (see example below)NOTE[`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multinomial.Multinomial.probs) must be non-negative, finite and have a non-zero sum, and it will be normalized to sum to 1.[`sample()`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multinomial.Multinomial.sample) requires a single shared total_count for all parameters and samples.[`log_prob()`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multinomial.Multinomial.log_prob) allows different total_count for each parameter and sample.Example:`>>> m = Multinomial(100, torch.tensor([ 1., 1., 1., 1.])) >>> x = m.sample()  # equal probability of 0, 1, 2, 3 tensor([ 21.,  24.,  30.,  25.])  >>> Multinomial(probs=torch.tensor([1., 1., 1., 1.])).log_prob(x) tensor([-4.1338]) `Parameters**total_count** ([*int*](https://docs.python.org/3/library/functions.html#int)) – number of trials**probs** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – event probabilities**logits** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – event log probabilities`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': SIMPLEX()}*`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multinomial.html#Multinomial.expand)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multinomial.html#Multinomial.log_prob)`logits``mean``param_shape``probs``sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multinomial.html#Multinomial.sample)`support``variance`

## MultivariateNormal

- *CLASS*`torch.distributions.multivariate_normal.``MultivariateNormal`(*loc*, *covariance_matrix=None*, *precision_matrix=None*, *scale_tril=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multivariate_normal.html#MultivariateNormal)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a multivariate normal (also called Gaussian) distribution parameterized by a mean vector and a covariance matrix.The multivariate normal distribution can be parameterized either in terms of a positive definite covariance matrix \mathbf{\Sigma}Σ or a positive definite precision matrix \mathbf{\Sigma}^{-1}Σ−1 or a lower-triangular matrix \mathbf{L}L with positive-valued diagonal entries, such that \mathbf{\Sigma} = \mathbf{L}\mathbf{L}^\topΣ=LL⊤. This triangular matrix can be obtained via e.g. Cholesky decomposition of the covariance.Example`>>> m = MultivariateNormal(torch.zeros(2), torch.eye(2)) >>> m.sample()  # normally distributed with mean=`[0,0]` and covariance_matrix=`I` tensor([-0.2102, -0.5429]) `Parameters**loc** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – mean of the distribution**covariance_matrix** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – positive-definite covariance matrix**precision_matrix** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – positive-definite precision matrix**scale_tril** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – lower-triangular factor of covariance, with positive-valued diagonalNOTEOnly one of [`covariance_matrix`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multivariate_normal.MultivariateNormal.covariance_matrix) or [`precision_matrix`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multivariate_normal.MultivariateNormal.precision_matrix) or [`scale_tril`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multivariate_normal.MultivariateNormal.scale_tril) can be specified.Using [`scale_tril`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multivariate_normal.MultivariateNormal.scale_tril) will be more efficient: all computations internally are based on [`scale_tril`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multivariate_normal.MultivariateNormal.scale_tril). If [`covariance_matrix`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multivariate_normal.MultivariateNormal.covariance_matrix) or [`precision_matrix`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.multivariate_normal.MultivariateNormal.precision_matrix) is passed instead, it is only used to compute the corresponding lower triangular matrices using a Cholesky decomposition.`arg_constraints` *= {'COVARIANCE_MATRIX': POSITIVEDEFINITE(), 'LOC': REALVECTOR(), 'PRECISION_MATRIX': POSITIVEDEFINITE(), 'SCALE_TRIL': LOWERCHOLESKY()}*`covariance_matrix`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multivariate_normal.html#MultivariateNormal.covariance_matrix)`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multivariate_normal.html#MultivariateNormal.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multivariate_normal.html#MultivariateNormal.expand)`has_rsample` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multivariate_normal.html#MultivariateNormal.log_prob)`mean``precision_matrix`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multivariate_normal.html#MultivariateNormal.precision_matrix)`rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multivariate_normal.html#MultivariateNormal.rsample)`scale_tril`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/multivariate_normal.html#MultivariateNormal.scale_tril)`support` *= REAL()*`variance`

## NegativeBinomial

- *CLASS*`torch.distributions.negative_binomial.``NegativeBinomial`(*total_count*, *probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/negative_binomial.html#NegativeBinomial)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a Negative Binomial distribution, i.e. distribution of the number of independent identical Bernoulli trials needed before `total_count` failures are achieved. The probability of success of each Bernoulli trial is [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.negative_binomial.NegativeBinomial.probs).Parameters**total_count** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – non-negative number of negative Bernoulli trials to stop, although the distribution is still valid for real valued count**probs** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Event probabilities of success in the half open interval [0, 1)**logits** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Event log-odds for probabilities of success`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': HALFOPENINTERVAL(LOWER_BOUND=0.0, UPPER_BOUND=1.0), 'TOTAL_COUNT': GREATERTHANEQ(LOWER_BOUND=0)}*`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/negative_binomial.html#NegativeBinomial.expand)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/negative_binomial.html#NegativeBinomial.log_prob)`logits`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/negative_binomial.html#NegativeBinomial.logits)`mean``param_shape``probs`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/negative_binomial.html#NegativeBinomial.probs)`sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/negative_binomial.html#NegativeBinomial.sample)`support` *= INTEGERGREATERTHAN(LOWER_BOUND=0)*`variance`

## Normal

- *CLASS*`torch.distributions.normal.``Normal`(*loc*, *scale*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/normal.html#Normal)

  Bases: [`torch.distributions.exp_family.ExponentialFamily`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.exp_family.ExponentialFamily)Creates a normal (also called Gaussian) distribution parameterized by `loc` and `scale`.Example:`>>> m = Normal(torch.tensor([0.0]), torch.tensor([1.0])) >>> m.sample()  # normally distributed with loc=0 and scale=1 tensor([ 0.1046]) `Parameters**loc** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – mean of the distribution (often referred to as mu)**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – standard deviation of the distribution (often referred to as sigma)`arg_constraints` *= {'LOC': REAL(), 'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`cdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/normal.html#Normal.cdf)`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/normal.html#Normal.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/normal.html#Normal.expand)`has_rsample` *= TRUE*`icdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/normal.html#Normal.icdf)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/normal.html#Normal.log_prob)`mean``rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/normal.html#Normal.rsample)`sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/normal.html#Normal.sample)`stddev``support` *= REAL()*`variance`

## OneHotCategorical

- *CLASS*`torch.distributions.one_hot_categorical.``OneHotCategorical`(*probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/one_hot_categorical.html#OneHotCategorical)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a one-hot categorical distribution parameterized by [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.one_hot_categorical.OneHotCategorical.probs) or [`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.one_hot_categorical.OneHotCategorical.logits).Samples are one-hot coded vectors of size `probs.size(-1)`.NOTE[`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.one_hot_categorical.OneHotCategorical.probs) must be non-negative, finite and have a non-zero sum, and it will be normalized to sum to 1.See also: `torch.distributions.Categorical()` for specifications of [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.one_hot_categorical.OneHotCategorical.probs) and [`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.one_hot_categorical.OneHotCategorical.logits).Example:`>>> m = OneHotCategorical(torch.tensor([ 0.25, 0.25, 0.25, 0.25 ])) >>> m.sample()  # equal probability of 0, 1, 2, 3 tensor([ 0.,  0.,  0.,  1.]) `Parameters**probs** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – event probabilities**logits** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – event log probabilities`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': SIMPLEX()}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/one_hot_categorical.html#OneHotCategorical.entropy)`enumerate_support`(*expand=True*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/one_hot_categorical.html#OneHotCategorical.enumerate_support)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/one_hot_categorical.html#OneHotCategorical.expand)`has_enumerate_support` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/one_hot_categorical.html#OneHotCategorical.log_prob)`logits``mean``param_shape``probs``sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/one_hot_categorical.html#OneHotCategorical.sample)`support` *= SIMPLEX()*`variance`

## Pareto

- *CLASS*`torch.distributions.pareto.``Pareto`(*scale*, *alpha*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/pareto.html#Pareto)

  Bases: [`torch.distributions.transformed_distribution.TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution)Samples from a Pareto Type 1 distribution.Example:`>>> m = Pareto(torch.tensor([1.0]), torch.tensor([1.0])) >>> m.sample()  # sample from a Pareto distribution with scale=1 and alpha=1 tensor([ 1.5623]) `Parameters**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Scale parameter of the distribution**alpha** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Shape parameter of the distribution`arg_constraints` *= {'ALPHA': GREATERTHAN(LOWER_BOUND=0.0), 'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/pareto.html#Pareto.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/pareto.html#Pareto.expand)`mean``support``variance`

## Poisson

- *CLASS*`torch.distributions.poisson.``Poisson`(*rate*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/poisson.html#Poisson)

  Bases: [`torch.distributions.exp_family.ExponentialFamily`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.exp_family.ExponentialFamily)Creates a Poisson distribution parameterized by `rate`, the rate parameter.Samples are nonnegative integers, with a pmf given by\mathrm{rate}^k \frac{e^{-\mathrm{rate}}}{k!}ratekk!e−rateExample:`>>> m = Poisson(torch.tensor([4])) >>> m.sample() tensor([ 3.]) `Parameters**rate** (*Number**,* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the rate parameter`arg_constraints` *= {'RATE': GREATERTHAN(LOWER_BOUND=0.0)}*`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/poisson.html#Poisson.expand)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/poisson.html#Poisson.log_prob)`mean``sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/poisson.html#Poisson.sample)`support` *= INTEGERGREATERTHAN(LOWER_BOUND=0)*`variance`

## RelaxedBernoulli

- *CLASS*`torch.distributions.relaxed_bernoulli.``RelaxedBernoulli`(*temperature*, *probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_bernoulli.html#RelaxedBernoulli)

  Bases: [`torch.distributions.transformed_distribution.TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution)Creates a RelaxedBernoulli distribution, parametrized by [`temperature`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_bernoulli.RelaxedBernoulli.temperature), and either [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_bernoulli.RelaxedBernoulli.probs) or [`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_bernoulli.RelaxedBernoulli.logits)(but not both). This is a relaxed version of the Bernoulli distribution, so the values are in (0, 1), and has reparametrizable samples.Example:`>>> m = RelaxedBernoulli(torch.tensor([2.2]),                          torch.tensor([0.1, 0.2, 0.3, 0.99])) >>> m.sample() tensor([ 0.2951,  0.3442,  0.8918,  0.9021]) `Parameters**temperature** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – relaxation temperature**probs** (*Number**,* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the probability of sampling 1**logits** (*Number**,* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the log-odds of sampling 1`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': INTERVAL(LOWER_BOUND=0.0, UPPER_BOUND=1.0)}*`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_bernoulli.html#RelaxedBernoulli.expand)`has_rsample` *= TRUE*`logits``probs``support` *= INTERVAL(LOWER_BOUND=0.0, UPPER_BOUND=1.0)*`temperature`

## LogitRelaxedBernoulli

- *CLASS*`torch.distributions.relaxed_bernoulli.``LogitRelaxedBernoulli`(*temperature*, *probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_bernoulli.html#LogitRelaxedBernoulli)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a LogitRelaxedBernoulli distribution parameterized by [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_bernoulli.LogitRelaxedBernoulli.probs) or [`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_bernoulli.LogitRelaxedBernoulli.logits) (but not both), which is the logit of a RelaxedBernoulli distribution.Samples are logits of values in (0, 1). See [1] for more details.Parameters**temperature** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – relaxation temperature**probs** (*Number**,* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the probability of sampling 1**logits** (*Number**,* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the log-odds of sampling 1[1] The Concrete Distribution: A Continuous Relaxation of Discrete Random Variables (Maddison et al, 2017)[2] Categorical Reparametrization with Gumbel-Softmax (Jang et al, 2017)`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': INTERVAL(LOWER_BOUND=0.0, UPPER_BOUND=1.0)}*`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_bernoulli.html#LogitRelaxedBernoulli.expand)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_bernoulli.html#LogitRelaxedBernoulli.log_prob)`logits`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_bernoulli.html#LogitRelaxedBernoulli.logits)`param_shape``probs`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_bernoulli.html#LogitRelaxedBernoulli.probs)`rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_bernoulli.html#LogitRelaxedBernoulli.rsample)`support` *= REAL()*

## RelaxedOneHotCategorical

- *CLASS*`torch.distributions.relaxed_categorical.``RelaxedOneHotCategorical`(*temperature*, *probs=None*, *logits=None*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_categorical.html#RelaxedOneHotCategorical)

  Bases: [`torch.distributions.transformed_distribution.TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution)Creates a RelaxedOneHotCategorical distribution parametrized by [`temperature`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_categorical.RelaxedOneHotCategorical.temperature), and either [`probs`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_categorical.RelaxedOneHotCategorical.probs)or [`logits`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_categorical.RelaxedOneHotCategorical.logits). This is a relaxed version of the `OneHotCategorical` distribution, so its samples are on simplex, and are reparametrizable.Example:`>>> m = RelaxedOneHotCategorical(torch.tensor([2.2]),                                  torch.tensor([0.1, 0.2, 0.3, 0.4])) >>> m.sample() tensor([ 0.1294,  0.2324,  0.3859,  0.2523]) `Parameters**temperature** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – relaxation temperature**probs** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – event probabilities**logits** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – the log probability of each event.`arg_constraints` *= {'LOGITS': REAL(), 'PROBS': SIMPLEX()}*`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/relaxed_categorical.html#RelaxedOneHotCategorical.expand)`has_rsample` *= TRUE*`logits``probs``support` *= SIMPLEX()*`temperature`

## StudentT

- *CLASS*`torch.distributions.studentT.``StudentT`(*df*, *loc=0.0*, *scale=1.0*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/studentT.html#StudentT)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Creates a Student’s t-distribution parameterized by degree of freedom `df`, mean `loc` and scale `scale`.Example:`>>> m = StudentT(torch.tensor([2.0])) >>> m.sample()  # Student's t-distributed with degrees of freedom=2 tensor([ 0.1046]) `Parameters**df** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – degrees of freedom**loc** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – mean of the distribution**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – scale of the distribution`arg_constraints` *= {'DF': GREATERTHAN(LOWER_BOUND=0.0), 'LOC': REAL(), 'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/studentT.html#StudentT.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/studentT.html#StudentT.expand)`has_rsample` *= TRUE*`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/studentT.html#StudentT.log_prob)`mean``rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/studentT.html#StudentT.rsample)`support` *= REAL()*`variance`

## TransformedDistribution

- *CLASS*`torch.distributions.transformed_distribution.``TransformedDistribution`(*base_distribution*, *transforms*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transformed_distribution.html#TransformedDistribution)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Extension of the Distribution class, which applies a sequence of Transforms to a base distribution. Let f be the composition of transforms applied:`X ~ BaseDistribution Y = f(X) ~ TransformedDistribution(BaseDistribution, f) log p(Y) = log p(X) + log |det (dX/dY)| `Note that the `.event_shape` of a [`TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution) is the maximum shape of its base distribution and its transforms, since transforms can introduce correlations among events.An example for the usage of [`TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution) would be:`# Building a Logistic Distribution # X ~ Uniform(0, 1) # f = a + b * logit(X) # Y ~ f(X) ~ Logistic(a, b) base_distribution = Uniform(0, 1) transforms = [SigmoidTransform().inv, AffineTransform(loc=a, scale=b)] logistic = TransformedDistribution(base_distribution, transforms) `For more examples, please look at the implementations of [`Gumbel`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.gumbel.Gumbel), [`HalfCauchy`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.half_cauchy.HalfCauchy), [`HalfNormal`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.half_normal.HalfNormal),[`LogNormal`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.log_normal.LogNormal), [`Pareto`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.pareto.Pareto), [`Weibull`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.weibull.Weibull), [`RelaxedBernoulli`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_bernoulli.RelaxedBernoulli) and [`RelaxedOneHotCategorical`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.relaxed_categorical.RelaxedOneHotCategorical)`arg_constraints` *= {}*`cdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transformed_distribution.html#TransformedDistribution.cdf)Computes the cumulative distribution function by inverting the transform(s) and computing the score of the base distribution.`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transformed_distribution.html#TransformedDistribution.expand)`has_rsample``icdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transformed_distribution.html#TransformedDistribution.icdf)Computes the inverse cumulative distribution function using transform(s) and computing the score of the base distribution.`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transformed_distribution.html#TransformedDistribution.log_prob)Scores the sample by inverting the transform(s) and computing the score using the score of the base distribution and the log abs det jacobian.`rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transformed_distribution.html#TransformedDistribution.rsample)Generates a sample_shape shaped reparameterized sample or sample_shape shaped batch of reparameterized samples if the distribution parameters are batched. Samples first from base distribution and applies transform() for every transform in the list.`sample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transformed_distribution.html#TransformedDistribution.sample)Generates a sample_shape shaped sample or sample_shape shaped batch of samples if the distribution parameters are batched. Samples first from base distribution and applies transform() for every transform in the list.`support`

## Uniform

- *CLASS*`torch.distributions.uniform.``Uniform`(*low*, *high*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/uniform.html#Uniform)

  Bases: [`torch.distributions.distribution.Distribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)Generates uniformly distributed random samples from the half-open interval `[low, high)`.Example:`>>> m = Uniform(torch.tensor([0.0]), torch.tensor([5.0])) >>> m.sample()  # uniformly distributed in the range [0.0, 5.0) tensor([ 2.3418]) `Parameters**low** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – lower range (inclusive).**high** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – upper range (exclusive).`arg_constraints` *= {'HIGH': DEPENDENT(), 'LOW': DEPENDENT()}*`cdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/uniform.html#Uniform.cdf)`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/uniform.html#Uniform.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/uniform.html#Uniform.expand)`has_rsample` *= TRUE*`icdf`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/uniform.html#Uniform.icdf)`log_prob`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/uniform.html#Uniform.log_prob)`mean``rsample`(*sample_shape=torch.Size([])*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/uniform.html#Uniform.rsample)`stddev``support``variance`

## Weibull

- *CLASS*`torch.distributions.weibull.``Weibull`(*scale*, *concentration*, *validate_args=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/weibull.html#Weibull)

  Bases: [`torch.distributions.transformed_distribution.TransformedDistribution`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transformed_distribution.TransformedDistribution)Samples from a two-parameter Weibull distribution.Example`>>> m = Weibull(torch.tensor([1.0]), torch.tensor([1.0])) >>> m.sample()  # sample from a Weibull distribution with scale=1, concentration=1 tensor([ 0.4784]) `Parameters**scale** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Scale parameter of distribution (lambda).**concentration** ([*float*](https://docs.python.org/3/library/functions.html#float) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – Concentration parameter of distribution (k/shape).`arg_constraints` *= {'CONCENTRATION': GREATERTHAN(LOWER_BOUND=0.0), 'SCALE': GREATERTHAN(LOWER_BOUND=0.0)}*`entropy`()[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/weibull.html#Weibull.entropy)`expand`(*batch_shape*, *_instance=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/weibull.html#Weibull.expand)`mean``support` *= GREATERTHAN(LOWER_BOUND=0.0)*`variance`



## KL Divergence

- `torch.distributions.kl.``kl_divergence`(*p*, *q*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/kl.html#kl_divergence)

  Compute Kullback-Leibler divergence KL(p \| q)KL(p∥q) between two distributions.KL(p \| q) = \int p(x) \log\frac {p(x)} {q(x)} \,dxKL(p∥q)=∫p(x)logq(x)p(x)dxParameters**p** ([*Distribution*](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)) – A `Distribution` object.**q** ([*Distribution*](https://pytorch.org/docs/stable/distributions.html#torch.distributions.distribution.Distribution)) – A `Distribution` object.ReturnsA batch of KL divergences of shape batch_shape.Return type[Tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)Raises[**NotImplementedError**](https://docs.python.org/3/library/exceptions.html#NotImplementedError) – If the distribution types have not been registered via[`register_kl()`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.kl.register_kl).

- `torch.distributions.kl.``register_kl`(*type_p*, *type_q*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/kl.html#register_kl)

  Decorator to register a pairwise function with [`kl_divergence()`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.kl.kl_divergence). Usage:`@register_kl(Normal, Normal) def kl_normal_normal(p, q):     # insert implementation here `Lookup returns the most specific (type,type) match ordered by subclass. If the match is ambiguous, a RuntimeWarning is raised. For example to resolve the ambiguous situation:`@register_kl(BaseP, DerivedQ) def kl_version1(p, q): ... @register_kl(DerivedP, BaseQ) def kl_version2(p, q): ... `you should register a third most-specific implementation, e.g.:`register_kl(DerivedP, DerivedQ)(kl_version1)  # Break the tie. `Parameters**type_p** ([*type*](https://docs.python.org/3/library/functions.html#type)) – A subclass of `Distribution`.**type_q** ([*type*](https://docs.python.org/3/library/functions.html#type)) – A subclass of `Distribution`.



## Transforms

- *CLASS*`torch.distributions.transforms.``Transform`(*cache_size=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#Transform)

  Abstract class for invertable transformations with computable log det jacobians. They are primarily used in `torch.distributions.TransformedDistribution`.Caching is useful for tranforms whose inverses are either expensive or numerically unstable. Note that care must be taken with memoized values since the autograd graph may be reversed. For example while the following works with or without caching:`y = t(x) t.log_abs_det_jacobian(x, y).backward()  # x will receive gradients. `However the following will error when caching due to dependency reversal:`y = t(x) z = t.inv(y) grad(z.sum(), [y])  # error because z is x `Derived classes should implement one or both of `_call()` or `_inverse()`. Derived classes that set bijective=True should also implement [`log_abs_det_jacobian()`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transforms.Transform.log_abs_det_jacobian).Parameters**cache_size** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Size of cache. If zero, no caching is done. If one, the latest single value is cached. Only 0 and 1 are supported.Variables**~Transform.domain** ([`Constraint`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraints.Constraint)) – The constraint representing valid inputs to this transform.**~Transform.codomain** ([`Constraint`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraints.Constraint)) – The constraint representing valid outputs to this transform which are inputs to the inverse transform.**~Transform.bijective** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – Whether this transform is bijective. A transform `t` is bijective iff `t.inv(t(x)) == x` and `t(t.inv(y)) == y` for every `x` in the domain and `y` in the codomain. Transforms that are not bijective should at least maintain the weaker pseudoinverse properties `t(t.inv(t(x)) == t(x)` and `t.inv(t(t.inv(y)))== t.inv(y)`.**~Transform.sign** ([*int*](https://docs.python.org/3/library/functions.html#int) *or* [*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)) – For bijective univariate transforms, this should be +1 or -1 depending on whether transform is monotone increasing or decreasing.**~Transform.event_dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Number of dimensions that are correlated together in the transform `event_shape`. This should be 0 for pointwise transforms, 1 for transforms that act jointly on vectors, 2 for transforms that act jointly on matrices, etc.`inv`Returns the inverse [`Transform`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transforms.Transform) of this transform. This should satisfy `t.inv.inv is t`.`sign`Returns the sign of the determinant of the Jacobian, if applicable. In general this only makes sense for bijective transforms.`log_abs_det_jacobian`(*x*, *y*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#Transform.log_abs_det_jacobian)Computes the log det jacobian log |dy/dx| given input and output.

- *CLASS*`torch.distributions.transforms.``ComposeTransform`(*parts*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#ComposeTransform)

  Composes multiple transforms in a chain. The transforms being composed are responsible for caching.Parameters**parts** (list of [`Transform`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transforms.Transform)) – A list of transforms to compose.

- *CLASS*`torch.distributions.transforms.``ExpTransform`(*cache_size=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#ExpTransform)

  Transform via the mapping y = \exp(x)y=exp(x).

- *CLASS*`torch.distributions.transforms.``PowerTransform`(*exponent*, *cache_size=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#PowerTransform)

  Transform via the mapping y = x^{\text{exponent}}y=xexponent.

- *CLASS*`torch.distributions.transforms.``SigmoidTransform`(*cache_size=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#SigmoidTransform)

  Transform via the mapping y = \frac{1}{1 + \exp(-x)}y=1+exp(−x)1 and x = \text{logit}(y)x=logit(y).

- *CLASS*`torch.distributions.transforms.``AbsTransform`(*cache_size=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#AbsTransform)

  Transform via the mapping y = |x|y=∣x∣.

- *CLASS*`torch.distributions.transforms.``AffineTransform`(*loc*, *scale*, *event_dim=0*, *cache_size=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#AffineTransform)

  Transform via the pointwise affine mapping y = \text{loc} + \text{scale} \times xy=loc+scale×x.Parameters**loc** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor) *or* [*float*](https://docs.python.org/3/library/functions.html#float)) – Location parameter.**scale** ([*Tensor*](https://pytorch.org/docs/stable/tensors.html#torch.Tensor) *or* [*float*](https://docs.python.org/3/library/functions.html#float)) – Scale parameter.**event_dim** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Optional size of event_shape. This should be zero for univariate random variables, 1 for distributions over vectors, 2 for distributions over matrices, etc.

- *CLASS*`torch.distributions.transforms.``SoftmaxTransform`(*cache_size=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#SoftmaxTransform)

  Transform from unconstrained space to the simplex via y = \exp(x)y=exp(x) then normalizing.This is not bijective and cannot be used for HMC. However this acts mostly coordinate-wise (except for the final normalization), and thus is appropriate for coordinate-wise optimization algorithms.

- *CLASS*`torch.distributions.transforms.``StickBreakingTransform`(*cache_size=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#StickBreakingTransform)

  Transform from unconstrained space to the simplex of one additional dimension via a stick-breaking process.This transform arises as an iterated sigmoid transform in a stick-breaking construction of the Dirichlet distribution: the first logit is transformed via sigmoid to the first probability and the probability of everything else, and then the process recurses.This is bijective and appropriate for use in HMC; however it mixes coordinates together and is less appropriate for optimization.

- *CLASS*`torch.distributions.transforms.``LowerCholeskyTransform`(*cache_size=0*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/transforms.html#LowerCholeskyTransform)

  Transform from unconstrained matrices to lower-triangular matrices with nonnegative diagonal entries.This is useful for parameterizing positive definite matrices in terms of their Cholesky factorization.



## Constraints

The following constraints are implemented:

- `constraints.boolean`
- `constraints.dependent`
- `constraints.greater_than(lower_bound)`
- `constraints.integer_interval(lower_bound, upper_bound)`
- `constraints.interval(lower_bound, upper_bound)`
- `constraints.lower_cholesky`
- `constraints.lower_triangular`
- `constraints.nonnegative_integer`
- `constraints.positive`
- `constraints.positive_definite`
- `constraints.positive_integer`
- `constraints.real`
- `constraints.real_vector`
- `constraints.simplex`
- `constraints.unit_interval`

- *CLASS*`torch.distributions.constraints.``Constraint`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/constraints.html#Constraint)

  Abstract base class for constraints.A constraint object represents a region over which a variable is valid, e.g. within which a variable can be optimized.`check`(*value*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/constraints.html#Constraint.check)Returns a byte tensor of sample_shape + batch_shape indicating whether each event in value satisfies this constraint.

- `torch.distributions.constraints.``dependent_property`

  alias of `torch.distributions.constraints._DependentProperty`

- `torch.distributions.constraints.``integer_interval`

  alias of `torch.distributions.constraints._IntegerInterval`

- `torch.distributions.constraints.``greater_than`

  alias of `torch.distributions.constraints._GreaterThan`

- `torch.distributions.constraints.``greater_than_eq`

  alias of `torch.distributions.constraints._GreaterThanEq`

- `torch.distributions.constraints.``less_than`

  alias of `torch.distributions.constraints._LessThan`

- `torch.distributions.constraints.``interval`

  alias of `torch.distributions.constraints._Interval`

- `torch.distributions.constraints.``half_open_interval`

  alias of `torch.distributions.constraints._HalfOpenInterval`



## Constraint Registry

PyTorch provides two global [`ConstraintRegistry`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraint_registry.ConstraintRegistry) objects that link [`Constraint`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraints.Constraint) objects to [`Transform`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transforms.Transform)objects. These objects both input constraints and return transforms, but they have different guarantees on bijectivity.

1. `biject_to(constraint)` looks up a bijective [`Transform`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transforms.Transform) from `constraints.real` to the given `constraint`. The returned transform is guaranteed to have `.bijective = True` and should implement `.log_abs_det_jacobian()`.
2. `transform_to(constraint)` looks up a not-necessarily bijective [`Transform`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transforms.Transform) from `constraints.real` to the given `constraint`. The returned transform is not guaranteed to implement `.log_abs_det_jacobian()`.

The `transform_to()` registry is useful for performing unconstrained optimization on constrained parameters of probability distributions, which are indicated by each distribution’s `.arg_constraints` dict. These transforms often overparameterize a space in order to avoid rotation; they are thus more suitable for coordinate-wise optimization algorithms like Adam:

```
loc = torch.zeros(100, requires_grad=True)
unconstrained = torch.zeros(100, requires_grad=True)
scale = transform_to(Normal.arg_constraints['scale'])(unconstrained)
loss = -Normal(loc, scale).log_prob(data).sum()
```

The `biject_to()` registry is useful for Hamiltonian Monte Carlo, where samples from a probability distribution with constrained `.support` are propagated in an unconstrained space, and algorithms are typically rotation invariant.:

```
dist = Exponential(rate)
unconstrained = torch.zeros(100, requires_grad=True)
sample = biject_to(dist.support)(unconstrained)
potential_energy = -dist.log_prob(sample).sum()
```

NOTE

An example where `transform_to` and `biject_to` differ is `constraints.simplex`: `transform_to(constraints.simplex)` returns a [`SoftmaxTransform`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transforms.SoftmaxTransform) that simply exponentiates and normalizes its inputs; this is a cheap and mostly coordinate-wise operation appropriate for algorithms like SVI. In contrast, `biject_to(constraints.simplex)` returns a [`StickBreakingTransform`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transforms.StickBreakingTransform) that bijects its input down to a one-fewer-dimensional space; this a more expensive less numerically stable transform but is needed for algorithms like HMC.

The `biject_to` and `transform_to` objects can be extended by user-defined constraints and transforms using their `.register()` method either as a function on singleton constraints:

```
transform_to.register(my_constraint, my_transform)
```

or as a decorator on parameterized constraints:

```
@transform_to.register(MyConstraintClass)
def my_factory(constraint):
    assert isinstance(constraint, MyConstraintClass)
    return MyTransform(constraint.param1, constraint.param2)
```

You can create your own registry by creating a new [`ConstraintRegistry`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraint_registry.ConstraintRegistry) object.

- *CLASS*`torch.distributions.constraint_registry.``ConstraintRegistry`[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/constraint_registry.html#ConstraintRegistry)

  Registry to link constraints to transforms.`register`(*constraint*, *factory=None*)[[SOURCE\]](https://pytorch.org/docs/stable/_modules/torch/distributions/constraint_registry.html#ConstraintRegistry.register)Registers a [`Constraint`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraints.Constraint) subclass in this registry. Usage:`@my_registry.register(MyConstraintClass) def construct_transform(constraint):     assert isinstance(constraint, MyConstraint)     return MyTransform(constraint.arg_constraints) `Parameters**constraint** (subclass of [`Constraint`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraints.Constraint)) – A subclass of [`Constraint`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.constraints.Constraint), or a singleton object of the desired class.**factory** (*callable*) – A callable that inputs a constraint object and returns a[`Transform`](https://pytorch.org/docs/stable/distributions.html#torch.distributions.transforms.Transform) object.
