---
title: 二值化
toc: true
date: 2019-09-16
---
# 二值化

<center>

![mark](http://images.iterate.site/blog/image/20190915/wKKFVozVcXWG.png?imageslim)

</center>

有了灰色图，我们怎么把他变黑白呢？（装 B 的说法：二值化）

算法有很多很多很多很多……

下面的软件列举了 n 种二值化的方法

<center>

![mark](http://images.iterate.site/blog/image/20190915/iaU0exG7fCzS.png?imageslim)

</center>

每一种方法都有优缺点，没有一种完美的解决方案。我自己做了灰度平均值、百分比阈值和双峰波谷最小值等几个算法，根据我的实验效果，最后选择了双峰波谷最小值法。

这种算法是怎么样工作的呢？

我们之前已经得到了灰度图，他的 RGB 值：t=r=g=b。这样我们就可以将 RGB(r,g,b)值合并，用一个 t 表示。最终简化成用 1 个 Byte(8bits)来表示每一个像素的值，每个像素的值就会落在[0, 255]这样一个闭区间上，如果我们用 16 进制表示，就是[00, ff]这样一个区间。如果用放大镜放大一个 10*4个像素的图片，就会像这样：

00 00 00 00 00 00 00 00 00 00
ee 00 ee dd 4f 29 30 00 00 00
ff 10 32 ee 40 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00

好了，我们看看，值为 0 的个数 C(0)=29个, C(ee)=3, C(dd)=1, C(4f)=1, C(29)=1, C(30)=1, C(32)=1……
于是乎，如果我们统计完我们实验那张图片的 0~255每个值的个数，会得到怎么样的一个结果呢？

<center>

![mark](http://images.iterate.site/blog/image/20190915/MYT1TLK9AoNF.png?imageslim)

</center>

用上述的方法，我把之前处理的那个灰度图片的灰度值放到二维平面上，x轴表示 0~255种色值，y轴表示每个色值的个数。仔细看，是否很容易看出有两个波峰。这两个波峰，就是这张灰度图片上最重要的两个色值：前景色+背景色。

一般来讲，在文本照片的 case 里，我们会认为背景色的数值会比前景色多很多，所以较高的波峰，我们就认为是背景色，而低的那个呢，我们认为是前景色。在非文本的很多情况下，有可能出现多个波峰，这个时候，前景色有可能是多个色调，这种 case 就先不在这里讨论了。

好啦，有这样一个数值投影，我们只要能找出前景色和背景色，就很好识别哪些是文字，哪些是背景了，对吧。从而，我们只要把前景标志为 1，背景标志为 0。我们就可以把一张 w*h像素的彩色图变成一个 w*h的位图。我们再在这张位图上做算法，就轻松太多了。接下来的工作，就是怎么样用算法来找到前景色和背景色。

我们肉眼很容易看出，在 x=18和 x=135两个点附近是两个波峰，那里对应的就是我们的前景和背景。不过，对于我们的程序来讲，还不是那么容易。我们需要再用算法来处理一下，让程序能很容易的辨认出来。

我们用程序怎么判断一个点是波峰呢？就是他旁边的两个点值比他小，对不对。那旁边的两个点比他小，他就一定是波峰嘛？很明显不是。比如我们上面的统计图，很多毛刺的点，他们不是波峰，但是比周围的点要大。那有没有一种比较好的算法能快速的找到波峰呢？

其中有一种简单粗暴但有效的方法，就是迭代平滑：每个点 a[i] = (a[i-1] + a[i] + a[i+1]) / 3（当然，首尾两个点单独处理），如此反复，至到找到只有两个点（如果多个连续点值相同，则看成是一个点）比旁边的点要大，或者最多执行 K 次（比如 100 次）。

我们来想想这个逻辑，我们不断用旁边点的值来修正一个点，那经过多次以后，这个点的值就会趋近于周围两个点。如果是一个突兀点，比如是一个高点，多次平均以后，一定和周围两个点的值相当，极限情况就是这几个点相等，对吧。

<center>

![mark](http://images.iterate.site/blog/image/20190915/CbuyIQohCf3o.png?imageslim)

</center>

这就是我们迭代平滑以后的点，看起来是不是如丝般顺滑啊，哈哈哈。
当然，如果迭代 K 次以后，也找不到这样两个点的话，我们就只能做个兼容方案：先找到最高点，然后再找距离这个点左右各 p 个点以外的次高点。我们就认为这两个点是前景和背景。当然，这个并不能证明他们就是，只是觉得他们最可能是。这个就没有绝对的好，只能做技术上的折中。这个时候就是做实验调参数了。

好了，有了波峰以后，我们总要给前背景做个区分，也就是，从那个点分开，把贴近背景的点认为都是背景，把贴近前景的点，认为都是前景。这个时候，我们就选择了两个波峰中间的波谷。（也有算法选择他们之间的平均值）。具体到这个 case，我们很容易就选择到了 62 号点附近。

<center>

![mark](http://images.iterate.site/blog/image/20190915/SWSBkGY07kGS.png?imageslim)

</center>

这样，小于 62 的点，都是前景色，其余的都是背景色。换句话说，也就是灰度图像上，gray=r=g=b中值小于 62 的，都是前景色，我们把他们标识为 1，认为是黑色。其余的都是 0，认为是白色。看看效果吧：

<center>

![mark](http://images.iterate.site/blog/image/20190915/AGwnkkwIdC43.png?imageslim)

</center>

怎么样，是不是感觉一下就清爽了呢？
这样，我们就把一张彩色图，变成了黑白图。
现在，我们的灰度像素图，就变成了类似这样的效果：


0 0 0 0 0 0 0 0 0 0
1 0 1 1 1 1 1 0 0 0
1 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0


# 相关

- [拍照怎么搜题？（上）](https://mp.weixin.qq.com/s?__biz=MzA3MDExNzcyNA==&mid=402907292&idx=1&sn=889c4abcf576e24525ea6a705069c4de)
