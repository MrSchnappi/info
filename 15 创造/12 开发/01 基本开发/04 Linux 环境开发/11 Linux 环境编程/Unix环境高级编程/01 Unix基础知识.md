---
title: 01 Unix基础知识
toc: true
date: 2018-08-21 18:15:06
---
##### 1.1弓 I 言

所有操作系统都为它们所运行的程序提供服务。典型的服务包括：执行新程序、打开文件、读 文件、分配存储区以及获得当前时间等，本书集中阐述不同版本的 UNIX 操作系统所提供的服务。

想要按严格的先后顺序介绍 UNIX，而不超前引用尚未介绍过的术语，这几乎是不可能的（可 能也会令人厌烦）。本章从程序员的角度快速浏览 UNIX，对书中引用的一些术语和概念进行简要 的说明并给出实例。在以后各章中，将对这些概念做更详细的说明。对于初涉 UNIX 环境的程序 员，本章还简要介绍了 UNIX提供的各种服务，

##### 1-2 UNIX体系结构

![img](UNIX环境高级编程_files/UNIXaf83d8a7160b-2.png)



从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境， 我们通常将这种软件称为内核（kernel），因为它相对较小，

而且位于环境的核心。图 1-1显示了 UNIX系统的体系结构。

内核的接口被称为系统调用（systemcall，图 1-1中的阴 影部分）。公用函数库构建在系统调用接口之上，应用程序 既可使用公用函数库，也可使用系统调用，（我们将在 1.11 节对系统调用和库函数做更多说明。）shell是一个特殊的应 用程序，为运行其他应用程序提供了一个接口。

从广义上说，操作系统包括了内核和一些其他软件，这 些软件使得计算机能够发挥作用，并使计算机具有自己的特 性。这里所说的其他软件包括系统实用程序（system utility ）＞

应用程序、shell以及公用函数库等。

例如，Linux是 GNU 操作系统使用的内核。一些人将这种操作系统称为 GNU/Linux操作系 统，但是，更常见的是简单地称其为 Linux。虽然这种表达方法在严格意义上讲并不正确，但鉴 于“操作系统”这个词的双重含义，这种叫法还是可以理解的（这样的叫法更简洁）。

###### 1.3登录

1.登录名

用户在登录 UNIX 系统时，先键入登录名，然后键入口令。系统在其口令文件（通常是/etc/

passwd文件）中査看登录名。口令文件中的登录项由 7 个以冒号分隔的字段组成，依次是：登录 名、加密口令、数字用户 ID （205〉、数字组 ID （105）、注释字段、起始目录（/home/sar）以及 shell 程序（/bin/ksh）。

sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh

目前，所有的系统已将加密口令移到另一个文件中。第 6 章将说明这种文件以及访问它们的 rn函数。

\2. shell

用户登录后，系统通常先显示一些系统信息。然后用户就可以向 shell 程序键入命令。（当 用户登录时，某些系统启动一个视窗管理程序，但最终总会有一个 shell 程序运行在一个视窗 中）。shell是一个命令行解释器，它读取用户输入，然后执行命令。shell的用户输入通常来自 于终端（交互式 shell），有时则来自于文件（称为 shell 脚本）。图 1-2总结了 UNIX系统中常见 的 shell。

| 名称              | 路径      | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris 10 |
| ----------------- | --------- | ----------- | ----------- | --------------- | ---------- |
| Bourne shell      | /bin/sh   | •           | -           | bash的副本      |            |
| Boume-again shell | /bin/bash | 可选的      | -           | •               |            |
| C shell           | /bin/csh  | 链接至 tcsh  | 可选的      | 链接至 tcsh      |            |
| Kom shell         | /bin/ksh  | 可选的      | 可选的      | •               |            |
| TENEX C shell     | /bin/tcsh | •           | 可选的      | •               |            |

图 1-2 UNIX系统中常见的 shell

系统从口令文件中相应用户登录项的最后一个字段中了解到应该为该登录用户执行哪一 个 shell。

自 V7 以来，由 SteveBoume 在贝尔实验室开发的 Boumeshell 得到了广泛应用，几乎每一个 现有的 UNIX 系统都提供 Bourne shell，其控制流结构类似于 Algol 68。

C shell是由 Bill Joy在伯克利开发的，所有 BSD 版本都提供这种 shell。另外，AT&T的 System V/386R3.2和 System VR4 （SVR4）也提供 C shell （下一章将对这些不同版本的 UNIX 系统做更多说明）。C shell是在第 6 版 shell 而非 Bourne shell的基础上构造的，其控制流类似 于 C 语言，它支持 Boumeshell 没有的一些特色功能，例如作业控制、历史机制以及命令行编 辑等。

Korn shell是 Bourne shell的后继者，它首先在 SVR4 中提供。Korn shell是由贝尔实验室的 David Korn开发的，在大多数 UNIX 系统上运行，但在 SVR4 之前，通常它需要另行购买，所以 没有其他两种 shell 流行。它与 Bourne shell向上兼容，并具有使 C shell广泛得到应用的一些特色 功能，包括作业控制以及命令行编辑等。

Bourne-again shell是 GNU shell，所有 Linux 系统都提供这种 shell。它的设计遵循 POSIX 标准，同时也保留了与 Bourne shell的兼容性。它支持 C shell和 Korn shell两者的特色 功能。

TENEX C shell是 C shell的加强版本。它从 TENEX 操作系统（1972年 BBN 公司开发）借 鉴了很多特色|例如命令完备。TENEX C shell在 C shell基础上增加了很多特性，常被用来替 换 C sheik

|~3~|    POSIX 1003.2标准对 shell 进行了标准化，这项规范基于 Kom shell和 Bourne shell的特性。

不同的 Linux 系统使用不同的默认 shell。一些 Linux 默认使用 Boume-againshe）lo另外一些使用 BSD 的对 Bourne shell的替代品 dash （Dd）ianAlmquist shell，最早由 Kenneth Ahnquist斤发，并在后来移植入 Linux ）o FreeBSD 的默认用户 shell 衍生于 Almquist shell。Mac OSX 的默认 shell 是 Boume-again shell。

Solaries继承了 BSD和 System V两者，它提供了困 1-2中所示的所有 shell。在因特网上可以 '：找到 shell 的自由移植版软件。

!    本书将使用这种形式的注释来描述历史注释，并对不同的 UNIX 系统的实现进行比较。当我

'们了解到历史缘由后，会更好地理解采用某种特定实现技术的原因。

本书将使用很多交互式 shell 实例来执行所开发的程序，这些实例使用了 Bourne shell、Korn shell 和 Boume-again shell 通用的功能。

1.4文件和目录

1.文件系统

UNIX文件系统是目录和文件的一种层次结构，所有东西的起点是称为根（root）的目录，这 个目录的名称是一个字符“/”。

目录（directoiy）是一个包含目录项的文件。在逻辑上，可以认为每个目录项都包含一个文 件名，同时还包含说明该文件属性的信息。文件属性是指文件类型（是普通文件还是目录等）、 文件大小、文件所有者、文件权限（其他用户能否访问该文件）以及文件最后的修改时间等，stat 和 fstat 函数返回包含所有文件属性的一个信息结构。第 4 章将详细说明文件的各种属性。

目录项的逻辑视图与实际存放在磁盘上的方式是不同的。UNIX文件系统的大多数实现并不 在目录项中存放属性，这是因为当一个文件具有多个竣链接时，很难保持多个属性副本之间的同

步。这一点将在第 4 章讨论硬键接时理解得更明晰。

\2.    文件名

目录中的各个名字称为文件名（filename）。只有斜线（/）和空字符这两个字狩不能出现在 文件名中。斜线用来分隔构成路径名的各文件名，空字符则用来终止一个路径名。尽管如此，好 的习惯还是只使用常用印刷字符的一个子集作为文件名字符（如果在文件名中使用了某些 shell 的特殊字符，则必须使用 shell 的引号机制来引用文件名，这会带来很多麻烦）。事实上，为了可 移植性，POSIX.1推荐将文件名限制在以下字符集之内：字母（a〜z、A〜Z）、数字（0〜9）、

句点（•）、短横线（-）和下划线（_）。

创建新目录时会自动创建了两个文件名：.（称为点）和..（称为点点）。点指向当前目录，

点点指向父目录。在最髙层次的根目录中，点点与点相同。    m

Research UNIX System和某些早期 UNIX System V的文件系统限制文件名的最大长度为 14 个 字符，BSD版本则将这种限制扩展为 255 个字符 Q 现今，几乎所有商业化的 UNIX 文件系统都支 持超过 255 个字符的文件名。

\3.    路径名

由斜线分隔的一个或多个文件名组成的序列（也可以斜线开头）构成路往名（pathname），以斜线 开头的路授名梅为绝对路径名（absolute pathname），吾则称为相对路径名（relative pathname〉。相对路 径名指向相对于当前目录的文件。文件系统根的名字（/）是一个特殊的绝財路径名，它不包含文件名。

■实例

不难列出一个目录中所有文件的名字，图 1-3是 ls(l)命令的简要实现。

番 include "apue.h"

linclude <dirent.h>

int

main(int argc, char *argv[])

{

DIR    *dp；

struct dirent *dirp;

if (argc != 2)

err_quit("usage: Is directory_name");

if { {dp = opendir(argv[1])) == NULL)

err_sys("can't open %s", argv[1]);

while ((dirp = readdir(dp)) != NULL) printf{"%s\n", dirp->d_name);

closedir(dp); exit(0);

}

图 1-3列出一个目录中的所有文件

ls(l)这种表示方法是 UNIX 系统的惯用方法，用以引用 UNIX 系统手册中的一个特定项。 1S(1)引用第一部分中的 Is 项。各部分通常用数字 1〜8编号，在每个部分中的各项则按字母顺 序排列。在本书中始终假定你有自己所使用的 UNIX 系统的手册。

早期的 UNIX 系统把 8 个部分都集中在一本《UNIX程序员手册》(

Manual} to随着萸数的增加，现在的趋势是把这些部分分别安排在不同的手册中，例如用户 手册、程序员手册以及系统管理贝手册等。

一些 UNIX 系统用大写字母把某一部分手册进一步分成若干小部分，例如，AT&T[1990e]中 的所有标准 I/O函数都被指明位于 3S 部分中，例如 fopen(3S)。另一些 UNIX 系统不用数字而是 用字母将手册分成若干部分。如用 C 表示命令部分等。

现今，大多数手册都以电子文档形式提供。如果用的是联机手册，则可用下面的命令査看 Is 命令手册页：

man 1 Is man -si Is

图 1-3只打印一个目录中各个文件的名字，不显示其他信息，如果该源文件名为 myls.c， 则可以用下面的命令对其进行编译，编译结果是生成默认名为 a.out的可执行文件中。

cc myls.c

历史上，cc（l）是 C 编译器。在配置了 GNU C编译系统的系统中，C编译器是 gcc（l）。其中， cc通常链接至 gcc。

示例输出如下：

$ ./a.out /dav

cdrom

stderr

stdout

stdin

sda4

sda3

sda2

sdal

sda

tty2

ttyl

console

tty

zero

null

很多行未显示

mem

$ ./a.out /etc/ssl/pcivata

can’t open /etc/ssl/private: Permission denied $ ./a.out /dov/tty

can't open /dev/tty: Not a directory

本书将以以下方式表示输入的命令及其输出：输入的字符以等宽粗体表示，程序输出则以上 面所示的等宽字体表示。对输出的注释以中文宋体表示。输入之前的美元符号（$）是 shell 的提 示符，本书总是将 shell 提示符表示为 $。

注意，myls程序列出的目录中的文件名不是以字母顺序列出的，而 Is 命令一般是按字母顺 序打印目录项。

在这个 20 行的程序中，有很多细节需要考虑。

•首先，其中包含了一个头文件 apue.h。本书中几乎每一个程序都包含此头文件。它包含 了某些标准系统头文件，定义了许多常量及函数原型，这些都将用于本书的各个实例中， 附录 B 列出了这一头文件。

•接下来，我们包含了一个系统头文件 dirent, h，以便使用 opendir 和 readdir 的函 数原型，以及 dirent 结构的定义。在其他一些系统里，这些定义被分成多个头文件。 比如，在 Ubuntu 12.04中，/usr/include/dirent.h声明了函数原型，并且包含 bits/dirent .h，后者定义了 dirent 结钩（真正存放在/usr/include/x86_64-linux-gnu/bits 下

• main函数的声明使用了 ISO C标准所使用的风格（下一章将对 ISO C标准进行更多 说明）。

•程序获取命令行的第 1 个参数 argv[l]作为要列出其各个目录项的目录名。第 7 章将说 明 main 函数如何被调用，程序如何存取命令行参数和环境变量。

•因为各种不同 UNIX 系统目录项的实际格式是不一样的，所以使用函数 opendir、 readdir和 closedir 对目录进行处理。

• opendir函数返回指向 DIR 结构的指针，我们将该指针传送给 readdir 函数。我们并 不关心 DIR 结构中包含了什么。然后，在循环中调用 readdir 来读每个目录项。它返 回一个指向 dirent 结构的指针，而当目录中已无目录项可读时则返回 null 指针。在 dirent结构中取出的只是每个目录项的名字(d_name)。使用该名字，此后就可调用 stat函数(见 4.2节)以获傳该文件的所有属性。

•程序调用了两个自编的函数対错误进行处理：err_SyS和 err_qUit。从上面的输出中 可以看到，err_sys 函数打印一条消息(“Permission denied” 或 “Not a directory”)，说 明遇到了什么类型的错误。这两个出错处理函数在附录 B 中说明，1.7节将更多地叙述出 错处理。

•当程序将结束时，它以参数 0 调用函数 exit。函数 exit 终止程序。按惯例，参数 0 的 意思是正常结束，参数值 1-255则表示出错。8.5节将说明一个程序(如 shell 或我们所 编写的程序)如何获得它所执行的另一个程序的 exit 状态。

\4.    工作目录

每个进程都有一个工作目录(working directory)，有时称其力当前工作目录(current working directory)-所有相对路径名都从工作目录开始解释。进程可以用 chdir 函数更改其工作目录。

例如，相对路径名 doc/memo/joe指的是当前工作目录中的 doc 目录中的 memo 目录中的 文件(或目录)joe。从读路授名可以看出，doc和 memo 都应当是目录，但是却不能廿辨 joe 是文件还是目录。路径名/urs/lib/lint是一个绝对路径名，它指的是根目录中的 usr 目录中 的 lib 目录中的文件(或目录)lint。

\5.    起始目录

登录时，工作目录设置为起始目录(homedirectory)，该起始目录从口令文件(见 1.3节)中 相应用户的登录项中取得。

1.5输入和输出

\1.    文件描述符

文件描述符(file descriptor)通常是一个小的非负整数，内核用以标识一个特定进程正在访 问的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。在谏、写 文件时，可以使用这个文件描述符。

\2.    标准输入、标准输出和标准错误

按惯例，每当运行一个新程序时，所有的 shell 都为其打开 3 个文件描述符，即标准输入 (standardinput)>枯准输出(standardoutput)以及标准错误(standarderror)0如果不做特殊处理， 例如就像简单的命令 Is，则这 3 个描述符都链接向终端。大多数 shell 都提供一种方法，使其中 任何一个或所有这 3 个描述符都能重新定向到某个文件，例如：

Is > file.list

执行 Is 命令，其标淮输出重新定向到名为 file.list的文件。

3.不帝缓冲的 I/O

函数 open、read、write、lseek以及 close 提供了不带缓冲的 I/O。这些函数都使用文 件描述符。

■L实例

如果愿意从标准输入读，并向标准输出写，则图 14 中所示的程序可用于复制任一 UNIX 普 通文件。    m

番 include ’’apue. h"

禅 define BUFFSIZE 4096

int

main(void)

{

int n;

Char buf[BUFFSIZE];

while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0) if (write(STDOUT_FILENO, buf, n) != n)

err_sys("write error");

if (n < 0>

err_sys("read error");

exit(0);

J

图将标准输入复制到标准输出

头文件＜unistd.h＞ （apue.h中包含了此头文件）及两个常量 STDIN_FILENO和 STDOUT_ FILENO是 POSIX 标准的一部分（下一章将对此做更多的说明）。头文件含了很 多 UNIX 系统服务的函数原型，例如图 M 程序中调用的 read 和 write。

两个常量 STDIN_FILENO和 STDOUT_FILENO定义在＜unistd.h＞头文件中，它们指定了 标准输入和标准输出的文件描述符。在 POSIX 标准中，它们的值分别是 0 和 1，但是考虑到可读 性，我们将使用这些名字来表示这些常量。

3.9节将详细讨论 BUFFSIZE 常量，说明它的各种不同值将如何影响程序的效率。但是不管 该常量的值如何，此程序总能复制任一 UNIX普通文件。

read函数返回读取的字节数，此值用作要写的字节数。当到达输入文件的尾端时，read返 回 0，程序停止执行-如果发生了一个读错误，read返回-1。出错时大多数系统函数返回-1。

如果将该程序编译成标准名称的 a.out文件，并以下列方式执行它：

./a.out ＞ data

那么标准输入是终端，标准输出则重新定向至文件 data，标准错误也是终端。如果此输出文件 并不存在，则 shell 会创建它。该程序将用户键入的各行复制到标淮输出，键入文件结束符（通常 是 Ctrl+D）时，将终止本次复制。

若以下列方式执行该程序：

./a.out < infile > outfile

会将名为 infile 文件的内容复制到名为 outfile 的文件中。

第 3 章将更详细地说明不带缓冲的 I/O函数。

4.标准 I/O

标准 I/O函数为那些不带缓冲的 I/O函数提供了一个带缓冲的接口。使用标准 I/O函数无需 担心如何选取最佳的缓冲 E 大小，如图中的 BUFFSIZE 常量的大小。使用标准 I/O函数还简 化了对输入行的处理（常常发生在 UNIX 的应用程序中例如，fgets函数读取一个完整的行， 而 read 函数读取指定字节数。在 5.4节中我们将了解到，标准 I/O函数库提供了使我们能够控 制该库所使用的缓冲风格的函数，

我们最熟悉的标准 I/O函数是 printf。在调用 printf 的程序中，益是包含＜31＜110.h＞（在 本书中，该头文件包含在 apue.h中），该头文件包括了所有标准 I/O函数的原型。

图 1-5程序的功能类似于前一个调用了 read和 write 的程序，5.8节将对此程序进行更详 细的说明。它将标准输入复制到标准输出，也就能复制任一 UNIX普通文件。

frinclude "apue.h" int

main(void)

{

int    c;

while { {c = getc(stdin))    != EOF)

if (putc(c, stdout) == EOF)

err_sys("output error");

if (ferror(stdin))

err_sys("input error");

exit(0);

图 1-5用标准 I/O将标准输入复制到标准输出

函数 getc—次读取一个字符，然后函数 putc 将此字符写到标淮输出。读到输入的最后一 个字节时，getc返回常量 EOF （该常量在＜stdio .h＞中定义）。标准 I/O常量 stdin 和 stdout 也在头文件＜3七 011.0.?1＞中定义，它们分别表示标准输入和标准输出。    ■錄


1.6程序和进程

\1.    程序

程序（program）是一个存储在磁盘上某个目录中的可执行文件。内核使用 exec 函数（7个 間 exec 函数之一），将程序读入内存，并执行程序。8.10节将说明这些 exec 函数。

\2.    进程和进程 ID

程序的执行实例被称为进程（process）。本书的每一页几乎都会使用这一术语。某些操作系 统用任务（task）表示正在被执行的程序。

UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程 ID （process ID）。进程 ID 总 是一个非负整数。

■实例

图 1-6程序用于打印进程 ID。

\#include "apue.h" int

main(void)

f

printf("hello world from process ID %ld\n", (long)getpid()); exit (0);

}

图 1-6打印进程 ID

如果将该程序编课成 a.out文件，然后执行它，则有：

$ ./a.out

hello world from process ID 851

$ ./a.out

hello world from process ID 854

此程序运行时，它调用函数 getpid 得到其进程 ID。我们将会在后面看到，getpid返回一个 Pid_t数据类型。我们不知道它的大小，仅知道的是标准会保证它能保存在一个长整型中。因为 我们必须在 printf 函数中指定需要打印的每一个变量的大小，所以我们必须把它的值强制转换 为它可能会用到的最大的数据类型（这里是长整型）。虽然大多数进程 ID 可以用整型表示，但用 长整型可以提高可移植性。

3.进程控制

有 3 个用于进程控制的主要函数：fork、exec和 waitpid。（exec函数有 7 种变体，但 经常把它们统称为 exec 函数。）

实例

UNIX系统的进程控制功能可以用一个简单的程序说明（见图］-7）。该程序从标准输入读取 命令，然后执行送些命令。它类似于 shdi 程序的基本实施部分。    rm

\#include "apue.h"

♦include <sys/wait.h> int

main(void)

{

char buf [MAXLINE] ；    /* from apue.h */

pid_t pid; int status;

printf("%% ");    /* print prompt (printf requires %% to print %) */

while (fgets(buf, MAXLINE, stdin) != NULL) {

if (buf[strlen(buf) - 1I == *\n')

buf[strlen(buf) - 1] = 0; /* replace newline with null */

if ((pid = fork()) < 0) { err_sys("fork error");

} else if (pid == 0) {    /* child */

execlp(buf, buf, (char *)0); err_ret("couldn1t execute: %g", buf); exit(127)；

/* parent */

if ((pid = waitpid(pid, Sstatus, 0)) < 0) err_sys{"waitpid error");

printf("%% ");

)

exit(0);

图 1-7从标准输入读命令并执行 在这个 30 行的程序中，有很多功能需要考虑。

•用标准 I/O函数 fgets 从标准输入一次读取•一行。当键入文件结束符（通常是 Ctrl+D）作 为行的第一个字符时，fgets返回一个 null 指针，于是循环停止，进程也就终止。第 18 章将说明所有特殊的终端字符（文件结束、退格字符、整行擦除等），以及如何改变它们。

。因为 fgets 返回的每一行都以换行符终止，后随一个 null 字节，因此用标准 C 函数 strlen 计算此字符串的长度，然后用一个 null 字节替换换行符。这样做是因为 execlp 函数要 求的参数是以 null 结束的而不是以换行符结束的。

•调用 fork 创建一个新进程。新进程是调用进程的一个副本，我们称调用进程为父进程， 新创建的进程为子进程。fork对父进程返回新的子进程的进程 ID （—个非负整数），对

DTI    子进程则返回 0。因为 fork 创建一个新进程，所以说它被调用一次（由父进程），但返

回两次（分别在父进程中和在子进程中），

•在子进程中，调用 execlp 以执行从标准输入读入的命令。这就用新的程序文件替换了 子进程原先执行的程序文件。fork和跟随其后的 exec 两者的组合就是某些操作系统所 称的产生（spawn） —个新进程。在 UNIX 系统中，这两部分分离成两个独立的函数。第 8章将对这些函数进行更多说明，

•子进程调用 execlp 执行新程序文件，而父进程希望等待子进程终止，这是通过调用 waitpid实现的，其参数指定要等待的进程（即 pid 参数是子进程 ID）。waitpid函 数返回子进程的终止状态（status变量）。在我们这个简单的程序中，没有使用该值。 如果需要，可以用此值准确地判定子进程是如何终止的，

•该程序的最主要限制是不能向所执行的命令传递参数。例如不能指定要列出目录项的目 录名，只能对工作目录执行 Is 命令。为了传递参数，先要分析输入行，然后用某种约定 把参数分开（可能使用空格或制表符），再将分隔后的各个参数传递给 execlp 函数。尽 管如此，此程序仍可用来说明 UNIX 系统的进程控制功能。

如果运行此程序，将得到下列结果。注意，该程序使用了一个不同的提示符（%），以区别于 shell的提示符。

$ ./a.out % date

Sat Jan 21 19:42:07 EST 2012

% who

sar    console    Jan    1    14:59

sar    ttysOOO    Jan    1    14 ： 59

sar    ttysOOl    Jan    15    15:28

% pwd

/home/sar/bk/apue/3e

% Is

Makefile a. out shelll.c

键入文件结束符 常规的 shell 提示符



% *D

$

；    "D表示一个控制字符。控制字符是特殊字符，其构成方法是：在键盘上按下控制键——通常

；被标记为 Control 或 Ctrl，同时按另一个键。Ctrl+D或 AD 是默认的文件结束符。在第 18 章中

讨论终端 I/O时，会介绍更多的控制字符。

4.线程和线程 ID

通常，一个进程只有一个控制线程（thread）——某一时刻执行的一组机器指令。对于某些 问题，如果有多个控制线程分别作用于它的不同部分，那么解决起来就容易得多。另外，多个接 制线程也可以充分利用多处理器系统的并行能力。

一个进程内的所有线程共享同一地址空间、文件描述符、桟以及与进程相关的属性。因为它 们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。

与进程相同，线程也用 ID 标识。但是，线程 ID 只在它所属的进程内起作用。一个进程中的 线程 ID 在另一个进程中没有意义。当在一进程中对某个特定线程进行处理时，我们可以使用孩 线程的 ID 引用它。

控制线程的函数与控制进程的函数类似，但另有一套。线程模型是在进程模型建立很久之后才被 引入到 UNIX 系统中的，然而这两种模型之间存在复杂的交互，在第 12 章中，我们会对此进行说明。

1.7出错处理

当 UNIX 系统函数出错时，通常会返回一个负值，而且整型变量 errno 通常被设置为具有特定 信息的值。例如，open函数如果成功执行则返回一个非负文件描述符，如出错则返回-1。在 open 出错时，有大约 15 种不同的 errno 值（文件不存在、权限问题等）。而有些函数对于出错则使用另 一种约定而不是返回负值。例如，大多数返回指向对象指针的函数，在出错时会返回一个皿 11 指针。

文件＜扛 2：110』＞中定义丁 errno以及可以赋与它的各种常量。这些常量都以字狩 E 开头。 另外，UNIX系统手册第 2 部分的第 1 页，intro（2）列出了所有这些出错常量。例如，若 errno 等于常量 EACCES，表示产生了权限问题（例如，没有足够的权限打开请求文件）。

在 Linux 中，出错常量在 errno（3）手册页中列出。

POSIX和 ISO （3将 errno 定义为一个符号，它扩展成为一个可修改的整形左值（lvalue）。 它可以是一个包含出错编号的整数，也可以是一个返回出错编号指针的函数。以前使用的定义是：

extern int errno;

但是在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部 errno riTI以避免一个线程干扰另一个线程。例如，Linux支持多线程存取 61^110，将其定义为：

extern int *_errno_location(void);

\#define errno (*_errno_location())

对 T errno应当注意两条规则。第一条规则是，如果没有出错，其值不会被例程清除。因 此，仅当函数的返回值指明出错时，才检验其值。第二条规则是：任何函数都不会将 errno 值 设置为 0，而且在<errnO.h>中定义的所有常量都不为 0。

C标准定义了两个函数，它们用于打印出错信息。 ftinclude <string.h> char *strerror (int ermum};

返回值：指向消息字符串的指针

strerror函数将(通常就是 errno 值)映射为一个出错消息字符串，并且退回此 字符串的指针。

perror函数基于 errno 的当前值，在标准错误上产生一条出错消息，然后返回。

\#include <stdio.h>

void perror (const char *msg);

它首先输出由 m 呀指向的字符串，然后是一个冒号，一个空格，接着是对应于 errno 值的 出错消息，最后是一个换行符。

、实例

图 1-8程序显示了这两个出错函数的使用方法。

\#include "apue.h"

\#include <errno.h>

int

main(int argc, char *argv[])

{

fprintf(stderr, "EACCES: %s\n", strerror(EACCES)); errno = ENOENT; perror(argv[0]); exit (0);

图 1-8 例示 strerror 和 perror 如果将此程序编译成文件 a.cmt，然后执行它，则有

S ./a-out

EACCES: Permission denied

./a.out: No such file or directory

注意，我们将程序名(argv[0]，其值是./a .out)作为参数传递给 perror。这是一个标准的 UNIX惯例。使用这种方法，在程序作为管道的一部分执行时 I 例如：

progl < inputfile I prog2 I prog3 > outputfile

我们就能分清 3 个程序中的哪一个产生了一条特定的出错消息。

本书中的所有实例基本上都不直接调用 strerror 或 perror，而是使用附录 B 中的出错函 数。该附录中的出错函数使我们只用一条 C 语句就可利用 ISOC 的可变参数表功能处理出错情况。

出错恢复

可将在＜errn0.h＞中定义的各种出错分成两类:致命性的和非致命性的。对于致命性的错误， 无法执行恢复动作。最多能做的是在用户屏幕上打印出一条出错消息或者将一条出错消息写入日 志文件中，然后退出。対于非致命性的出错，有时可以较妥善地进行处理。大多数非致命性出错 是暂时的（如资源短缺），当系统中的活动较少时，这种出错很可能不会发生。

与资源相关的非致命性出错包括：EAGAIN、ENFILE. ENOBUFS、ENOLCK、ENOSPC、 EWOULDBLOCK，有时 ENOMEM 也是非致命性出错。当 EBUSY 指明共享资源正在使用时，也可将 它作为非致命性出错处理。当 EINTR 中断一个慢速系统调用时，可将它作为非致命性出错处理 （在 10.5节対此会进行更多说明）。

对于资源相关的非致命性出错的典型恢复操作是延迟一段时间，然后重试。这种技术可应用 于其他情况。例如，假设出错表明一个网络连接不再起作用，那么应用程序可以采用这种方法，

在短时间延迟后，尝试重建该连接。一些应用使用指数补偿算法，在每次迭代中等待更长时间。

最终，由应用的开发者决定在哪些情况下应用程序可以从出错中恢复。如果能够采用一种合 理的恢复策略，那么可以避免应用程序异常终止，进而就能改善应用程序的健壮性，

1.8用户标识

\1.    用户 ID

口令文件登录项中的用户 ID （userID）是一个数值，它向系统标识各个不同的用户。系统 管理员在确定一个用户的登录名的同时，确定其用户 ID。用户不能更改其用户 ID。通常每个用 户有一个唯一的用户 ID。下面将介绍内核如何使用用户 ID 来检验该用户是否有执行某些操作 的权限。

用户 1D 为 0 的用户为根用户（root）或超级用户（superuser〉。在口令文件中，通常有一个 登录项，其登录名为 root，我们称这种用户的特权为超级用户特权。我们将在第 4 章中看到，

如果一个进程具有超级用户特权，则大多数文件权限检查都不再进行。某些操作系统功能只向超 级用户提供，超级用户对系统有自由的支配权。    nn

: MacOSX客户端版本交由用户使用时，禁用超级用户账户，服务器版本则可使用该账户。在 丨 Apple 的网站可以找到使用说明，它告知如何才能使用该赚户。参见<http://support>.

[apple.com/kb/HTl528。

\2.    组 ID

口令文件登录项也包括用户的组 ID （group ID），它是一个数值。组 ID 也是由系统管理 员在指定用户登录名时分配的。一般来说，在口令文件中有多个登录项具有相同的组 nx 组 被用于将若干用户集合到项目或部门中去-这种机制允许同组的各个成员之间共享资源（如 文件）。4.5节将介绍可以通过设置文件的权限使组内所有成员都能访问该文件，而组外用户 不能 i 方问。

组文件将组名映射为数值的组 ID。组文件通常是/etc/group。

使用数值的用户 ID 和数值的组 1D 设置权限是历史上形成的。对于磁盘上的每个文件，文件 系统都存储该文件所有者的用户 ID 和组 ID-存储这两个值只需 4 个字节(假定每个都以双字节 的整型值存放)。如果使用完整 ASCII 登录名和组名，则需更多的磁盘空间。另外，在检验权限 期间，比较字符串较之比较整型数更消耗时间。

但是対于用户而言，使用名字比使用数值方便，所以口令文件包含了登录名和用户 ID 之间 的映射关系，而组文件则包含了组名和组江＞ 之间的映射关系。例如，Is -1命令使用口令文件 将数值的用户 ID 映射为登录名，从而打印出文件所有者的登录名。

早期的 UNIX 系统使用 16 位整型數表示用户 ID 和组 ID。现今的 UNIX 系统使用 32 位整型 ；教表示用户 1D 和组 ID。

t实例

图 1-9程序用于打印用户 ID 和组 ID。 昝 include "apue.h"

int

main(void)

t

printf("uid = %d, gid = %d\n", getuidt), getgid()); exit{0);

_

图 1-9打印用户 ID 和组 ID

程序调用 getuid 和 getgid 以返回用户 ID 和组 ID。运行该程序的结果如下：

$ ./a.out

1 17 |    uid = 205, gid = 105

3.附属组 ID

除了在口令文件中对一个登录名指定一个组 ID 外，大多数 UNIX 系统版本还允许一个用户 属于另外一些组。这一功能是从 4.2BSD开始的，它允许一个用户属于多至 16 个其他的组。登录 时，读文件/etc/group，寻找列有该用户作为其成员的前 16 个记录项就可以得到该用户的附 属组 ID (supplementary group ID)O在下一章将说明，POSIX要求系统至少应支持 8 个附属组， 实际上大多数系统至少支持 16 个附属组。

##### 1.9信号

信号(signal)用于通知进程发生了某种情况。例如，若某一进程执行除法操作，其除数为 0, 则将名为 SIGFPE (浮点异常)的信号发送给该进程。进程有以下 3 种处理信号的方式。

(1)    忽略信号。有些信号表示硬件异常，例如，除以 0 或访问进程地址空间以外的存储单元 等，因为这些异常产生的后果不确定，所以不推荐使用这种处理方式。

(2)    按系统默认方式处理。对于除数为 0，系统默认方式是终止读进程。

(3)    提供一个函数，信号发生时调用该函数，这被称为捕捉该信号。通过提供自编的函数， 我们就能知道什么时候产生了信号，并按期望的方式处理它。

很多情况都会产生信号。终端键盘上有两种产生信号的方法，分别称为中断键（interrupt key, 通常是 Delete 键或 Ctrl+C）和退出键（quitkey，通常是 Ctrl+\），它们被用于中断当前运行的进程。

另一种产生信号的方法是调用 kill 函数。在一■个进程中调用此函数就可向另一个进程发送一个信 号。当然这样做也有些限制：当向一个进程发送信号时，我们必须是那个进程的所有者或者是超级 用户。

賤•实例

回忆一下基本的 shell 实例（见图 1-7程序）。如果调用此程序，然后按下中断键，则执行此 程序的进程终止。产生这种后果的原因是：对于此信号（SIGINT）的系统默认动作是终止进程。 该进程没有告诉系统内核应该如何处理此信号，所以系统按默认方式终止该进程。

为了能捕捉到此信号，程序需要调用 signal 函数，其中指定了当产生 SIGINT 信号时 要调用的函数的名字。函数名为 sig_int，当其被调用时，只是打印一条消息，然后打印［KI —个新提示符。在图 1-7程序中添加了 11行，构成了图 1-10程序（添加的 11 行以行首的+

号指示）。

\#include "apue.h"

\#include <sys/wait.h>

十 static void sig_int（int）;    /* our signal-catching function */

main(void)

{

char buf[MAXLINE]; /* from apue.h */ pid_t pid; int status;

\+    if (signal(SIGINT, sig_int) == SIG_ERR}

\+    err_sys("signal error");

+

printf("%% "); /* print prompt (printf requires %% to print %) */ while (fgets{buf, MAXLINE, stdin) != NULL) {

if (buf[strlen(buf) - 1] == 1\n')

buf[strlen(buf) - 1] = 0; /* replace newline with null */

if ( (pid = fork{) ) < 0) { err_sys("fork error");

} else if (pid == 0) {    /* child */

execlp (buf, buf, (char *)0); err_ret("couldn1t execute: %s", buf); exit(127);

/* parent */

if ((pid = waitpid(pid, Sstatus, 0)) < 0) err_sys ("waitpid error'1};

printf("%% ");

1

exit (0);

\+ void

\+ sig_int{int signo)

\+ (

\+ printf("interrupt\n%% "); + }

图 1-10从标准输入读命令并执行

冈    因为大多数重要的应用程序都对信号进行处理，所以第 10 章将详细介绍信号。

###### 1.10时间值

历史上，UNIX系统使用过两种不同的时间值。

(1)    日历时间。该值是自协调世界时(Coordinated Universal Time, UTC) 1970年 1 月 1 日 00X)0:00这个特定时间以来所经过的秒数累计值(早期的手册称 UTC 为格林尼治标准时间)。这 些时间值可用于记录文件最近一次的修改时间等。

系统基本数据类型 time_t用于保存这种时间值。

(2)    进程时间。也被称为 CPU 时间，用以度量进程使用的中央处理器资源。进程时间以时钟 滴答计算。每秒钟曾经取为 50、60或 100 个时钟滴答。

系统基本数据类型 clock.t保存这种时间值。2.5.4节将说明如何用 sysconf 函数得到每 秒的时钟滴答数。

当度量一个进程的执行时间时(见 3.9节)，UNIX系统为一个进程维护了 3个进程时间值：

•时钟时间；

•用户 CPU 时间；

•系统 CPU 时间。

时钟时间又称为墙上时钟时间(wall clock time)，它是进程运行的时间总量，其值与系统 中同时运行的进程数有关。每当在本书中提到时钟时间时，都是在系统中没有其他活动时进行 度量的》

用户 CPU 时间是执行用户指令所用的时间量。系统 CPU 时间是为该进程执行内核程序所经 历的时间。例如，每当一个进程执行一个系统服务时，如 read 或 write，在内核内执行该服务 所花费的时间就计入该进程的系统 CPU 时间。用户 CPU 时间和系统 CPU 时间之和常被称为 CPU 时间=

要取得任一进程的时钟时间、用户时间和系统时间是很容易的——只要执行命令 time(l)， 其参数是要度量其执行时间的命令，例如：

$ cd /use/xnoluda

$ ♦•Ana -p gcap _POSIX_SODRCB */*.h > /dav/null

real oraO,81s user omO.11s sys omO.07s

time命令的输出格式与所使用的 shell 有关，其原因是某些 shell 并不运行/usr/bin/time，而 是使用一个内置函数测量命令运行所使用的时间。

[20~|    8.17节将说明一个运行进程如何取得这 3 个时间=关于时间和日期的一般说明见 6.10节。

1.11系统调用和库函数

所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的 UNIX 实 现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用（systemcall,

见图 1-1）。Research UNIX系统第 7 版提供了约 50 个系统调用，4.4BSD提供了约 110 个系统调 用，而 SVR4 则提供了约 120 个系统调用。具体数字在不同操作系统版本中会不同，新近的大多 数系统大大增加了支持的系统调用的个数。Linux 3.2.0提供了 380个系统调用，FreeBSD 8.0提供 的系统调用超过 450 个。

系统调用接口总是在《UNIX程序员手册》的第 2 部分中说明，是用 C 语言定义的，与具体 系统如何调用一个系统调用的实现技术无关。这与很多早期的操作系统不同，那些系统按传统方 式用机器的汇编语言定义内核入口点。

UNIX所使用的技术是为每个系统调用在标准 C 库中设置一个具有同样名字的函数。用户进 程用标准 C 调用序列来调用这些函数，然后，函数又用系统所要求的技术调用相应的内核服务。

例如，函数可将一个或多个 C 参数送入通用寄存器，然后执行某个产生软中断进入内核的机器指 令。从应用角度考虑，可将系统调用视为 c 函数。

《UNIX程序员手册》的第 3 部分定义了程序员可以使用的通用库函数。虽然这些函数可能会 调用一个或多个内核的系统调用，但是它们并不是内核的入口点。例如，printf函数会调用 write系统调用以输出一个字符串，但函数 strcpy （复制一个字狩串）和 atoi （将 ASCII 转 换为整数）并不使用任何内核的系统调用。

从实现者的角度来看，系统调用和库函数之间有根本的区别，但从用户角度来看，其区别并 不重要。在本书中，系统调用和库函数都以 C 函数的形式出现，两者都为应用程序提供服务。但 是，我们应当理解，如果希望的话，我们可以替换库函数，但是系统调用通常是不能被替换的。

以存储空间分配函数 malloc 为例。有多种方法可以进行存储空间分配及与其相关的无用空 间回收操作（最佳适应、首次适应等），并不存在对所有程序都最优的一种技术。UNIX系统调用 中处理存储空间分配的是 sbrk（2），它不是一个通用的存储器管理器。它按指定字节数增加或减 少进程地址空间。如何管理该地址空间却取决于进程。存储空间分配函数 mallOC（3）实现一种特 定类型的分配。如果我们不喜欢其操作方式，则可以定义自己的 malloc 函数，它很可能将使用 sbrk系统调用。事实上，有很多软件包，它们使用 sbrk 系统调用实现自己的存储空间分配算 法。图 1-11显示了应用程序、malloc函数以及 sbrk 系统调用之间的关系。    [10

从中可见，两者职责不同，内核中的系统调用分配一块空间给进程，而库函数 malloc 则在 用户层次管理这-•空间。

另一个可说明系统调用和库函数之间差别的例子是，UNIX系统提供的判断当前时间和日期 的接口。一些操作系统分别提供了一个返回时间的系统调用和另一个返回日期的系统调用。任何 特殊的处理，例如正常时制和夏令时之间的转換，由内核处理或要求人为干预。UNIX系统则不 同，它只提供一个系统调用，该系统调用返回自协调世界时 1970 年 1 月 1 日零时这个特定时间 以来所经过的秒数。对该值的任何解释，例如将其变换成人们可读的、适用于本地时区的时间和 日期，都留给用户进程进行处理。在标准 C 库中，提供了若干例程以处理大多数情况。这些库函 数处理各种细节，如各种夏令时算法等。

应用程序既可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。图 1-12显

示了这种差别。

图 1-11 malloc函数和 sbrk 系统调用



图 1U2 C库函数和系统调用之间的差别



系统调用和库函数之间的另一个差别是：系统调用通常提供一种最小接口，而库函数通常提 [22]供比较复杂的功能。我们从 sbrk 系统调用和 malloc 库函数之间的差别中可以看到这一点。当 我们比较不带缓冲的 I/O函数（见第 3 章）和标准 I/O函数（见第 5 章）时，还将看到这种差别。

进程控制系统调用（fork、exec和 wait）通常由用户应用程序直接调用（请回忆图 1-7 中的基本 shell）。但是为了简化某些常见的情况，UNIX系统也提供了一些库函数，如 system 和 popen。8.13节将说明 system 函数的一种实现，它使用基本的进程控制系统调用 a 10.18节 还将强化这一实例以正确地处理信号。

为使读者了解大多数程序员应用的 UNIX 系统接口，我们不得不既说明系统调用，又介绍某 些库函数。例如，若只描述 sbrk 系统调用，那么就会忽略很多应用程序使用的 malloc 库函数 本书除了必须要区分两者时，对系统调用和库函数都使用函数（function）这一术语来表示。

##### 1.12小结

本章快速浏览了 UNIX系统。说明了某些以后会多次用到的基本术语，介绍了一些小的 UNIX [23]程序实例。读者可以从中大概了解到本书其余部分将要介绍的内容，

下一章是关于 UNIX 系统的标准，以及这方面的工作对当前系统的影响。标准，特别是 ISO C 标准和 POSEX.1标准，将影响本书的余下部分。

习题

1.1在系统上验证，除根目录外，目录。和.。是不同的。

1.2分析图 1-6程序的输出，说明进程 ID 为 852 和 853 的进程发生了什么情况？

1.3 在 1.7节中，perror的参数是用 ISO C的属性 const 定义的，而 strerror 的整型参数 没有用此属性定义，为什么？

1.4若日历时间存放在带符号的 32 位整型数中，那么到哪一年它将溢出？可以用什么方法扩展 溢出浮点数？采用的策略是否与现有的应用相兼容？

1.5 若进程时间存放在带符号的 32 位整型数中，而且每秒为 100 时钟滴答，那么经过多少天后

该时间值将会溢出？    ®
