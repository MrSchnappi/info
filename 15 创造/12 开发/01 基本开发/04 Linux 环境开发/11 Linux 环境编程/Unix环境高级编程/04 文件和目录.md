---
title: 04 文件和目录
toc: true
date: 2018-08-21 18:15:07
---
#### 文件和目录

###### 4.1引言

上一章我们说明了执行 I/O操作的基本函数，其中的讨论是围绕普通文件 I/O进行的——打开 文件、读文件或写文件。本章将描述文件系统的其他特征和文件的性质。我们将从 stat 函数开始， 逐个说明 stat 结构的每一个成员以了解文件的所有属性。在此过程中，我们将说明修改这些属性 的各个函数（更改所有者、更改权限等），还将更详细地说明 UNIX 文件系统的结构以及符号链接。 本章最后介绍对目录进行操作的各个函数，并且开发了一个以降序遍历目录层次结构的函数。

##### 4-2 函数 stat、fstat〜fstatat 和 lstat

本章主要讨论 4 个 stat 函数以及它们的返回信息。

\#include <sys/stat.h>

int stat {const char ^restrict pathname, struct stat ^restrict buf}; int fstat (int fd, struct stat *buj);

int lstat (const char * restrict pathname, struct stat * restrict buf};

int fstatat (int fd, const char * restrict patimame, struct stat * restrict btf, int fiag}:

[93]



所有 4 个函数的返回值：若成功：返回 0；若出错 I 返回-1

一-旦给出 po 决 name，stat函数将返回与此命名文件有关的信息结构 D fstat函数获得已 在描述符人/上打开文件的有关信息。lstat函数类似于 stat，但是当命名的文件是一个符号 链接时，lstat返回该符号链接的有关信息，而不是由该符号链接引用的文件的信息。（在 4.22 节中，当以降序遍历目录层次结构时，需要用到 lstat。4.17节将更详细地说明符号链接。）

fstatat函数为一个相对于当前打开目录（由参数指向〉的路径名返回文件统计信息。 A/g参数控制着是否跟随着一个符号链接。当 TVTLSYMLINICNOFOLLOW 标志被设置时，fstatat 不会跟随符号链接，而是返回符号链接本身的信息。否则，在默认情况下，返回的是符号链接所 指向的实际文件的信息。如果/rf参数的值是 AT_FDCWD，并且参数是一个相对路径名， fstatat会计算相対于当前目录的 pathname 参数。如果 pathname 是一个绝对路轻，参数就会 被，忽略。送两种情况下，根据及呀的取值，fstatat的作用就跟 stat 或 lstat 样

第 2 个参数是一个指针，它指向一个我们必须提供的结构。函数来填充由指向的结 构。结构的实际定义可能随具体实现有所不同，但其基本形式是：

struct stat {

mode_t

ino_t

dev_t

dev_t

nlink_t

uid_t

gicLt

off_t

struct timespec struct timespec struct timespec blksize_t blkcnt_t



st_mode;

st_ino;

st_dev;

st_rdev;

st_nlink;

st_uid;

st_gid;

st_size;

st_atime;

st_mtime;

st_ctime;

st_blksize;

st_blocks;



/* file type & mode (permissions) */ /* i-node number (serial number) */

/* device number {file system) */

/* device number for special files */ /* number of links *Z

/* user ID of owner */ /* group ID of owner */

/* size in bytes, for regular files */ /* time of last access */

/* time of last modification */

/* time of last file status change */ /* best I/O block size */

/* number of disk blocks allocated */

j POSIX.l 未要求 st_rdev、st_blksize 和 st_blocks 字段。Single UNIX Specification XSI i扩展定义了这些字段。

timespec结构类型按照秒和纳秒定义了时间，至少包括下面两个字段：

time_t tv_sec; long Cv_nsec；

在 2008 年版以前的标准中，时间字段定义成 st_atime、st_mtime以及 st_ctime，它 j们都是 tiine_t类型的(以秒来表示)。timespec结构提供了更高精度的时间戳。为了保持兼

容性，旧的名字可以定义成 tv_sec成员。例如，st_atime可以定义成 st_atim.tv_secD !叫|

注意，stat结构中的大多数成员都是基本系统数据类型(见 2.8节)。我们将说明此结构的 每个成员以了解文件属性。

使用 stat 函数最多的地方可能就是 Is -1命令，用其可以获得有关一个文件的所有 信息。

4.3文件类型

至此我们已经介绍了两种不同的文件类型：普通文件和目录。UNIX系统的大多数文件是普 通文件或目录，但是也有另外一些文件类型。文件类型包括如下几种。

(1)    普通文件(regular file)。这是最常用的文件樊型，这种文件包含了某种形式的数据。至 于这种数据是文本还是二进制数据，对于 UNIX 内核而言并无医别。对普通文件内容的解释由处 理该文件的应用程序进行。

:    一个值得注意的例外是二进制可执行文件。为了执行程序，内核必须理解其格式。所

j有二进制可执行文件都遵循一种标准化的格式，这种格式使内核能够确定程序文本和数据 ；的加载位置。

(2)    目录文件(directory file)。这种文件包含了其他文件的名字以及指向与这些文件有关信 息的指针=对一个目彔文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接 写目录文件。进程必须使用本章介绍的函数才能更改目录。

(3)    块特殊文件(blockspecial file)。这种类型的文件提供对设备(如磁盘)带缓冲的访问， 每次访问以固定长度为单位进行。

注意，FreeBSD不再支持块特殊文件。对设备的所有访问需要通过字符特殊文件进行。

(4)    字符特殊文件(character special file)。这种类型的文件提供对设备不带缓冲的访问，每 次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。

(5)    FIFO。这种类型的文件用于进程间通信，有时也称为命名管道(namedpipe)、15.5节将 对其进行说明。

(6)    套接字(socket)。这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主 机上进程之间的非网络通信。第 16 章将用套接字进行进程间的通信。

(7)    符号链接(symbolic link)。这种类型的文件指向另一个文件。4.17节将更多地描述符号 链接。

|-95~|    文件类型信息包含在 stat 结构的 st_mOde成员中。可以用图 4-1中的宏确定文件类型。这

咎定的参数都是 stat 结构中的 st_mode成员。

| 宏         | 文件类型     |
| ---------- | ------------ |
| S_ISREG()  | 普通文件     |
| S_ISDIR()  | 目录文件     |
| S_ISCHR()  | 字符特殊文件 |
| S_ISBLK()  | 块特殊文件   |
| S_ISFIFO() | 管道或 FIFO   |
| S_ISLNK()  | 符号链接     |
| S ISSOCK{) | 套接字       |

图 4~1在＜sys/stat.h＞^的文件类型宏

POSIX.1允许实现将进程间通信(IPC)对象(如消息队列和信号量等)说明为文件。图 4^2中 的宏可用来从 stat 结构中确定 IPC 对象的类型。这些宏与图 4-1中的不同，它们的参数并非 st_mode，而是指向 stat 结构的指针。

| 宏            | 对象的类型   |
| ------------- | ------------ |
| S_TYPEISMQ()  | 消息队列     |
| S_TYPEISSEM() | 信号量       |
| S TYPEISSHM() | 共享存储对象 |

图在＜373/3七 31:.^1＞中的 IPC 类型宏

消息队列、信号量以及共享存储对象等将在第 15 章中讨论。但是，本书讨论的 4 种 UNIX 系统都不将这些対象表示为文件。

■实例

图 4-3程序取其命令行参数，然后针对每一个命令行参数打印其文件类型。

^include "apue.h" int

main(int argc, char *argv[]) {

int i; struct stat buf; char *ptr;

for (i = 1; i < argc; i++) { printf("%s: ", argv[i]); if {lstat(argv[i], &buf) < 0) {

err^ret("lstat error"); continue;

}

if {S_ISREG(buf.st_mode)) ptr = "regular";

else if (S_ISDIR(buf.st_mode)) ptr = "directory";

else if (S_ISCHR(buf.st_mode)) ptr = "character special"; else if (S_ISBLK(buf.st_mode),

ptr = "block special"; else if {S_ISFIFO{buf-st_mode))

ptr = "fifo";

else if (S_ISLNK(buf.st_mode)) ptr = "symbolic link";

else if (S„ISSOCK(buf.st_mode)) ptr = "socket";

else

ptr = "** unknown mode ** printf("%s\n", ptr);

}

exit (0);

图 4-3对每个命令行参数打印文件类型

图 4-3程序的示例输出是：

$ ./a.out /etc/passwd /etc /dev/log /dev/tty \

＞ /var/lib/oprofile/opd_pipd /dev/srO /dev/cdcom

/etc/passwd： regular

/etc: directory

/dev/log： socket

/dev/tty: character special

/var/lib/oprofile/opdj)ipe: fifo

/dev/srO: block special

/dev/cdrom: symbolic link

(其中，在第一个命令行末端我们键入了一个反斜杠，通知 shell 要在下一行继续键入命令，然后， shell在下一行上用其辅助提示符＞提示我们。)我们特地使用了 lstat函数而不是 stat 函数以 便检测符号链接。如若使用 stat 函数，则不会观察到符号链接。

早期的 UNIX 版本并不提供 S_ISxxx宏，于是就需要将 st_mode与屏蔽字 S_IFMT进行逻 辑“与”运算，然后与名为 s_IFxxx的常量相比较。大多数系统在文件＜sys/stat.h＞中定义 了此屏蔽字和相关的常量。如若査看此文件，则可找到 S_ISDIR宏定义为：

ftdefine S_ISDIR (mode) (((mode) & S_IFMT) == S_IFDIR)

我们说过，普通文件是最主要的文件类型，但是观察一下在一个给定的系统中各种文件的比 例是很有意思的。图 4-4显示了在一个单用户工作站 Linux 系统中的统计值和百分比。这些数据 是由 4.22节中的程序得到的。

| 文件类型 | 统计值  | 百分比(％) |
| -------- | ------- | ---------- |
| 普通文件 | 415 803 | 79.77      |
| 目彔     | 62 197  | 11.93      |
| 符号链接 | 40 018  | 8.25       |
| 字符特殊 | 155     | 0+03       |
| 块特殊   | 47      | 0.01       |
| 套接字   | 45      | 0.01       |
| FIFO     | 0       | 0.00       |

图本 4 不同类型文件的统计值和百分比



1~971



###### 4.4设置用户 ID 和设置组 ID

与一个进程相关联的 ID 有 6 个或更多，如图 4-5所示。

| 实际用户 1D 实际组 ID              | 我们实际上是谁                 |
| ------------------------------- | ------------------------------ |
| 有效用户 ID 有效组 ID 附属组 ID    | 用于文件访问权限检査           |
| 保存的设置用户 ID 保存的设置组 ID | 由 exec 函数保存                 |
| 图 4-5                           | 与每个进程相关联的用户 ID 和组 ID |

•实际用户 1D 和实际组 ID 标识我们究竟是谁。这两个字段在登录时取自口令文件中的登 录项。通常，在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们， 8.11节将说明这些方法。

•有效用户 ID、有效组 ID 以及附属组 ID 决定了我:们的文件访问权限，下一节将对此进行 说明(我们已在 1.8节中说明了附属组 ID)。

•保存的设置用户 ID 和保存的设置组 ID 在执行一个程序时包含了有效用户 ID 和有效组 ID 的副本，在 8.11节中说明 setuid 函数时，将说明这两个保存值的作用。

在 P0SIX.1 2001年版中，要求这些保存的 ID。在早期 POSIX 版本中，它们是可选的。一个 应用程序在编译时可测试常 f_POSIX_SAVED_IDS，或在运行时以参教_SC_SAVED_IDS调

；用函数 sysconf，以判断此实现是否支持这一功能。

通常，有效用户 ID 等于实际用户 ID，有效组 ID 等于实际组 ID。

每个文件有一个所有者和组所有者，所有者由 stat 结构中的 st_uid指定，组所有者则由 1^1 st_gid 指定。

当执行一个程序文件时，进程的有效用户 ID 通常就是实际用户 ID，有效组 ID 通常是实际组 ID。但是可以在文件模式字(strode)中设置一个特殊标志，其含义是“当执行此文件时，将 进程的有效用户 ID 设置为文件所有者的用户 ID (st_uid) ”。与此相类似，在文件模式字中可 以设置另一位，它将执行此文件的进程的有效组 ID 设置为文件的组所有者 ID (St_gid)o在文 件模式字中的这两位被称为设置用户 ID (set-user-ID)位和设置组 ID (set-group4D)位。

例如，若文件所有者是超级用户，而且设置了该文件的设置用户 ID 位，那么当该程序文件

由一个进程执行时，该进程具有超级用户权限。不管执行此文件的进程的实际用户 ID 是什么， 都会是这样。例如，UNIX系统程序 paSSwd（l）允许任一用户改变其口令，该程序是一个设置用 户 ID 程序。因为该程序应能将用户的新口令写入口令文件中（一般是/etc/passwd或/etc/ shadow），而只有超级用户才具有对孩文件的写权限，所以需要使用设置用户 ID 功能。因为运 行设置用户 ID 程序的进程通常会得到额外的权限，所以编写这种程序时要特别谨慎。第 8 章将 更详细地讨论这种类型的程序。

再回到 stat 函数，设置用户江＞ 位及设置组 ID 位都包含在文件的 st_mode值中。这两位 可计别用常量 S_ISUID和 S_ISGID测试。


4.5文件访问权限

strode值也包含了对文件的访问权限位。当提及文件时，指的是前面所提到的任何类型的 文件。所有文件类型（目录、字符特别文件等）都有访问权限（access permission）.，很多人认为 只有普通文件有访问权限，这是一种误解。

每个文件有 9 个诂问权限位，可将它们分成 3 类，见图 4-6。

| st_mode 屏厳 | 含义     |
| ------------ | -------- |
| S_IRUSR      | 用户读   |
| S_IWUSR      | 用户写   |
| S IXUSR      | 用户执行 |
| S_IRGRP      | 组读     |
| S_IWGRP      | 组写     |
| S IXGRP      | 组执行   |
| S_IROTH      | 其他读   |
| S_IWOTH      | 其他写   |
| S IXOTH      | 其他执行 |

图 4-6 9个访问权限位，取自＜sys/stat.h＞

在图 4-6前 3 行中，术语用户指的是文件所有者（owner）。chmod（l）命令用于修改送 9 个权 限位。该命令允许我们用 u 表示用户（所有者），用 g 表示组，用 o 表示其他。有些书把这 3 种 用户类型分别称为所有者、组和世界。这会造成混乱，因为 chmod 命令用 o 表示其他，而不是间 所有者。我们将使用术语用户、组和其他，以便与 chmod 命令保持一致。

图 4-6中的 3 类访问权限（即读、写及执行）以各种方式由不同的函数使用。我们将这些不 同的使用方式汇总在下面。当说明相关函数时，再进一步讨论。

•第一个规则是，我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包 括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位 常被称为搜索位的原因。

例如，力了打开文件/usr/include/stdio.h，需要射目录/、/usr 和/usr/include 具有执行权限。然后，需要具有对文件本身的适当权限|这取决于以何种模式打开它（只 读、读-写等）。

如果当前目录是/usr/include，那么为了打开文件 stdio.h，需要对当前目录有执行 权限。送是隐含当前目录的一个示例。打开 stdio.h文件与打开./stdio.h作用相同。

注意，对于目录的读权限和执行权限的意义是不相同的。读权限允许我们读目录，获得在 该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时， 对读目录的执行权限使我们可通过该目录（也就是搜索该目录，寻找一个特定的文件名）。 引用隐含目录的另一个例子是，如果 PATH 环境变量（8.10节将对其进行说明）指定了~ 个我们不具有执行权限的目录，那么 shell 绝不会在该目录下找到可执行文件。

•对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作 c•这与 open 函数的 O_RDONLY和 O_RDWR标志相关。

•对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作。这与 open 函数的 O_WRONLY和 O_RDWR标志相关。

•为了在 open 函数中对一个文件指定 O_TRUNC标志，必须对该文件具有写权限。

•为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限。

•为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本 身则不需要有读、写权限。

•如果用 7 个 exec 函数（见 8.10节）中的任何一个执行某个文件，都必须对该文件具有 晒    执行权限。该文件还必须是一个普通文件。

进程每次打开、创建或删除一个文件时，内核就进行文件访问权限测试，而这种测试可能涉 及文件的所有者（st_uid和 st_gid）、进程的有效 ID （有效用户 ID 和有效组 ID）以及进程的 附属组 ID （若支持的话两个所有者 ID 是文件的性质，而两个有效 ID 和附属组 ID 则是进程 的性质。内核进行的测试具体如下。

（1）    若进程的有效用户 ID 是 0 （超级用户），则允许访问。这给予了超级用户对整个文件系 统进行处理的最充分的自由。

（2）    若进程的有效用户 ID 等于文件的所有者 ID （也就是进程拥有此文件），那么如果所有者 适当的访问权限位被设置，则允许访问；否则拒绝访问。适当的访问权限位指的是，若进程为读 而打开该文件，则用户读位应为 1；若进程为写而打开该文件，则用户写位应为 1:若进程将执行 该文件，则用户执行位应为 1。

（3）    若进程的有效组 ID 或进程的附属组 ID 之一等于文件的组 ID，那么如果组适当的访问权 限位被设置，则允许访问：否则拒绝访问。

（4）    若其他用户适当的访问权限位被设置，则允许访问；否则拒绝访问。

按顺序执行这 4 步。注意，如果进程拥有此文件（第 2 步），则按用户访问权限批准或拒绝 该进程对文件的访问——不查看组访问权限。类似地，若进程并不拥有该文件。但进程属于某个 适当的组，则按组访问权限批准或拒绝该进程对文件的访问——不査看其他用户的访问权限。

4.6新文件和目录的所有权

在第 3 章中讲述用 open 或 creat 创建新文件时，我们并没有说明赋予新文件的用户 ID 和 组 ID 是什么。4.21节将说明 mkdir 函数，此时就会了解如何创建一个新目录。关于新目录的所 有权规则与本节将说明的新文件所有权规则相同。

新文件的用户 ID 设置为进程的有效用户 ID。关于组 ID, POSIX.1允许实现选择下列之一作 为新文件的组 ID。

（1）新文件的组 ID 可以是进程的有效组 ID。

（2）新文件的组 ID 可以是它所在目录的组 ID。

"011    | FreeBSD 8.0和 Mac OS X 10.6.8总是使用目录的组 1D 作为新文件的组 IDd 有些 Linux 文件

j系统使用 mount（l）命令选项允许在 POSEX.I提出的两种选项中进行选择。对于 Linux 3.2.0和 i Solaris 10，默认情况下，新文件的组 ID 粗决于它所在的目录的设置组 ID 位是否枝设置。如果该目录的

这一位已经被设置，则新文件的组 ID 设置为目录的组 ID；否则新文件的组 ID 设置为进程的有效组 ID。

使用 POSIX.1所允许的第二个选项（继承目录的组 ID）使得在某个目录下创建的文件和目录 都具有该目录的组 ID。于是文件和目录的组所有权从该点向下传递。例如，在 Linux 的/var/mail 目录中就使用了途种方法。

；    正如前面提到的，这种设置组所有权的方法是 FreeBSD 8.0和 Mac OS X 10.6.8系统获认的，

=但对于 Linux 和 Solaris 则是可选的。在 Linux 3.2.0和 Solaris 10之下，必须使设置组 1D 位起作用。 I更进一步，为使这种方法能够正常工作，ntkdir函数要自动地传递一个目录的设置组 ID 位（4.21 j节将说明 mkdir 就是这样做的）。

##### 4.7 函数 access 和 faccessat

正如前面所说，当用 open 函数打开一个文件时，内核以进程的有效用户 ID 和有效组 ID 为基础执行其访问权限测试。有时，进程也希望按其实际用户 ID 和实际组 ID 来测试其访问能 力。例如，当一个进程使用设置用户 ID 或设置组 ID 功能作为另一个用户（或组）运行时，就 可能会有这种需要。即使一个进程可能已经通过设置用户 ID 以超级用户权限运行，它仍可能想 验证其实际用户能否访问一个给定的文件。access和 faccessat 函数是按实际用户 ID 和实 际组 ID 进行访问权限测试的。（该测试也分成 4 步，这与 4.5节中所述的一样，但将有效改为 实际。〉

\#include <unistd.h>

int access （const char * pathname, int mode、；

int faccessat （int fd, const char * pathname, int mode, int flag、；

两个函数的返回值：若成功，返回 0；若出错，返回-1

其中，如果测试文件是否已经存在，motfe就为 F_OK:否则 mode 是图 17 中所列常量的按位或。

| mode | 说明         |
| ---- | ------------ |
| R_OK | 測试读权限   |
| W_OK | 测试写权限   |
| X OK | 测试执行权限 |

图 4-7 access函数的 wocfe 标志，取自<unistd.h> faccessat函数与 access 函数在下面两种情况下是相同的：一种楚 pcrZ/wwme参数为绝对

路径，另一种是/£/参数取值为 AT_FDCWD而 pW 肺做参数为相对路径。否则，faccessat计 算相对于打开目录（由片参数指向）的 pathname。

脚 g 参数可以用于改变 faccessat 的行为，如果 y/ag设置为 AT_EACCESS，访问检查用的 是调用进程的有效用户 ID 和有效组 ID，而不是实际用户 ID 和实际组 ID。

■实例

图 4~8显示了 access函数的使用方法。

\#include "apue.h"

♦include <fcntl.h>

int

main(int argc, char *argv[])

f

if (argc != 2)

err_quit("usage: a.out <pathname>"); if {access(argv[l], R_OK) < 0)

err_ret("access error for %s", argv[l])；

else

printf("read access 0K\n"); if {open(argv[l]( O_RDONLYJ < 0)

err_ret("open error for %s", argv[l]);

else

printf("open for reading 0K\n"); exit(0);

J

图 4-8 access函数实例

下面是该程序的示例会话:

$ Is -1 a.out

15945 Nov 30 12:10 a.out



-rwxrwxr-x 1 sar $ ./a.out a.out read access OK open for reading OK $ Is -1 /ate/shadow

1315 Jul 17 2002 /etc/shadow

Permission denied Permission denied

成为超级用户 输入超级用户口令 将文件用户 ID 改为 root 并打开设置用户 ID 位 检査所有者和 SU1D 位 15945 Nov 30 12:10 a.out 恢复为正常用户

Permission denied



-r--------1 root

$ ./a.out: /etc/shadow

access error for /etc/shadow：

open error for /etc/shadow:

$ su

Password：

\#    chown root a.out

\#    chnod u+s a.out

\#    Is -1 a.out

-rwsrwxr-x 1 root

\#    axit

$ ./a.out /etc/shadow

_    access error for /etc/shadow:

画 open for reading OK

在本例中，尽管 open 函数能打开文件，但通过设置用户辽）程序可以确定实际用户不能正常 读指定的文件。

在上例及第 8 章中，我们有时要成为超级用户，以便演示某些功能是如何工作的。如果你使 用多用户系统，但无超级用户权限，那么你就不能完整地重复这些实例。

##### 4,8 函数 umask

至此我们已说明了与每个文件相关联的 9 个访问权限位，在此基础上我们可以说明与每个进 程相关联的文件模式创建屏蔽字。

umask函数为进程设置文件模式创建屏蔽字，并返回之前的值。（这是少数几个没有出错返 回函数中的一个。）

| #include <sys/stat.h>         |                                  |
| ----------------------------- | -------------------------------- |
| rnode_t umask (mode_t cmask); | 返回值：之前的文件模式创建屏蔽字 |

其中，参数 cmoyA 是由图 4-6中列出的 9 个常量（S_IRUSR、S_IWUSR等）中的若干个按位 “或”构成的，

在进程创建一个新文件或新目录时，就一定会使用文件模式创建屏蔽字（回忆 3.3节和 3.4 节，在那里我们说明了 open和 creat 函数。这两个函数都有一个参数也，它指定了新文件 的访问权限位〉。我们将在 4.21节说明如何创建一个新目录。在文件模式创建屏蔽字中为 1 的位， 在文件 mode 中的相应位一定被关闭。

I实例

图 4-9程序创建了两个文件，创建第一个时，umask值为 0，创建第二个时，umask值禁止 所有组和其他用户的访问权限。

tinclude "apue.h"

\#include <fcntl.h>

\#define RWRWRW （S_IRUSRIS_IWUSR 丨 S_IRGRPIS_IMGRPIS_IROTH|S_IWOTH） int

main(void)

umask(0);

if (creat("foo", RWRWRW) < 0)

err_sys("creat error for foo");

umask (S_IRGRP I S_IWGRP I S_IROTH | S_IWOTH); if (creat("bar", RWRWRW) < 0)

err_sys{"creat error for bar"); exit(0);

}

图 4-9 umask函数实例

若运行此程序可得如下结果，从中可见访问权限位是如何设置的。    E04]

$ umask    先打印当前文件模式创建屏蔽字

002

$ ./a.out

$ Is -1 foo bar

-rw-------1 sar    0 Dec 7 21:20 bar

-rw-rw-rw- 1 sar    0 Dec 7 21:20 foo

5 wnaafc    观察文件模式创建屏蔽字是否更改

002 ■-

UNIX系统的大多数用户从不处理他们的 umask 值。通常在登录时，由 shell 的启动文件设

置一次，然后，再不改变。尽管如此，当编写创建新文件的程序时，如果我们想确保指定的访问 权限位已经激活，那么必须在进程运行时修改 umask 值。例如，如果我们想确保任何用户都能 读文件，则应将 umask 设置为（K否则，当我们的进程运行时，有效的 umask 值可能关闭该权 限位，

在前面的示例中，我们用 shell 的 umask 命令在运行程序的前、后打印文件模式创建屏蔽字。 从中可见，更改进程的文件模式创建屏蔽字并不影响其父进程（常常是 shell）的屏蔽字。所有 shell 都有内置 umask 命令，我们可以用该命令设置或打印当前文件模式创建屏蔽字。

用户可以设置 umask 值以控制他们所创建文件的默认权限。该值表示成八进制数，一位 代表一种要屏蔽的权限，这示于图 4-10中。设置了相应位后，它所对应的权限就会被拒绝。 常用的几种 umask 值是 002、022和 027。002阻止其他用户写入你的文件，022阻止同组 成员和其他用户写入你的文件，027阻止同组成员写你的文件以及其他用户读、写或执行你的 文件。

| 屏薮位 | 含义     |
| ------ | -------- |
| 0400   | 用户读   |
| 0200   | 用户写   |
| 0100   | 用户执行 |
| 0040   | 组读     |
| 0020   | 组写     |
| 0010   | 组执行   |
| 0004   | 其他读   |
| 0002   | 其他写   |
| 0001   | 其他执行 |

图 4-10 umask文件访问权限位

Single UNIX Specification要求 shell 应该支持符号港式的 umask 命令。与八进制格式不同， 符号格式指定许可的权限（即在文件创建屏蔽字中为 0 的位）而非拒绝的权限（即在文件创建屏 蔽字中为丨的位）。下面显示了两种格式的命令。

S umask    先打印当前文件模式创建屏蔽字

002

$ umask    -S    打印符号格式

u=rwx,g=rwx, o=rx

$ uoask    027    更改文件摸式创建屏葱字

$ umask    -S    打印符号格式

u=rwx,g=rx,o=

##### 4-9 函数 chmod、fchmod 和 f chmodat

chmod、f chmod和 f chmodat这 3 个函数使我们可以更改现有文件的访问权限。

\#include <sys/stat.h〉

int chmod (const char * pathname, mode_t mode);

int fchmod(int fd, mode_t mode、；

int fchmodat (int fd, const char ★ pathname, mode_t mode, int flag)；

3个函数返回值：若成功。返回 0；若出错，返回-1

chmod函数在指定的文件上进行操作，而 fchmod 函数则对已打开的文件进行操作。 fchmodat函数与 chmod 函数在下面两种情况下是相同的：一种是 port/wme参数为绝对路径， 另一种是知参数取值为 AT_FDCWD而/wwTwame参数为相对路轻。否则，fchmodat计算相对于 打开目录（由％参数指向）的加 g 参数可以用于改变 fchmodat 的行为，当设置了 AT_SYMLINK_NOFOLLOW标志时，fchmodat并不会跟随符号链接。

为了改变一个文件的权限位，进程的有效用户 ID 必须等于文件的所有者 ID，或者该进程必 须具有超级用户权限。

参数 mo 也是图 4-11中所示常量的按位或。

| mode    | 说明                        |
| ------- | --------------------------- |
| S_ISUID | 执行时设置用户 ID            |
| S_ISGID | 执行时设置组 ID              |
| S ISVTX | 保存正文（粘着位）          |
| S_IRWXU | 用户（所有者）读、写和执 行 |
| S_IRUSR | 用户（所有者）读            |
| S_IWUSR | 用户（所有者）写            |
| S^IXUSR | 用户（所有者）执行          |
| S_IRWXG | 组读、写和执行              |
| S_IRGRP | 组渎                        |
| S_IWGRP | 组写                        |
| S IXGRP | 组执行                      |
| S_IRWXO | 其他读、写和执行            |
| S_IROTH | 其他读                      |
| S„IWOTH | 其他写                      |
| S IXOTH | 其他执行                    |

图 4-11 chmod 函数的 mode 常量，取自 <sys/stat .h>

注意，在图 4-11中，有 9 项是取自图 4-6中的 9 个文件访问权限位。我们另外加了 6个，它 们是两个设置 ID 常量（S_ISUID和 S_ISGID）、保存正文常量（S_ISVTX）以及 3 个组合常量 （S_IRWXU> S_IRWXG 和 S_IRWXO）»

保存正文位（S.ISVTX）不是 POSIX.1的一部分。在 Single UNIX Specification中，它被定义 在 XSI 扩展中。我们在下一节说明其目的。

-实例

为了演示 umask 函数，我们在前面运行了图 4-9程序，先让我们回忆文件 foo 和 bar 当时 的最后状态：

$ Is -1 foo bar

-rw-------1 sar

-rw-rw-rw- 1 sar



0 Dec 7 21:20 bar 0 Dec 7 21:20 foo



图 4-12的程序修改了这两个文件的模式，

\#include "apue.h"

int

main(void)

{

struct stat statbuf;

/* turn on set-group-ID and turn off group-execute */

if (stat("foo", fistatbuf) < 0)

err_sys("stat error for foo");

if {chmodC'foo", (statbuf.st_mode & ~S_IXGRP) | S_ISGID) < 0) err_sys("chmod error for foo");

/* set absolute mode to '*rw-r--r--" */

if {chmod{"bar", S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) err_sys("chmod error for bar");

exit(0);

J

图 4-12 chmod函数实例

在运行图 4-12程序后，这两个文件的最后状态是：

S Is -1 foo bar

-rw-r--r-- 1 sar    0 Dec 7 21:20 bar

-rw-rwSrw- 1 sar    0 Dec 7 21:20 foo

在本例中，不管文件 bar 的当前权限位如何，我们都将其权限设置为一个绝对值。对文件 foo, 我们相对于其当前状态设置权限。为此，先调用 stat 获得其当前权限，然后修改它。我们显式 地打开了设置组 ID 位、关闭了组执行位。注意，Is命令将组执行权限表示为 S，它表示设置组

闹 ID 位已经设置，同时，组执行位未设置。

在 Solaris 中，Is命令置示 1 而非 S，这表明对该文件可以加强制性文件或记录锁。这只能

；用于普通文件，14.3节将更详细地讨论这一点。

最后还要注意，在运行图 4-]2程序后，Is命令列出的时间和日期并没有改变。在 4.19节中， 我们会了解到 chmod 函数更新的只是 i 节点最近一次被更改的时间。按系统默认方式，Is -1 列出的是最后修改文件内容的时间。

chmod函数在下列条件下自动清除两个权限位。

• Solaris等系统对用于普通文件的粘着位賦予了特殊含义，在这些系统上如果我们试图设 置普通文件的粘着位（S_ISVTX），而且又没有超级用户权限，那么 morfe 中的粘着位自 动被关闭（我们将在下一节说明粘着位）。这意味着只有超级用户才能设置普通文件的粘 着位。这样做的理由是防止恶意用户设置粘着位，由此影响系统性能。

在 FreeBSD 8.0和 Solaris 10中，只有超级用户才能对普通文件设置粘着位。Linux 3.2.0 ；和 Mac OS X 10.6.8对设置粘着位并无此种限制，其原因是，粘着位对 Linux 普通文件并无意 i义。虽然粘着位对 FreeBSD 的普通文件也无意义，但还是阻止除超级用户以外的任何用户对 *普通文件设置该位。

•新创建文件的组 ID 可能不是调用进程所属的组。回忆一下 4.6节，新文件的组 ID 可能是父目录的组 ID。特别地，如果新文件的组江＞ 不等于进程的有效组 ID 或者进 程附属组 ID 中的一个，而且进程没有超级用户权限，那么设置组 ID 位会被自动被 关闭。这就防止了用户创建一个设置组 ID 文件，而该文件是由并非该用户所属的组 拥有的。

这种情况下，FreeBSD 8.0对试困设置组 ID 的操作肯定会返回失败，而其他的系统则无 声息地关闭该位，但不会对试图改变文件访问权限的操作直接做失败处理。

FreeBSD 8.0、Linux 3.2.0、Mac OS X 10.6.8 和 Solaris 10 增加了另一个安全性功能以试 图阻止误用某些保护位。如果没有超级用户权限的进程写一个文件，则设置用户 ID 位和设 置组 ID 位会被自动清除。如果恶意用户找到一个他们可以写的设置组 ID 和设置用户 ID 文

:件，即使可以修改此文件，他们也没有对该文件的特殊权限。

###### 4.10粘着位

SJESVTX位有一段有趣的历史，在 UNIX 尚未使用请求分页式技术的早期版本中，S_ISVTX 位被称为粘着位(sticky bit)。如果一个可执行程序文件的这一位被设置了，那么当该程序第一次 被执行，在其终止时，程序正文部分的一个副本仍被保存在交换区(程序的正文部分是机器指令)。® 这使得下次执行该程序时能较快地将其装载入内存。其原因是：通常的 UNIX 文件系统中，文件 的各数据块很可能是随机存放的，相比较而言，交换区是被作为一个连续文件来处理的。对于通 用的应用程序，如文本编缉程序和 C 语言编译器，我们常常设置它们所在文件的粘着位。自然地， 对于在交换区中可以同时存放的设置了粘着位的文件数是有限制的，以免过多占用交换区空间，

但无论如何这是一个有用的技术。因为在系统再次自举前，文件的正文部分总是在交换区中，这 正是名字中“粘着”的由来。后来的 UNIX 版本称它为保存正文位(saved-textbit)，因此也就有 了常量 S_ISVTX。现今较新的 UNIX 系统大多数都配置了虚拟存储系统以及快速文件系统，所以 不再需要使用这种技术。

现今的系统扩展了粘着位的使用范围，Single UNIX Specification允许针对目录设置粘着位。

如果对一个目录设置了粘着位，只有对读目录具有写权限的用户并且满足下列条件之一，才能删 除或重命名垓目录下的文件：

•拥有此文件；

•拥有此目录：

•是超级用户。

目录/tmP和/var/tmp是设置粘着位的典型候选者——任何用户都可在这两个目录 中创建文件》任一用户(用户、组和其他)对这两个目录的权限通常都是读、写和执行。

但是用户不应能删除或重命名属于其他人的文件，为此在这两个目录的文件模式中都设置 了粘着位。

POSIX.1没有定义保存正文位，Single UNIX Specification将它定义在 XSI 扩展部分。FreeBSD 8.0. Linux 3.2.0、Mac OS X 10.6.8 和 Solaris 10 则支持这种功能。

在 Solaris 10中，如果对普通文件设置了粘着位，那么它就具有特殊含义。在这种恃况下，如 果任何执行位都没有设 I，那么操作系统就不会缓存文件内容。

##### 4.11 函数 chown、fchown、fchownat 和 lchown

下面几个 chown 函数可用于更改文件的用户 ID 和组 ID。如果两个参数 owner■或 gmup 中的 任意一个是-1，则对应的 ID 不变。

\#include <unistd.h>

int chown (const char * pathname, uid_t owner, gid_t group)； int fchown (int fd, uid_t owner, gid_t group);

int fchownat (int fd, const char ★ pathname, uid_t owner, gid_t group, int flag}; int lchown (const char * pathname, uid_t owner, gid_t group);

4个函数的返回值：若成功，返回 0:若出错，返回-1

除了所引用的文件是符号链接以外，这 4 个函数的操作类似。在符号链接情况下，lchown 和 fchownat (设置了 AT_SYMLINK_NOFOLLOW标志)更改符号链接本身的所有者，而不是该 符号链接所指向的文件的所有者。

fchown函数改变片参数指向的打开文件的所有者，既然它在一个已打开的文件上操作，就 不能用于改变符号链接的所有者。

fchownat函数与 chown 或者 lchown 函数在下面两种情况下是相同的：一种是 参数为绝对路径，另一种是炎参数取值为 AT_FDCWD而 par/wwme参数为相对路径。在这两种情 况下，如果_/?呀参数中设置了 AT_SYMLINKJWFOLLOW标志，fchownat与 lchown 行为相同， 如果 flag 参数中清除了 AT_SYMLXNK_NOFOLLOW标志，则 fchownat 与 chown 行为相同。如 果只参数设置为打开目录的文件描述符，并且汝 zwme 参数是一个相对路径名，fchownat函 数计算相对于打开目录的 pathname o

基于 BSD 的系统一直规定只有超级用户才能更改一个文件的所有者。这样做的原因是防止用 户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。System V则允许任一用户更改他们 所拥有的文件的所有者。

'    按照_POSIX_CHOWN_RESTRICTED的值，POSIX.1允许在这两种形式的操作中选用一种。

对于 Solaris 10，此功能是个配置选项，其默认值是施加限制。而 FreeBSD 8.0、Linux 3.2.0

和 Mac OS X 10.6.8则总对 chown 施加限制。

回忆 2.6节，_POSIX_CHOWN_RESTRICTED常量可选地定义在头文件<unistd.h>中，而且 总是可以用 pathconf 或 fpathconf 函数进行查询£■此选项还与所引用的文件有关一可在每个 文件系统基础上，使该选项起作用或不起作用，在下文中，如提及“若_POSIX_CHOWN_ RESTRICTED生效”，则表示“这适用于我们正在谈及的文件”，而不管该实际常量是否在头文件 中定义。

g_POSIX_CHOWN_RESTRICTED对指定的文件生效，则

(1)    只有超级用户进程能更改该文件的用户 ID:

(2)    如果进程拥有此文件(其有效用户 ID 等于该文件的用户 ID)，参数 owner 等于-1或文 件的用户 ID，并且参数等于进程的有效组 ID 或进程的附属组 ID 之一，那么一个非超级用 户进程可以更改该文件的组 ID。

这意味着，有效时，不能更改其他用户文件的用户 ID。你 可以更改你所拥用的文件的组 ID，但只能改到你所属的组，

E3    如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户 ID 位和设置组

ID位都被清除。

###### 4.12文件长度

Stat结构成员 st_siZe表示以字节为单位的文件的长度。此字段只对普通文件、目录文件 和符号链接有意义。

FreeBSD 8.0、Mac OS X 10.6.8和 Solaris 10对管道也定义了文件长度，它表示可从该管道中 读到的字节数，我们将在丨 5.2中讨论管道。

对于普通文件，其文件长度可以是 0，在开始读这种文件时，将得到文件结束（end-of-file）指示。 対于目录。文件长度通常是一个数（如 16 或 512）的整倍数，我们将在 4.22节中说明读目录操作。

对于符号链接，文件长度是在文件名中的实际字节数。例如，在下面的例子中 I 文件长度 7 就是路径名 usr/lib的长度：

Irwxrwxrwx 1 root    7 Sep 25 07:14 lib -> usr/lib

（注意，因为符号链接文件长度总是由 st_Size指示，所以它并不包含通常 C 语言用作名字结尾 的 null 字节。）

现今，大多数现代的 UNIX 系统提供字段 31：_1311^1汗和 51：_1010<^5«>其中，第一个是対 文件 I/O较合适的块长度，第二个是所分配的实际 512 字节块块数。回忆 3.9节，其中提到了当 我们将于读操作时，读一个文件所需的时间量最少。为了提高效率，标准 VO 库 （我们将在第 5 章中说明）也试图一次读、写字节。

应当了解的是，不同的 UNIX 版本其 st_blocks所用的单位可能不是 512 字节的块。使用 此值并不是可移植的。

文件中的空洞

在 3.6节中，我们提及普通文件可以包含空洞。在图 3-2程序中例示了这一点。空洞是由所 设置的偏移量超过文件尾端，并写入了某些数据后造成的。作为一个例子，考虑下列情况：

$ la -1 coca

-rw-r--r-- 1 sar    8483248 Nov 18 12:18 core

$ du -» core 212    core

文件 core 的长度稍稍超过 8 MB，可是 du 命令报告该文件所使用的磁盘空间总量是 272 个 512 字节块（即 139264 字节）。很明显，此文件中有很多空洞。

在很多 BSD 类系统上，du命令报告的是 1024 字节块的块数，Solaris报告的是 512 字节块的 块数。在 Linux 上。报告的块数单位取决于是否设置了环境变量 POSIXLY_CORRECT。当设置了 该环境变量，du命令报告的是 1 024字节块的块数；没有设置该环境变量时，du命令报告的是 512字节块的块數。

正如我们在 3.6节中提及的，对于没有写过的字节位置，read函数读到的字节是 0。如果执 行下面的命令，可以看出正常的 I/O操作读整个文件长度：    EB

$ wc -o core

8483248 core

带-c选项的 wc（l）命令计算文件中的字符数（字节）。

如果使用实用程序（如 cat（l））复制这个文件，那么所有这些空洞都会被填满，其中所有实 际数据字节皆填写为 0。

$ cat core > core.copy

$ Is -1 core*

-rw-r--r-- 1 sar    8483248 Nov 18 12:18 core

-rw-rw-r-- 1 sar    8483248 Nov 18 12:27 core.copy

5 du -s core*

272 core

16592 core.copy

从中可见，新文件所用的实际字节数是 8 495 104 （512x16 592）。此长度与 Is 命令报告的长度不 同，其原因是，文件系统使用了若干块以存放指向实际数据块的各个指针。

有兴趣的读者可以参阅 Bach［1986］的 4.2节、McKusick等［1996】的 7.2节和 7.3节（或 McKusick 和 NeviUe-Neil［2005］的 8.2 节和 8.3 节）、McDougall 和 Mauro［2007］的 15.2 节以及 Singh［2006］的 第 12 章，以更详细地了解文件的物理结构。

###### 4.13文件截断

有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为 o 是一个特 例，在打开文件时使用 O_TRUNC标志可以做到这一点。为了截断文件可以调用函数 truncate 和 ftruncateo

\#include <unistd.h>

int truncate {const char * pathname, off_t length); int ftruncate (int fd, of f_t length);

两个函数的返回值：若成功，返回 0；若出错，返回

这两个函数将一个现有文件长度截断为 length。如果该文件以前的长度大于 length，则超过 length以外的数据就不再能访问。如果以前的长度小于 length，文件长度将増加，在以前的文件 尾端和新的文件尾端之间的数据将读作 0 （也就是可能在文件中创建了一个空洞）。

早于 4.4BSD的 BSD 系统只能用 truncate 函数截短一个文件，不能用它扩展一个文件„

1112-1    Solaris对 fcntl 函数进行了扩展，增加了 F_FREESP，它允许释放一个文件中的任何一部分,

而不只是文件尾端处的一部分。

图 13-6的程序使用了 ftruncate函数，以便在获得对一个文件的锁后，清空该文件。

###### 4.14文件系统

为了说明文件链接的概念，先要介绍 UNIX 文件系统的基本结构。同时，了解 i 节点和指向

i节点的目录项之间的区别也是很有益的。

目前，正在使用的 UNIX 文件系统有多种实现。例如，Solaris支持多种不同类型的磁盘文件 系统：传统的基于 BSD 的 UNIX 文件系统（称为 UFS），读、写 DOS 格式软盘的文件系统（称 为 PCFS），以及读 CD 的文件系统（称为 HSFS）。在图 2-20中，我们已经看到了不同类型文件 系统的一个区别。UFS是以 Berkeley 快速文件系统为基础的。本节讨论该文件系统。

每一种文件系统类型都有它各自的特征，有些特征可能是混淆不清的。例如，大部分 UNIX 文件系统支持大小写敏感的文件名。因此，如果创建了一个名为 file.txt的文件以及另外一 个名为 file.TXT的文件，就是创建了两个不同的文件。在 MacOSX 上，HFS文件系统是大 小写保留的，并且是大小写不敏感比较的。因此，如果创建了一个名为 file.txt的文件，当 你再创建名为 file.TXT的文件时，就会覆盖原来的 file.txt文件。但是，保存在文件系统 中的是文件创建时的文件名（即 file.txt，因为是大小写保留的）。事实上，在“f, i, 1, e, t, x, t”这个序列中的大写或小写字母的排列都会在搜索这个文件时得到匹配（大小 写不教感比校 J。因此，除了 file. txt和 file.TXT，我们还可以用 File.txt、fILE.tXt

:以及 FiLe.TxT等名字来访问该文件 o

我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统（见图 4-13）。i岡 节点是固定长度的记录项，它包含有关文件的大部分信息。

磁盘    分区



文件系统



白举块

超级块



分区



分区



柱面组 0



柱面组 1



柱面组 n



| 超级块副本 | 配置信息 | i节点 團 | 块位图 | i节点 | 観块 |
| ---------- | -------- | -------- | ------ | ----- | ---- |
|            |          |          |        |       |      |



| i节点 | i节点 |      | i节点 |
| ----- | ----- | ---- | ----- |
|       |       |      |       |

图 4-13磁盘、分区和文件系统

如果更仔细地观察一个柱面组的 i 节点和数据块部分，则可以看到图 4-14中所示的情况。 注意图 4-14中的下列各点。

•在圉中有两个目录项指向同一个 i 节点。每个 i 节点中都有一个链接计数，其值是指向该 i节点的目录项数。只有当链接计数减少至 0 时，才可删除该文件（也就是可以释放该文 件占用的数据块）。这就是为什么“解除对一个文件的链接”操作并不总是意味着“释放 该文件占用的磁盘块”的原因。这也是为什么删除一■个目录项的函数被称之为 unlink 而不是 delete 的原因。在 stat 结构中，链接计数包含在 st_nlink成员中，其基本 系统数据类型是 nlink_t。这种链接类型称为硬链接。回忆 2.5.2节，其中，POSIX.1常

量 LINK_MAX指定了一个文件链接数的最大值，

图 4-14较详细的柱面组的 i 节点和数据块

•另外一种链接类型称为符号链接（symbolic link）。符号链接文件的实际内容（在数据块 中）包含了该符号链接所指向的文件的名字。在下面的例子中，目录项中的文件名是 3 个字符的字符串 lib，而在该文件中包含了 7个字节的数据 usr/lib：

lrwxrwxrwx 1 root    7 Sep 25 07:14 lib -> urs/lib

该 i 节点中的文件类型是 S_IFLNK，于是系统知道这是一个符号链接。

• i节点包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度和指向文件数 据块的指针等。stat结构中的大多数信息都取自 i 节点。只有两项重要数据存放在目录 项中：文件名和 i 节点编号。其他的数据项（如文件名长度和目录记录长度）并不是本书 关心的=i节点编号的数据类型是 ino_t。

•因为目录项中的 i 节点编号指向同一文件系统中的相应 i 节点，一个目录项不能指向另一 个文件系统的 i 节点。这就是为什么 ln（l）命令（构造一个指向一个现有文件的新目录项） 不能跨越文件系统的原因=我们将在下一节说明 link 函数。

•当在不更换文件系统的情况下为一个文件重命名时，孩文件的实际肉容并未移动，只需 构造一个指向现有 i 节点的新目录项，并删除老的目录项。链接计数不会改变。例如，为 将文件/usr/lib/foo重命名为/usr/foo，如果目录/usr/lib和/usr在同一文件系 统中，则文件 foo 的内容无需移动。这就是 mv（l）命令的通常操作方式。

我们说明了普通文件的链接计数概念，但是对于目录文件的链接计数字段又如何呢？假定我 们在工作目录中构造了一个新目录：

S mfcdic testdic

图 4-15显示丁其结果。注意，该图显式地显示了。和.。目录项。

编号为 2549 的 i 节点，其类型字段表示它是一个目录，链接计数为 2。任何一个叶目录（不 包含任何其他目录的目录）的链接计数总是 2，数值 2 来自于命名该目录（testdir）的目录项

[H5]以及在该目录中的。项。编号为 1267 的 i 节点，其类型字段表示它是一个目录，链接计数大于或 等于 3。它大于或等于 3 的原因是，至少有 3 个目录项指向它：一个是命名它的目录项（在图 4-15 中没有表示出来），第二个是在该目录中的。项，第三个是在其子目录 testdir 中的.。项。注意， 在父目录中的每一个子目录都使该父目录的链接计数增加 I。

图 4-15创建了目录 testdir 后的文件系统实例

这种格式与 UNIX 文件系统的经典格式类似，在 Bach［1986］的第 4 章中对此进行了详细说明。关于 伯克利快速文件系统对此所做的更改请参阅 McKusick 等［1996］的第 7 章以及 McKusidc 和 NeviUe*Neil［2005］中的第 8 章。关于 UFS（伯克利快速文件系统的 Solaris 版）的详细情况，请参见 McDougall 和 Mauro［2007］的第 15 章。关于 Mac OS X使用的 HFS 文件系统格式，请参阅 Singh［2006］的第 12 章。

##### 4-15 函数 link' linkat、unlink、unlinkat 和 remove

如上节所述，任何一个文件可以有多个目录项指向其 i 节点，创建一个指向现有文件的链接 的方法是使用 link 函数或 linkat 函数。

\#include <unistd.h>

int link (const char *existing)atht const char *newpath);

int linkat (int efd, const char *existingpath, int nfd, const char *ncwpath, int flag);

两个函数的返回值：若成功，返回 0:若出错，返回-1

这两个函数创建一个新目录项 nenpcr 汝，它引用现有文件如果已经存 在，则返回出错，只创建中的最后一个分量，路径中的其他部分应当已经存在。

对于 linkat 函数，现有文件是通过咖和 existingpath 参数指定的，新的路径名是通过；响 和 newpa 决参数指定的。默认情况下，如果两个路径名中的任一个是相对路径，那么它需要通过 相对于对应的文件描述符进行计算。如果两个文件描述符中的任一个设置为 AT_FDCWD，那么相 应的路径名（如果它是相对路径）就通过相对于当前目录进行计算。如果任一路径名是绝对路径，

相应的文件描述符参数就会被忽略。

当现有文件是符号链接时，由参数来控制 linkat 函数是创建指向现有符号链接的链接还 是创建指向现有符号链接所指向的文件的链接。如果在#堪参数中设置了 AT_SYMLINK_FOLLOW标 志，就创建指向符号链接目标的链接。如果这个标志被清除了，则创建一个指向符号链接本身的链接。岡

创建新目录项和增加链接计数应当是一个原子操作（请回忆在 3.11节中对原子操作的讨论）。

虽然 POSDC1 允许实现支持跨越文件系统的链接，但是大多数实现要求现有的和新建的两个 路径名在同一个文件系统中。如果实现支持创建指向一个目录的硬链接，那么也仅限于超级用户 才可以这样做。其理由是这样做可能在文件系统中形成循环，大多数处理文件系统的实用程序都 不能处理这种情况（4.17节将说明一个由符号链接引入循环的例子〉。因此，很多文件系统实现 不允许对于目录的硬链接。

为了删除一个现有的目录项，可以调用 unlink 函数。

\#include <unistd.h>

int unlink (const char * pathname、；

int unlinkat {int fd, const char ★ pathname, int flag);

两个函数的返回值：若成功，返回 0；若出错，返回-1

这两个函数删除目录项，并将由汝 zwme 所引用文件的链接计数减 1。如果对该文件还有其 他链接，则仍可通过其他链接访问该文件的数据。如果出错，则不対该文件做任何更改。

我们在前面已麵及，为了解除对文件的链接，必耐包含该目录项的目录具有写和执行权限。正 如 4.10节所述，如果对该目录设置了粘着位，则対该目录必须具有写权限，并且具备下面三个条件之一：

•拥有该文件：

•拥有该目录：

•具有超级用户权限。

只有当链接计数达到 0 时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内 容——只要有进程打开了该文件，其内容也不能删除，关闭一个文件时，内核首先检査打开该 文件的进程个数；如果这个计数达到 0，内核再去检查其链接计数；如果计数也是 0，那么就删 除该文件的内容。

如果戸如關 e 参数是相对路径名，那么 unlinkat 函数计算相对于由/rf文件描述符参数代 表的目录的路径名。如果/rf参数设置为 AT_FDCWD，那么通过相对于调用进程的当前工作目录来 计算路径名。如果 pa 汝 rnwie 参数是绝对路径名，那么片参数被忽略。

\>/呀参数给出了一种方法，使调用进程可以改变 unlinkat 函数的默认行为。当 AT_ REMOVEDIR E3标志被设置时，unlinkat函数可以类似于 rmdir 一样删除目录。如果这个标志被清除，

unlinkat与 unlink 执行同样的操作。

■实例

图 4-16的程序打开一个文件，然后解除它的链接。执行该程序的进程然后睡眠 15 秒，接着 就终止。

\#include "apue.h"

^include <fcntl.h> int

main(void)

i

if (openC'tempfile", O_RDWR) < 0) err_sys("open error");

if (unlink("tempfile") < 0) err_sys("unlink error");

printf("file unlinked\n"):

图 4-16 打开一个文件，然后 unlink 它



运行该程序，其结果是：

$ Is -1

| -cw~r————             | 1 sar     | 413265408 |
| --------------------- | --------- | --------- |
| $ df /home            |           |           |
| Filesystem            | lK-blocks | Used      |
| /dev/hda4             | 11021440  | 1956332   |
| $ ./a.out £           |           |           |
| 1364                  |           |           |
| $ file unlinked       |           |           |
| la -1 taapfxle        |           |           |
| Is: tempfile: No such | file or ( |           |
| $ df /hoo«            |           |           |
| Filesystem            | lK-blocks | Used      |
| /dev/hda4             | 11021440  | 1956332   |
| $ done                |           |           |
| df /hone              |           |           |
| Filesystem            | lK-blocks | Used      |
| /dev/hda4             | 11021440  | 1552352   |



査看文件大小

Jan 21 07:14 tempfile 检査可用磁盘空间

Available Use% Mounted on 9065108    18% /home

在后台运行图 446 程序 shell打印其进程 ID 解除文件链接 观察文件是否仍然存在 directory    目录项已刪除

检査可用磁盘空间有无变化 Available Use% Mounted on 9065108    18% /home

程序执行结束，关闭所有打开文件 现在，应当有更多可用磁盘空间 Available Use% Mounted on 9469088    15% /home

现在，394.1 MB磁盘空间可用

unlink的这种特性经常被程序用来确保即使是在程序崩溃时，它所创建的临时文件也不会遗

留下来。进程用 open 或 creat 创建一个文件，然后立即调用 unlink，因为该文件仍旧是打开_

的，所以不会将其内容删除。只有当进程关闭该文件或终止时（在这种情况下，内核关闭该进程 所打开的全部文件），该文件的内容才被删除。

卸果 pat/mame是符号链接，那么 unlink 删除该符号链接，而不是删除由该链接所引用的文件。 给出符号链接名的情况下，没有一个函数能删除由垓链接所引用的文件。

如果文件系统支持的话，超级用户可以调用 unlink，其参数指定一个目录，

但是通常应当使用 rmdir 函数，而不使用 unlink 这种方式。我们将在 4.21节中说明 rmdir 函数。

我们也可以用 remove 函数解除对一个文件或目录的链接。射于文件，remove的功能与 unlink相同。对于目录，remove的功能与 rmdir 相同。

^include <stdio.h>

int remove {const char * pathname）;

返回值：若成功，返回 th 若出错，返回-1

ISO C指定 remove 函数删除一个文件，这更改了 UNIX历来使用的名字 unlink，其原因是实 现 C 标准的大多数非 UNIX 系统并不支持文件链接。

##### 4.16 函数 rename 和 renameat

文件或目录可以用 rename 函数或者 renameat 函数进行重命名

\#include <stdio.h>

int rename (const char *oldname, const char *newname);

int renameat (int oldfd, const char *otdname, int newfd, const char *newname};

两个函数的返回值：若成功，返回 0；若出错，返回-1

ISOC对文件定义了 rename函教（C标准不处理目录）。POSIX.1扩展此定义，使其包含了 目录和符号键接。

根据 oW/wme是指文件、目录还是符号链接，有几种情况需要加以说明。我们也必须说明如 果 newname 已经存在时将会发生什么。

（1）    如果指的是一个文件而不是目录，那么为该文件或符号链接重命名。在这种情 况下，如果 rtew/wme已存在，则它不能引用一个目录。如果 new/wme已存在，而且不是一个目 录，则先将该目录项删除然后将 oldname 重命名为 newname^对包含 oldname 的目录以及包含 rtewmwie的目录，调用进程必须具有写权限，因为将更改这两个目录。

（2）    如若 o/t/rtome指的是一个目录，那么为该目录重命名。如果 nevwiflme 已存在，则它必须 引用一个目录，而且该目录应当是空目录（空目录指的是该目录中只有。和.。项）。如果 rtevwwme 存在（而且是一个空目录），则先将其删除，然后将 oZtAwme 重命名为 z/ewzwme。另外，当为一 个目录重命名时，new/jome不能包含 oZi/zwme作为其路授前缀。例如，不能将/usr/foo重命名 为/usr/foo/testdir，因为旧名字（/usr/foo）是新名字的路径前缀，因而不能将其删除。

（3）    如若 oWname 或 newname 引用符号链接，则处理的是符号链接本身，而不是它所引用的

文件。

（4）    不能对。和.。重命名。更确切地说，。和.。都不能出现在 oWrtOTwe 和 wewTiame 的最后部分。

（5）    作为一个特例，如果和 newname 引用同一文件，则函数不做任何更改而成功返回。

如若 ziewwme 已经存在，则调用进程对它需要有写权限（如同删除情况一样）。另外，调用

进程将删除 oWname 目录项，并可能要创建 newwme 目录项，所以它需要对包含 oWname 及包含 newname的目录具有写和执行权限。

捺了当 oldname 或 newname 指向相対路径名时，其他情况下 renameat 函数与 rename 函 数功能相同。如果 oldname 参数指定了相対路径，就相对于 oW/tf参数引用的目录来计算 oldname. 类似地，如果 newname 指定了相对路授，就相对于引用的目录采计算 new/wme。oldfd或 «~人/参数（或两者）都能设置成 AT^FDCWD，此时相对于当前目录来计算相应的路径名。

###### 4.17網链接

符号链接是对一个文件的间接指针，它与上一节所述的硬链接有所不同，硬链接直接指向文 件的 i 节点。引入符号链接的原因是为了避开硬链接的一些限制。

•硬链接通常要求链接和文件位于同一文件系统中。

•只有超级用户才能创建指向目录的硬链接（在底层文件系统支持的情况下）。

对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符

号链接。符弓•链接一般用于将一个文件或整个目录结构移到系统中另一个位置=

当使用以名字引用文件的函数吋，应当了解该函数是否处理符号链接。也就是该函数是否跟

随符号链接到达它所链接的文件。如若该函数具有处理符号链接的功能，则其路径名参数引用由

符号链接指向的文件。否则，一个路径名参数引用链接本身，而不是由该链接指向的文件。图 4-17 列出了本章中所说明的各个函数是否处理符号链接。在图 4-17中没有列出 mkdir. mkinfo, mknod和 rmdir 这些函数，其原因是，当路径名是符号链接时，它们都出错返回。以文件描述 符作为参数的一些函数（如 fstat、fchmod等）也未在该图中列出，其原因是，对符号链接的 处理是由返回文件描述符的函数（通常是 open）进行的。chovrn是否跟随符号链接取决于实现， 在所有现代的系统中，chown函数都跟随符号链接。

符号链接由 4.2BSD引入，chown最初并不跟随符号链接，但在 4.4BSD中情况发生了变化。 I SVR4中的 System V包含了对符号链接的支持，但与原始 BSD 中的行为已大不相同，也实现了 chown函数跟随符号链接。早期 Linux 版本中（Linux 2.1.81以前的版本），chown并不跟随符号

链接。从 2.1.81 版开始，chown 跟随符号链接。FreeBSD 8.0、Mac OS X 10.6.8 和 Solaris 10 中， chown跟随符号链接。所有这些平台都实现了 lchown，它改变符号健接自身的所有权。

| 函数     | 不跟随符号链接 | 跟随符号链接 |
| -------- | -------------- | ------------ |
| access   |                |              |
| chdir    |                | -            |
| chmod    |                |              |
| chown    |                | •            |
| creat    |                | •            |
| exec     |                | •            |
| lchown   | •              |              |
| link     |                |              |
| Istat    | •              |              |
| open     |                | •            |
| opendir  |                | •            |
| pathconf |                | •            |
| readlink | •              |              |
| remove   | •              |              |
| rename   | •              |              |
| stat     |                | •            |
| truncate |                | •            |
| unlink   | •              |              |

图 4-17各个函数对符号链接的处理

图 4-17的一个例外是，同时用 O_CREAT和 O_EXCL两者调用 open 函数。在此情况下，若 路径名引用符号链接，open将出错返回，errno设置为 EEXIST。这种处理方式的意图是堵塞 一个安全性漏洞，以防止具有特权的进程被诱骗写错误的文件。

■实例

使用符号链接可能在文件系统中引入循环。大多数查找路径名的函数在这种情况发生时都将 出错返回，errno值为 ELOOP。考虑下列命令序列：

$ afcdxz £oo

$ touch £oo/a

$ In -a ../foo foo/testdlr $ Is -1 foo

total 0

-rw-r-----1 sar    0

lrwxrwxrwx 1 sar    6



创建一个新目录 创建一个 0 长度的文件 创建一个符号链接



Jan 22 00:16 a

Jan 22 00:16 testdir -> ../foo



这创建了一个目录 foo，它包含了一个名为 a 的文件以及一个指向 foo 的符号链接。在图冬 18 中显示了这种结果，图中以圆表示目录，以正方形表示 一个文件。

![img](UNIXaf83d8a7160b-14.png)



如果我们写一段简单的程序，使用 Solaris 的标准函 数 ftw(3)以降序遍历文件结构，打印每个遇到的路径名，

则其输出是：

foo//a    图 4»18构成循环的符号链接 testdir

foo/testdir

foo/testdir/a

foo/testdir/testdir

foo/testdir/testdir/a

foo/testdir/testdir/testdir

foo/testdir/testdir/testdir/a

(更多行，直至 ftw 出错返回，此时，errno值为 ELOOP)

4.22节提供了我们自己的 ftw 函数版本，它用 lstat 代替 stat 以阻止它跟随符号链接。

| 注意，Linux的 ftw 和 nftw 函数记录了所有看到的目录并避免多次重复处理一个目录，因 j此这两个函数不显示这种程序运行行为。

这样一个循环是很容易消除的。因为 unlink 并不跟随符号链接，所以可以 unlink 文件 foo/testdir。但是如果创建了一个构成这种循环的硬链接，那么就很难消除它，这就是为什 么 link 函数不允许构造指向目录的硬链接的原因(除非进程具有超级用户权限)。

实际上，Rich Stevens在写本节的袭初版本时，在自己的系统上做了一个这样的实验。结果文 件系统变得错误百出。正常的 fsck⑴实用程序不能修复问题。为了修复文件系统，不得不使用

=了并不推荐使用的工具 clri⑻和 dcheck(8)。

对目录的硬链接的需求由来已久，但是使用符号键接和 mkdir 函数，用户就不再需要创建指

:向目录的硬链接了。

用 open 打开文件时，如果传递给 open 函数的路径名指定了一个符号链接，那么 open 跟 随此链接到达所指定的文件。若此符号链接所指向的文件并不存在，则 open 返回出错，表示它

岡不能打开该文件，这可能会使不熟悉符号链接的用户感到迷惑，例如：

$ In -a /no/sueh/filo norfil*    创建一个符号链接

S Is nyfile

myfile    Is査到该文件

$ cat ny£ila    试图査看该文件

cat: myfile: No such file or directory

$ Is —1 nyfila    尝试-1 选项

lrwxrwxrwx 1 sar    13 Jan 22 00:26 myfile -> /no/such/file

文件 myfile 存在，但 cat 却栋没有这一文件，其原因是 myfile 是个符号链接，由该符 号链接所指向的文件并不存在。Is命令的-1选项给我们两个提示：第一个字符是 1，它表示这 是一个符号链接，而->也表明这是一个符号链接。Is命令还有另一个选项-F，它会在符号链接 的文件名后加一个@符号，在未使用-1选项时，这可以帮助我们识别出符号链接。    ■

4.18创建和读取符号链接

可以用 symlink 或 symlinkat 函数创建一个符号链接。

♦include <unistd.h>

int symlink （const char *actualpath, const char *sympath）;

int symlinkat （const char *actualpath, int fd, const char * sympathy ；

_两个函数的返回值：若成功，返回 0:若出错，返回-1

函数创建了一个指向即也的新目录项叹 mport。往仓 1J 建此符号链接时，并不要求 actuaipat/i 已经存在（在上一节结束部分的例子中我们已经看到了这一点）。并且，actu咖油和押 atft 并 不需要位于同一文件系统中。

symlinkat函数与 symlink 函数类似，但吵/叩£油参数根据相射于打开文件描述符引用的 目录（由片参数指定）进行计算。如果 sympath 参数指定的是绝对路径或者/rf参数设置了 AT_FDCWD值，那么 symlinkat 就等同于 symlink 函数。

因为 open 函数跟随符号链接，所以需要有一种方法打开该链接本身，并读该链接中的名字。 readlink和 readlinkat 固数提供了这种功能。

ttinclude <unistd.h>

ssize_t readlink (const char * restrict pathname, char * restrict buf, size_t bufsize);

ssize_t readlinkat (int fd, const char* restrict pathname, char *restrict buf, size_t bufsize};

两个函数的返回值：若成功，返回读取的字节数：若出错，返回-1

两个函数组合了 open、read和 close 的所有操作。如果函数成功执行，则返回读入 Zuz/ 的字节数。在中返回的符号链接的内容不以 null 字节终止。

当 pathname 参数指定的是绝对路径名或者片参数的值为 AT.FDCWD, readlinkat函数的 行为与 readlink 相同。但是，如果为参数是一个打开目录的有效文件描述符并且 p 也知 wme 参 数是相对路径名，则 readlinkat 计算相对于由只代表的打开目录的路径名。

4.19文件的时间

在 4.2节中，我们讨论了 Single UNIX Specification 2008年版如何提高 stat 结构中时间字段 的精度，从原来的秒提髙到秒加上纳秒。每个文件属性所保存的实际精度依赖于文件系统的实现。 対于把时间戳记录在秒级的文件系统来说，纳秒这个字段就会被填充为 0。对于时间戳的记录精 度高于秒级的文件系统来说，不足秒的值被转换成纳秒并记录在纳秒这个字段中。

对每个文件维护 3 个时间字段，它们的意义示于图 4-19中。

| 字段    | 说明                    | 例子          | Is⑴选项 |
| ------- | ----------------------- | ------------- | ------- |
| st_atim | 文件数据的最后访问时间  | read          | -u      |
|         | 文件数据的最后修改时间  | write         | 默认    |
| st ctim | i节点状态的最后更改时间 | chmod-. chown | -c      |

图 4-19与每个文件相关的 3 个时间值

注意，修改时间（st.mtim）和状态更改时间（st.ctim）之间的区别。修改时间是文件内容 最后--次被修改的时间。状态更改时间是该文件的 i 节点最后一次被修改的时间。在本章中我们己 说明了很多影响到 i 节点的操作，如更改文件的访问权限、更改用户江）、更改链接数等，但它们并 没有更改文件的实际内容。因为 i 节点中的所有信息都是与文件的实际内容分开存放的，所以，除 了要记录文件数据修改时间以外，还需要记录状态更改时间，也就是更改 i 节点中信息的时间。

注意，系统并不维护对一个 i 节点的最后一次访问时间，所以 access 和 stat 函数并不更 改这 3 个时间中的任一个。

系统管理员常常使用访问时间来删除在一定时间范围内没有被话问过的文件。典型的例子是删除在 过去一周内没有被访问过的名为 a. out或 core 的文件。f ind（l偷令常被用来进行这种类型的操作。

闹    修改时间和状态更改时间可被用来归档那些内容已经被修改或 i 节点已经被更改的文件。

Is命令按这 3 个时间值中的一个排序进行显示。系统默认（用-1或-t选项调用时）是按文件的 修改时间的先后排序显示。-u选项使 Is 命令按访问时间排序，-c选项则使其按状态更改时间排序。

图 4-20列出了我们已说明过的各种函数对这 3 个时间的作用。回忆 4.14节中所述，目录是 包含目录项（文件名和相关的 i 节点编号）的文件，增加、删除或修改目录项会影响到它所在目 录相关的 3 个时间。这就是在图本 20 中包含两列的原因，其中一列是与该文件（或目录）相关的 3个时间，另一列是与所引用的文件（或目录）的父目录相关的 3 个时间。例如，创建一个新文 件影响到包含此新文件的目录，也影响该新文件的 i 节点。但是，读或写一个文件只影响该文件 的 i 节点，而对目录则无影响。

| 函数                         | 引用的文件或目录 | 所引用文件或目录 的父目录 | 节   | 备注 |      |      |      |                    |
| ---------------------------- | ---------------- | ------------------------- | ---- | ---- | ---- | ---- | ---- | ------------------ |
| a                            | m                | c                         | a    | m    | c    |      |      |                    |
| chmod、 fchmod               |                  |                           |      |      |      |      | 4.9  |                    |
| chown、 fchown               |                  |                           |      |      |      |      | 4.11 |                    |
| creat                        | •                | ■                         |      |      | •    | •    | 3.4  | O.CREAT新文件      |
| creat                        |                  | •                         |      |      |      |      | 3.4  | O_TRUNC现有文件    |
| exec                         |                  |                           |      |      |      |      | 8.10 |                    |
| lchown                       |                  |                           |      |      |      |      | 4.11 |                    |
| link                         |                  |                           |      |      | •    | •    | 4.15 | 第二个参数的父目录 |
| mkdir                        | •                |                           |      |      | •    | •    | 4.21 |                    |
| mkfifo                       | -                |                           |      |      | •    | •    | 15.5 |                    |
| open                         | •                |                           |      |      | •    | •    | 3.3  | O_CREAT新文件      |
| open                         |                  |                           |      |      |      |      | 3.3  | O_TRUNC现有文件    |
| pipe                         | ■                |                           |      |      |      |      | 15.2 |                    |
| read                         | •                |                           |      |      |      |      | 3.7  |                    |
| remove                       |                  |                           |      |      | •    | •    | 4.15 | 刪除文件=unlink    |
| remove                       |                  |                           |      |      | •    | •    | 4.15 | 刪除目录=rmdir     |
| rename                       |                  |                           |      |      | •    | -    | 4.16 | 对于两个参数       |
| rmdir                        |                  |                           |      |      | •    | •    | 421  |                    |
| truncate、ftruncate          |                  | •                         |      |      |      |      | 4.13 |                    |
| unlink                       |                  |                           |      |      | •    | •    | 4.15 |                    |
| utimes、utimensat-. futimens | •                |                           |      |      |      |      | 4^0  |                    |
| write                        |                  |                           |      |      |      |      | 3.8  |                    |

图 4~20各种函数对访问、修改和状态更改时间的作用

(mkdir 和 rmdir 函数蒋在 4.21 节-中说明。utimes、utimensat、futimens 函数将在 下一节中说明。7个 exec 函数将在 8.10节中讨论。第]5章将说明 mkfifo 和 pipe 圉数。)

##### 4-20 函数 futimens、utimensat 和 utimes

—个文件的访问和修改时间可以用以下几个函数更改。futimens和 utimensat 函数可以指 定纳秒级精度的时间戳。用到的数据结构是与 stat 函数族相同的 timespec 结构(见 4.2节)。

\#include <sys/stat.h>

int futimens (int fd, const struct timespec times[2]);

int utimensat (int fd, const char ★path, const struct timespec times 12], int flag);

两个函数返回值：若成功，返回 0；若出错，返回-1

这两个函数的 rt+mes数组参数的第一个元素包含访问时间，第二元素包含修改时间》这两个 时间值是日历时间，如 1.10节所述，这是自特定时间(1970年 1 月 1 日 00:00:00)以来所经过的 秒数。不足秒的部分用纳秒表示。

时间戳可以按下列 4 种方式之一进行指定。

(1)    如果 rimes 参数是一个空指针，则访问时间和修改时间两者都设置为当前时间。

(2)    如果 times 参数指向两个 timespec 结构的数组，任一数组元素的 tv_nsec字段的值 为 UTIME_N0Wt相应的时间戳就设置为当前时间，忽略相应的 tv_sec字段。

(3)    如果 times 参数指向两个 timespec 结构的数组，任一数组元素的 tv_nsec字段的值 为 UTIMEJ3MIT:相应的时间戳保持不变，忽略相应的 tv_sec字段。

(4)    如果 times 参数指向两个 timespec 结构的数组，且 tv_nsec字段的值为既不是 UTIME_NOW也不是 UTIME_OMIT，在这种情况下，相应的时间戳设置为相应的 tv_sec和 tv_nsec字段的值。

执行这些函数所要求的优先权取决于参数的值。

•如果 times 是一个空指针，或者任一 tv_nsec字段设为 UTIME.NOW，则进程的有效用户 ID 必须等于该文件的所有者 ID；进程对该文件必须具有写权限，或者进程是一个超级用户进程。

•如果 times 是非空指针，并且任一 tv_nsec字段的值既不是 UTIME_NOW也不是 UTIME_OMIT，则进程的有效用户 ID 必须等于该文件的所有者 ID，或者进程必须是一个 超级用户进程。对文件只具有写权限是不够的。    Q26]

•如果是非空指针，并且两个字段的值都为 UTIME_OMIT，就不执行任何的 权限检查。

futimens函数需要打开文件来更改它的时间，utimensat函数提供了一种使用文件名更 改文件时间的方法。pathname参数是相对于片参数进行计算的，只要么是打开目录的文件描述 符，要么设置为特殊值 AT_FDCWD (强制通过相対于调用进程的当前目录计算如果 pathname指定了绝对路择，那么及参数被忽略。

utimensat的参数可用于进一步修改默认行为。如果设置了 AT_SYMLINK_NOFOLLOW 标志，则符号链接本身的时间就会被修改(如果路径名指向符号链接)。默认的行为是跟随符号 链接，并把文件的时间改成符号链接的时间。

futimens和 utimensat 函数都包含在 POSIX.1中，第 3 个函数 utimes 包含在 Single

UNIX Specification 的 XSI 扩展选项中。

\#include <sys/time.h>

int utimes (const char ★pathname, const struct timeval times[2]);

函数返回值 i 若成功，返回 0:若出错，返回-1

utimes函数对路径名进行操作。参数是指向包含两个时间戳（访问时间和修改时间） 元素的数组的指针，两个时间戳是用秒和微妙表示的。

struct timeval {

tv_sec; /* seconds */

long tv_usec; /* microseconds */

}；

注意，我们不能对状态更改时间 st_Ctim （i节点最近被修改的时间）指定一个值，因为调 用 utimes 函数时，此字段会被自动更新。

在某些 UNIX 版本中，touch（l）命令使用这些函数中的某一个。另外，标准归档程序 tar（l） 和 epical）可选地调用这些函数，以便将一个文件的时间值设置为将它归档时保存的时间。 ，■实例

图 4-21的程序使用带 O_TRUNC选项的 open 函数将文件长度截断为 0，但并不更改其 i 方问 时间及修改时间。为了做到这一点，首先用 stat 函数得到这些时间，然后截断文件，最后再用 futimens函数重置这商个时间。

tinclude "apue.h"

\#include <fcntl.h>

|1271 int

main(int argc, char *argv[])

{

int    i, fd;

struct stat statbuf; struct timespec times[2]; for (i == 1; i < argc; i++) {

if (stat[argv[i], Sstatbuf) < 0) { /* fetch current times */ err_ret("%s: stat error", argv[i]); continue;

}

if ((fd = open(argv[i], O_RDWR t O_TRUNC)) < 0) { /* truncate */ err_ret("%s: open error", argvfi]); continue;

}

times[0] = statbuf.st_atim; times[1] = statbuf.

if {futimens(fd, times) < 0)    /* reset times */

err_ret("%s: futimens error", argv[i]);

close(fd);

J

exit 0);

图 4-21 futimens函数实例

可以用以下 Linux 命令演示图本 21 中的程序:

$ Is -1 changamod tines

-rwxr-xr-x 1 sar 13792 Jan 22 -rwxr-xr-x 1 sar 13824 Jan 22 $ Is -lu changamod timaa -rwxr-xr-x 1 sar 13792 Jan 22

査看长度和最后修改时间 01:26 changemod 01:26 times

査看最后访问时间 22:22 changemod

-rwxr-xr-x 1 sar 13824 Jan 22

22:22 times

| $ data                                          | 打印当天日期             |
| ----------------------------------------------- | ------------------------ |
| Fri Jan 27 20:53:46 EST                         | 2012                     |
| $ ./a.out changanod tines    运行图 4-21 的程序 |                          |
| $ Is -1 changamod times                         | 检査结果                 |
| -rwxr-xr-x 1 sar                                | 0 Jan 22 01:26 changemod |
| -rwxr-xr-x 1 sar                                | 0 Jan 22 01:26 times     |
| $ Is -lu changamod tiaras                       | 捡査最后访问时间         |
| -rwxr-xr-x 1 sar                                | 0 Jan 22 22:22 changemod |
| -rwxr-xr-x 1 sar                                | 0 Jan 22 22:22 times     |
| $ la -1c changmod tines                         | 检査状态更改时间         |
| -rwxr-xr-x 1 sar                                | 0 Jan 27 20:53 changemod |
| -rwxr-xr-x 1 sar                                | 0 Jan 21 20:53 times     |

正如我们所预见的一样，最后修改时间和最后访问时间未变。但是，状态更改时间则更改为 程序运行时的时间。

##### 4-21 函数 mkdir、mkdirat 和 rmdir

用 mkdir 和 mkdirat 函数创建目录，用 rmdir 画数删除目录。

\#include <sys/stat.h>

int mkdir (const char * pathname, mode_t mode、；

int mkdirat (int fd, const char * pathname, mode_t mode、；

两个函数返回值，若成功，返回 0；若出错，返回-1

这两个函数创建一个新的空目录。其中，。和.。目录项是自动创建的。所指定的文件访问权 限 mode 由进程的文件模式创建屏蔽字修改。

常见的错误是指定与文件相同的 morfe (只指定读、写权限)。但是，对于目录通常至少要设 置一个执行权限位，以允许访问该目录中的文件名(见习题 4.16〉。

按照 4.6节中讨论的规则来设置新目录的用户 ID 和组 ID。

Solaris 10和 Linux 3.2.0也使新目录继承父目录的设置组 ID 位。这就使得在新目录中创建的 文件将继水该目录的组 ID。对于 Linux，文件系统的实现决定是否支持此特征。例如，ext2、ext3 和 ext4 文件系统用 mount(l)命令的一个选领来控制是否支持此特征。但是.Linux的 UFS 文件 系统实现则是不可选择的，新目录继承父目录的设置组 ID 位，这仿效了历史上 BSD 的实现。在 BSD系统中，新目录的组 ID 是从父目录继承的。

基于 BSD 的系统并不要求在目录间传递设里组 ID 位，因为不论设置组 ID 位如何，新创建的 文件和目录总是继承父目录的组 IDd 因为 FreeBSD 8.0和 Mac OS X 10.6.8是基于 4.4BSD的，它 们不要求继承设置组 ID 位。在这些平台上，新创建的文件和目录总是继承父目录的组 ID，这与 是否设置了设置组 ID 位无关。

早期的 UNIX 版本并没有 mkdir 函数，它是由 4.2BSD和 SVR3 引入的。在早期版本中，进 程要调用 mknod 函数创建一个新目录，但是只有超级用户进程才能使用 mknod 函数》为了避免 这一点，创建目录的命令 mkdir(l)必须由根用户拥有，而且对它设置了设置用户 ID 位。要通过 —个进程创建一个目录，必须用 system(3)函数调用 mkdir(l)命令，

mkdirat函数与 mkdir 函数类似。当押参数具有特殊值 AT^FDCWD或者 pathname 参数指 定了绝对路径名时，mkdirat与 mkdir 完全一样。否则，/rf参数是一个打开目录，相对路径名 根据此打开目录进行计算。

Q2E    用 rmdir 函数可以删除一个空目录。空目录是只包含。和.。这两项的目录■,

\#include <unistd.h>

int rmdir (const char * pathname):

返回值：若成功。返回 0；若出错。返回-1

如果调用此函数使目录的链接计数成为 0，并且也没有其他进程打开此目录，则释放由此目 录占用的空间。如果在链接计数达到 0 时，有一个或多个进程打开此目录，则在此函数返回前删 除最后一个链接及。和.。项。另外，在此目录中不能再创建新文件。但是在最后一个进程关闭它 之前并不释放此目录。(即使另一些进程打开该目录，它们在此目录下也不能执行其他操作。这 样处理的原因是，为了使 rmdir 函数成功执行，该目录必须是空的。)

###### 4.22读目录

对某个目录具有访问权限的任一用户都可以读该目录，但是，为了防止文件系统产生混乱， 只有内核才能写目录。回忆 4.5节，一个目录的写权限位和执行权限位决定了在该目录中能否创 建新文件以及删除文件，它们并不表示能否写目录本身。

目录的实际格式依赖于 UNIX 系统实现和文件系统的设计。早期的系统(如 V7)有一个比 较简单的结构：每个目录项是 16 个字节，其中 14 个字节是文件名，2个字节是 i 节点编号■，而 对于 4.2BSD，由于它允许更长的文件名，所以每个目录项的长度是可变的。这就意味着读目录的 程序与系统相关。为了简化读目录的过程，UNIX现在包含了一套与目录有关的例程，它们是 POSIX.1的一部分，很多实现阻止应用程序使用 read 函数读取目录的内容，由此进一步将应用 程序与目录格式中与实现相关的细节隔离》

\#include <dirent.h>

DIR *opendir (const char * pathname);

DIR *fdopendir (int fd};

两个函数返回值：若成功，返回指针；若出错，返回 NULL

struct dirent *readdir(DIR *dp、；

返回值：若成功，返回指针：若在目录尾或出错，返回 NULL

void rewinddir (DIR *dp); int closedir(DIR *dp、；

返回值：若成功，返回 0:若出错，返回-1

long telldir (DIR *dp);

返回值：与分关联的目录中的当前位置

void seekdir(DIR *dp, long loc、；

fdopendir函数最早出现在 SUSv4 (Single UNIX Specification第 4 版)中，它提供了一种 方法，可以把打开文件描述符转换成目录处理函数需要的 DIR 结构。

telldir和 seekdir 函数不是基本 POSIX.1标准的组成部分。它们是 Single UNIX Specification中的 XSI 扩展，所以可以期望所有符合 UNIX 系统的实现都会提供这两个函数。

回忆一下，在图 1-3程序中(13命令的基本实现部分)使用了其中几个函数。

定义在头文件＜dirent.h＞中的 dirent 结构与实现有关。实现对此结构所做的定义至少包 含下列两个成员：

ino_t d_ino;    /* i-node number */

char d_name[];    /* null-terminated filename */

POSIX.1并没有定义 d_ino项，因为这是一个实现特征，但在 POSIX.1的 XSI 扩展中定义了 d_ino。POSIX.1在此结构中只定义了 d_name项。

注意，d_name项的大小并没有指定，但必须保证它能包含至少 NAME_MAX个字节(不包含 终止 null 字节，回忆图 2-15)。因为文件名是以 null 字节结束的，所以在头文件中如何定义数组 d_name并无多大关系，数组大小并不表示文件名的长度。

DIR结构是•一个内部结构，上述 7 个函数用这个内部结构保存当前正在被读的目录的有 关信息。其作用类似于 FILE 结构。FILE结构由标准 I/O库维护，我们将在第 5 章中对它进 行说明。

由 opendir 和 fdopendir 退回的指向 DIR 结构的指针由另外 5 个函数使用。opendir执 行初始化操作，使第一个 readdir 返回目录中的第一个目录项。DIR结钩由 fdopendir 创建 时，readdir返回的第一项取决于传给 fdopendir 函数的文件描述符相关联的文件偏移量。注 意，目录中各目录项的顺序与实现有关。它们通常并不按字母顺序排列。

幽实例

我们将使用这些对目录进行操作的例程编写一个遍历文件层次结构的程序，其目的是得 到如图 4-4中所示的各种类型的文件计数。图 4-22的程序只有一个参数，它说明起点路径名， 从该点开始递归降序遍历文件层次结构。Solaris提供了一个遍历此层次结构的函数 ftw(3), 对于每一个文件它都调用一个用户定义的函数。ftw函数的问题是：対于每一个文件，它都 调用 stat 函数，这就使程序跟随狩号链接。例如，如果从根目录(root)开始，并且有一个 名为/lib的符号链接，它指向/usr/lib，则所有在目录/usr/lib中的文件都会被计数两 次。为了纠正这一点，Solaris提供了另一个函数 nftw(3)，它具有一个停止跟随符号链接的 选项。尽管可以使用 nftw，但是为了说明目录例程的使用方法，我们还是编写了一个简单的 文件遍历程序。

在 SUSv4 中，nftw 包含在 XS1 选领中。FreeBSD 8.0, Linux 32.0, Mac OS X 10.6.8 以及 Solaris 10 都包括了该&数的实现。(在 SUSv4 中，ftw函数已被标记为弃用 a)基于 BSD 的 UNIX 系统则有另一个 函数 fts(3)，它提供类似的功能。该函数在 FreeBSD 8.0、Unux 32.0和 Mac OS X 10.6.8中是可用的。

\#include "apue.h" #include <dirent.h> #include <limits.h>

/* function type that is called for each filename */ typedef int Myfunc{const char *, const struct stat *, int);

static Myfunc myfunc;

static int myftw(char *, Myfunc *);

static int dopath{Myfunc *)；

static long nreg, ndir, nbllc, nchr, nfifo, nslink, nsock, ntot;

int main(int argc, char *argv[])

int    ret;

if (argc != 2)

err_quit("usage: ftw <starting-pathname>"); ret = myftw(argv[l], myfunc);    /* does it all */

ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock; if (ntot == 0)

ntot = 1;    /* avoid divide by 0; print 0 for all counts *Z

printf("regular files = %71d, %5.2f    nreg,

nreg*100.0/ntot);

printf("directories = %71d, %5.2f    ndir,

ndir*100.0/ntot);

printf("block special = %71d, %5.2f    nblk,

nblk*100.0/ntot);

printf{"char special = %71d, %5.2f    nchr,

nchr*100.0/ntot);

printf("FIFOs    = %71d, %5.2f    nfifo,

nfifo*100.0/ntot)；

printf("symbolic links = %71d, %5.2f %%\n", nslink, nslink*100.0/ntot);

printf("sockets    = %71d, %5.2f    nsock,

nsock*100.0/ntot);

exit(ret);

画»

/*

\*    Descend through the hierarchy, starting at "pathname".

\*    The caller's func() is called for every file.

\#define FTW_F 1 /* #define FTW_D 2 /* #define FTW_DNR 3 /* #define FTW_NS 4 /*

file other than directory */ directory */

directory that can't be read */ file that we can't stat */

static char *fullpath; /* contains full pathname for every file */ static size_t pathlen;

static int    /* we return whatever func () returns */

myftw{char *pathname, Myfunc *func)

t

fullpath = path_alloc(&pathlen); /* malloc PATH_MAX+1 bytes */ /* “Figure 2.16}) */

if (pathlen <= strlen(pathname)) { pathlen = strlen(pathname) * 2;

if { {fullpath = realloc(fullpath, pathlen)) = NULL) err_sys{"realloc failed");

}

strcpy(fullpath, pathname); return(dopath(func) };

/*

\*    Descend through the hierarchy, starting at "fullpath".

\*    If "fullpath" is anything other than a directory, we lstat() it,

\*    call func{), and return. For a directory, we call ourself

\*    recursively for each name in the directory.

*Z

static int    /* we return whatever func() returns */

dopath(Myfunc* func)

t

struct    stat    statbuf;

struct    dirent    *dirp;

DIR    *dp;

int    ret, n;

if (lstat(fullpath, Sstatbuf) < 0) /* stat error */ return(func(fullpath, Sstatbuf, FTW_NS));

if (S_ISDIR(statbuf.st_raode) == 0) /* not a directory */ return{func(fullpath, &statbuf, FTW_F));

/*

\*    it’s a directory. First call funcU for the directory,

\*    then process each filename in the directory.

*/

if ((ret = func(fullpath, &statbuf, FTW_D)) != 0) return(ret);

n = strlen(fullpath);

if (n + NAME_MAX + 2 > pathlen) { /* expand path buffer */ pathlen *= 2;

if {(fullpath = realloc(fullpath, pathlen)) == NULL) err_sys("realloc failed");

}

fullpath[n++] = '/'； fullpath[n] = 0;

if ((dp = opendir(fullpath)) == NULL) /* can't read directory *Z return(func(fullpath, Sstatbuf, FTW_DNR));

while ((dirp = readdir(dp)) != NULL) {

if (strcmp(dirp->d_name, ".") == 0    | |

strcmp(dirp->d_name,    == 0)

continue;    /* ignore dot and dot-dot */

strcpy (&fullpath[n], dirp->d_name)，- /* append name after "/" */ if {(ret = dopath(func))    != 0)    Z* recursive */

break; /* time to leave */

}

fullpath[n-11 = 0; /* erase everything from slash onward */ if (closedir(dp) < 0)

err_ret{"can't close directory %s", fullpath); return(ret);

}

static int

myfunc(const char ^pathname, const struct stat *statptr, int type)

switch (type) { case FTW_F:



switch (statptr->st_mode &



case S_IFREG: case S_IFBLK: case S_IFCHR: case S_IFIFO: case S_IFLNK:



nreg++; nblk++; nchr++; nfifo++; nslink++;



S_IFMT) { break; break;



break;

break;



break;



case S_IFSOCK:    nsock++; break;

case S—IFDIR: /* directories should have type = FTW_D ★/ err_dump("for S_IFDIR for %s", pathname);



break;

case FTW_D： ndir++; break;

case FTW_DNR：

err_ret("can't read directory %s", pathname); break;

case FTW_NS:

err_ret{"stat error for %s", pathname); break;

default:

err_dump("unknown type %d for pathname %s", type, pathname);

}

return(0);

LSS    图 4-22递归降序遍历目录层次结构，并按文件类型计数



在程序中，我们提供了比所要求的更多的通用性，这样做的目的是为了具体说明 ftw 和 nftw 函数 的应用。例如，函数 myfunc 总是退回 0，即使调用它的函数准备了处理非 0 返回也是如此。    ■

关于降序遍历文件系统的更多信息，以及在很多标准 UNIX 命令(如 find、Is、tar等) 中使用这种技术的情况，请参阅 Fowler、Korn和 Vo[1989]。

##### 4.23 函数 chdir、f chdir 和 getcwd

每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点(不以斜线开始的路 径名为相对路径名)。当用户登录到 UNIX 系统时，其当前工作目录通常是口令文件

(/etc/passwd)中该用户登录项的第 6 个字段-用户的起始目录(home directory)。当前工

作目录是进程的一个属性，起始目录则是登录名的一个属性。

进程调用 chdir 或 fchdir 函数可以更改当前工作目录。

\#include <unistd.h>

int chdir (const char * pathname、；

int fchdir (int fd);

两个函数的返回值：若成功，返回 0:若出错，返回-1

在这两个函数中，分别用汝 zwme 或打开文件描述符来指定新的当前工作目录。

实例

因为当前工作目录是进程的一个属性，所以它只影响调用 chdir 的进程本身，而不影响其 他进程（我们将在第 8 章更详细地说明进程之间的关系）。这就意味着图 4-23的程序并不会产生 我们可能希望得到的结果。

\#include "apue.h" int

main(void)

if (chdir("/tmp") < 0)

err_sys("chdir failed");

printf("chdir to /tmp succeededXn"); exit(0);

图 4 23 chdir函数实例    S3

如果编译图 4-23程序，并且调用其可执行目标代码文件 mycd，则可以得到下列结果：

$ pwd

/usr/lib

$ mycd

chdir to /tmp succeeded

$ pwd

/usr/lib

从中可以看出，执行 mycd 命令的 shell 的当前工作目录并没有改变，这是 shell 执行程序工作方 式的一个副作用。每个程序运行在独立的进程中，shell的当前工作目录并不会随着程序调用 chdir而改变。由此可见，为了改变 shell 进程自己的工作目录，shell应当直接调用 chdir 函数， 为此，cd命令内建在 shell 中。

因为内核必须维护当前工作目录的信息，所以我们应能获取其当前值。遗憾的是，内核 为每个进程只保存指向该目录 v 节点的指针等目录本身的信息，并不保存该目录的完整路 径名。

;    Linux内核可以确定完整路径名。完整路径名的各个组成部分分布在 mount 表和 dcache 表

中，然后进抒重新组装，比如在读取/proc/self/cwd符号链接时。

我们需要一个函数，它从当前工作目录（.）开始，用.。找到其上一级目录，然后读其目录 项，直到该目录项中的 i 节点编号与工作目录 i 节点编号相同，这样地就找到了其对应的文件名。 按照这种方法，逐层上移，直到遇到根，这样就得到了当前工作目录完整的绝对路径名。很幸运， 函数 getcwd 就提供了这种功能。

^include <unistd.h>

char *getcwd （char *buf, size_t size）;

返回值：若成功，返回 6 妒若出错，返回 NULL

必须向此函数传递两个参数，一个是缓冲区地址/>«/，另一个是缓冲区的长度 Jize （以字节为 单位）。该缓冲区必须有足够的长度以容纳绝对路径名再加上一个终止 null 字节，否则返回出错

（请回忆 2.5.5节中有关为最大长度路径名分配空间的讨论）。

丨 某些 getcwd 的早期实现允许第一个参数加*/为 NULL。在这种情况下，此函数调用 malloc 动态地分私 jize 字节數的空间。这不是 POSDC1 或 Single UNIX Specification的所属部分，应当避

I免使用。

、实例

图 4-24的程序将工作目录更改至一个指定的目录，然后调用 getcwd，最后打印该工作 目录。如果运行该程序，则可得

S ./a.out

cwd = /var/spool/uucppublic

_    $ la -1 /usr/spool

画 lrwxrwxrwx 1 root 12 Jan 31 07:57 /usr/spool -> ../var/spool

\#include "apue.h1*

int

main(void)

{

char *ptr; size_t size;

if (chdir("/usr/spool/uucppublic") < 0) err^sys("chdir failed");

ptr = path_alloc (ssize)，- /* our own function */ if (getcwd(ptr, size) == NULL)

err_sys("getcwd failed"); printf("cwd = %s\n", ptr); exit(0);

图 4-24 getcwd函数实例

注意，chdir跟随符号链接（正如我们希望的，如图 4-17中所示），但是当 getcwd 沿目录 树上溯遇到/var/spool目录时，它并不了解该目录由符号链接/usr/spool所指向。这是符 号链接的一种特性。

当一个应用程序需要在文件系统中返回到它工作的出发点时，getcwd函数是有用的。 在更换工作目录之前，我们可以调用 getcwd 函数先将其保存起来。在完成了处理后，就可 将所保存的原工作目录路径名作为调用参数传送给 chdir，这样就返回到了文件系统中的出 发点。

fchdir函数向我们提供了一种完成此任务的便捷方法。在更换到文件系统中的不同位置前， 无需调用 getcwd 函数，而是使用 open 打开当前工作目录，然后保存其返回的文件描述符。当 希望回到原工作目录时，只要简单地将该文件描述符传送给 fchdiro

4.24设备特殊文件

st_dev和 st_rdev这两个字段经常引起混淆，在 18.9节，我们编写 ttynarae 函数时，需 要使用这两个字段。有关规则很简单：

•每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是 基本系统数据类型 dev_t。主设备号标识设备驱动程序，有时编码为与其通信的外 设板；次设备号标识特定的子设备。回忆图 4-13, —个磁盘驱动器经常包含若干个 文件系统。在同一磁盘驱动器上的各文件系统通常具有相同的主设备号，但是次设 QKI 备号却不同。

•我们通常可以使用两个宏：major和 minor 来访同主、次设备号，大多数实现都定义这 两个宏。这就意味着我们无需关心这两个数是如何存放在 dev_t对象中的。

= 早期的系统用 16 位整型存放设备号：8位用于主设备号，8位用于次设备号。FreeBSD 8.0 ；和 Mac OS X 10.6.8使用 32 位整型，其中 8 位表示主设备号，24位表示次设备号。在 32 位系 J统中，Solaris 10用 32 位整型表示 dev_t，其中 14 位用于主设备号，18位用于次设备号。在 j 64位系统中，Solaris 10用 64 位整型表示 dev_t，主设备号和次设备号各用其中的 32 位表示。

在 Linux 3.2.0上，虽然 dev_t是 64 位整型，但其中只有 12 位用于主设备号，20位用于次设 备号。

POSIX.1说明（1时_七类型是存在的，但没有定义它包含什么，或如何取得其内容。大多数实 ；现定义了宏 major 和 minor，但在哪一个头文件中定义它们则与实现有关。基于 BSD 的 UNIX 丨系统将它们定义在＜sys/types＞中。Solaris在＜3?5/1）1]«167.11＞中定义了它们的丞教原型，

因为在＜sys/sysmacros .h＞中的宏定义都弃用了。Linux将它 4 门定义 S＜sys/sysmacros .h＞

中，而该头文件又包含在＜sys/type.h＞*o

•系统中与每个文件名关联的 st_dev值是文件系统的设备号，该文件系统包含了这一文 件名以及与其对应的 i 节点。

•只有字符特殊文件和块特殊文件才有 st_rdev值。此值包含实际设备的设备号。

I实例

图 4-25的程序为每个命令行参数打印设备号，另外，若此参数引用的是字符特殊文件或块特 殊文件，则还打印该特殊文件的 st_rdev值。

\#include "apue.h"

\#ifdef SOLARIS

\#include ＜sys/mkdev.h＞

\#endif int

main(int argc, char *argv[])

int    i;

struct stat buf;

for (i = 1; i < argc; i++) { printf ("%s: ", argv[i]) if (stat(argv[i], &buf) < 0) {

err_ret("stat error"); continue;

1

printf("dev = %d/%d", major(buf.st_dev), minor(buf.st^dev)); if (S_ISCHR(buf.st_mode) I| S_ISBLK(buf.st_mode))    {

printf (" (%s) rdev = %d/%d",

(S_ISCHR(buf.st_mode)) ? "character" : "block", major(buf.st_rdev), minor(buf.st_rdev));

}

printf ("\n");

}

exit{0);

图 4-25 打印 st_dev 和 st_rde▽值 在 Linux 上运行此程序得到下面的输出：

$ . /a.out / Zhnw/sar /dav/tty[01]

/: dev = 8/3

Zhome/sar： dev = 8/4

/dev/ttyO: dev = 0/5 (character) rdev = 4/0

/dev/ttyl: dev = 0/5 (character) rdev = 4/1

$ nount    哪些目录安装在哪些设备上？

/dev/sda3 on / type ext3 (rw, errors=remount-ro, coirunit=0) /dev/sda4 on /home type ext2 (rw,commit=0)

| $ Is -1 /<tev/tty[01] | /dev/sda[34] |      |      |      |            |       |           |
| --------------------- | ------------ | ---- | ---- | ---- | ---------- | ----- | --------- |
| brw-rw--              | —1           | root | 8,   | 3    | 2011-07-01 | 11:08 | /dev/sda3 |
| brw-rw--              | ___ i        | root | 8,   | 4    | 2011-07-01 | 11:08 | /dev/sda4 |
| crw--w--              | —1           | root | 4,   | 0    | 2011-07-01 | 11:00 | /dev/ttyO |
| crw-----              | —1           | root | 4,   | 1    | 2011-07-01 | 11:08 | /dev/ttyl |

传给该程序的前两个参数是目录（/和/home/sar），后两个参数是设备名/dev/tty [01]。（我 们用 shell 正则表达式语言以缩短所需的输入量。shell将字符串/dev/tty[01]扩展为 /dev/ttyO /dev/ttyl。）

我们期望设备是字符特殊文件。从程序的输出可见，根目录和/home/sar目录的设备号不 同，这表示它们位于不同的文件系统中。运行 mOUnt（l）命令可以证明了这一•点。

然后用 Is 命令査看由 mount 命令报告的两个磁盘设备和两个终端设备，这两个磁盘设备是 块特殊文件，而两个终端设备是字符特殊文件。（通常，只有那些包含随机访问文件系统的设备 类型是块特殊文件设备，如硬盘驱动器、软盘驱动器和 CD-ROM等，UNIX的早期版本支持磁带 存放文件系统，但这从未广泛使用过。）

注意，两个终端设备（st_dev）的文件名和 i 节点在设备 0/5上（devtmpfs伪文件系统， 它实现了/dev文件系统），但是它们的实际设备号是 4/0和 4/1。

4.25文件访问权限位小结

我们己经说明了所有文件访问权限位，其中某些位有多种用途。图 4-26列出了所有这些权限 位，以及它们对普通文件和目录文件的作用=

最后 9 个常量还可以分成如下 3 组：

S_IRWXU = S_IRUSR I S_IWUSR I S.IXUSR S_IRWXG = S_IRGRP I S_IWGRP I S_IXGRP S^IRWXO = S_IROTH I S.IWOTH I S_IXOTH

| 常量    | 说明       | 对普通文件的影响                                             | 对目录的影响                                  |
| ------- | ---------- | ------------------------------------------------------------ | --------------------------------------------- |
| S_ISUID | 设置用户 ID | 执行吋设置有效用户 ID                                         | （未使用）                                    |
| S_ISGID | 设置组 ID   | 若组执行位设置，则执行时设置有效 组 ID:否则使强制性锁起作用（若支持） | 将在目录中创建的新文件的组 ID 设置为目录的组 ID |
| S ISVTX | 粘着位     | 在交换区缓存程序正文（若支持）                               | 限止在目录中删除和重命名文件                  |
| S_IRUSR | 用户读     | 许可用户读文件                                               | 许可用户读目录项                              |
| S_IWUSR | 用户写     | 许可用户写文件                                               | 许可用户在目录中删除和创建文件                |
| S„IXUSR | 用户执行   | 许可用户执行文件                                             | 许可用户在目录中概给定蹄径名                  |
| S_IRGRP | 组读       | 许可组读文件                                                 | 许可组读目录项                                |
| S_IWGRP | 组写       | 许可组写文件                                                 | 许可组在目录中删除和创建文件                  |
| S IXGRP | 组执行     | 许可组执行文件                                               | 许可组在目录中搜索给定路径名                  |
| S_IROTH | 其他读     | 许可其他读文件                                               | 许可其他读目录项                              |
| S_IWOTH | 其他写     | 许可其他写文件                                               | 许可其他在目录中刪除和创建文件                |
| S IXOTH | 其他执行   | 许可其他执行文件                                             | 许可其他在冃录中触给定路径名                  |

图 4,26文件访问权限位小结

##### 4.26小结

本章内容围绕 stat 函数，详细介绍了 stat结构中的每一个成员。这使我们对 UNIX 文件 和目录的各个属性都有所了解。我们讨论了文件和目录在文件系统中是如何设计的以及如何使用® 文件系统命名空间。对文件和目录的所有属性以及对文件和目录进行操作的所有函数的全面了 解，对于 UNIX 编程是非常重要的。

习题

4.1用 stat 函数替换图 4-3程序中的 lstat 函数，如若命令行参数之一是符号链接，会发生 什么变化？

4.2如果文件模式创建屏蔽字是 777 （八进制），结果会怎样？用 shell 的 umask 命令验证该结果。 4.3关闭一个你所拥有文件的用户读权限，将导致拒绝你访问自己的文件，对此进行验证。

4.4创建文件 foo 和 bar 后，运行图 4-9的程序，将发生什么情况？

4.5    4.12节中讲到一个普通文件的大小可以为 0，同时我们又知道 st.size字段是为目录或符 号链接定义的，那么目录和符号链接的长度是否可以为 0?

4.6    编写一个类似 cp（l）的程序，它复制包含空洞的文件，但不将字节 0 写到输出文件中去。

4.7    在 4.12节 Is 命令的输出中，core和 core, copy的访问权限不同，如果创建两个文件时 umask没有变，说明为什么会发生这种差别。

4.8    在运行图 4-16的程序时，使用了 df（l）命令来检查空闲的磁盘空间。为什么不使用 du（l） 命令？

4.9图 4-20中显示 unlink 函数会修改文件状态更改时间，这是怎样发生的？

4.10 4.22节中，系统对可打开文件数的限制对 myftw 函数会产生什么影响？

4.11在 4.22节中的 myftw 从不改变其目录，对送种处理方法进行改动：每次遇到一个目录就用 其调用 chdir，这样每次调用 lstat 时就可以使用文件名而非路径名，处理完所有的目录

项后执行 chdir(» . .    》比较这种版本的程序和书中程序的运行时间。

4.12每个进程都有一个根目录用于解析绝对路径名，可以通过 chroot 函数改变根目录。在手 册中査阅此函数。说明这个函数什么时候有用。

4.13如何只设置两个时间值中的一个来使用 utimes 函数？

4.14 有些版本的 finger(l)命令输出 “New mail received …”和 “unread since ...”，其中..。表示 相应的日期和时间，程序是如何决定这些日期和时间的？

4.15用 cpio(l)和 tar(l)命令检査档案文件的格式(请参阅《UNIX程序员手册》第 5 部分中的 说明)。3个可能的时间值中哪几个是为每一个文件保存的？你认为文件复原时，文件的访 问时间是什么？为什么？

4.16    UNIX系统对目录树的深度有限制吗？编写一个程序循环，在每次循环中，创建目录，并将 该目录更改为工作目录。确保叶节点的绝对路径名的长度大于系统的 PATH_MAX限制。可 以调用 getcwd 得到目录的路径名吗？标准 UNIX 系统工具是如何处理长路径名的？对目 录可以使用 tar 或 cpio 命令归档吗？

4.17    3.16节中描述了/dev/fd特征。如果每个用户都可以访问这些文件，则其访问权限必须为 rw-rw-rw-o有些程序创建输出文件时，先删除该文件以确保该文件名不存在，忽略返回码。 unlink (path);

if ( (fd = creat(path, FILE^MODE)) < 0) err_sys(...);

® 如果 path 是/dev/fd/1，会出现什么情况？
