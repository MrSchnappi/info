---
title: 03 背包问题
toc: true
date: 2019-07-01
---
8.3 背包问题
本节来看一个景点的动态规划问题—背包问题。
8.3.1 问题描述
有 N 个重量为 w1,w2,...,wn、价值为 v1,v2,...,vn的物品和一个承重量为 W 的背包，求让背包里装入的物品具有最大的价值总和的物品子集。
这就是经典的背包问题，可以用动态规划算法进行求解。
总体思路：为了设计一个动态规划算法，需要推导出一个递推关系，用较小子实例的解的形式来表示背包问题的实例的解。
首先考虑一个有前 i（1 ≤ i ≤ N）个物品定义的实例，物品的重量分别为 w1,w2,...,wi，价值为 v1,v2,...,vi，背包目前的承重量为 j（1 ≤ j ≤ W）。设 F（i,j）为组成该实例最优解的物品的总价值，也就是说，是能够放进承重量为 j 的背包中的前 i 个物品中最有价值的子集的总价值。
在这里，可以把前 i 个物品中能够放进承重量为 j 的背包中的子集分为两种类别：包括第 i 个物品的子集和不包括第 i 个物品的子集。于是我们可以得到以下结论：
根据定义，在不包括第 i 个物品的子集中，最优子集的价值是 F（i-1,j）。
在包括第 i 个物品的子集中（此时，j-wi≥ 0），最优子集是由该物品和前 i-1个物品中能够放进承重量为 j-wi的背包的最优子集组成。这种最优子集的总价值等于 vi+F（i-1,j-wi）。
因此，在前 i个物品中，最优解的总价值等于以上两种情况中求得的价值的较大值，以上便是该问题的最优子结构。
当然，如果第 i 个物品不能放进背包，从前 i 个物品中选出的最优子集的总价值即等于从前 i-1个物品中选出的最优子集的总价值。于是，可以得到以下递推式，即状态转移函数：
同时，可以获得背包问题的边界为：
至此，该问题的边界、最优子结构和状态转移函数均已求出。
我们的目标是求 F（N,W），即给定 N 个物品中能够放进承重量为 W 的背包的最大总价值以及得到最大总价值的物品组合。
8.3.2 问题实例
根据上述思路，我们来思考以下实例：
假设物品的数量为 4，背包的承重量为 8，各个物品的重量和价值如表 8.13所示。
表 8.13 重量价值表
1.原理
动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的目的。
但不同的是，分治法在子问题和子子问题上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案记录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间。所以在问题满足最优性原理之后，用动态规划算法解决问题的核心就在于填表，表填写完毕，最优解也


就找到了。
2.过程
把背包问题抽象化（X1,X2,…,Xn，其中 Xi 取 0 或 1，表示第 i 个物品选或不选）,Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积（重量）。
建立模型，即求 max（V1X1+V2X2+…+VnXn）。
约束条件，W1X1+W2X2+…+WnXn<capacity。
定义 V（i,j），当前背包容量 j，前 i个物品最佳组合对应的价值。
最优性原理是动态规划的基础。最优性原理是指不依赖于初始状态和初始决策，对于属于最优性决策中的任何一环，其中的任何一个决策都是最优决策。判断该问题是否满足最优性原理，采用反证法证明：
假设（X1,X2,…,Xn）是背包问题的最优解，则有（X2,X3,…,Xn）是其子问题的最优解，假设（Y2,Y3,…,Yn）是上述问题的子问题的最优解，则理应有（V2Y2+V3Y3+…+VnYn）+V1X1＞（V2X2+V3X3+…+VnXn）+V1X1。
而（V2X2+V3X3+…+VnXn）+V1X1=（V1X1+V2X2+…+VnXn），则有（V2Y2+V3Y3+…+VnYn）+V1X1＞（V1X1+V2X2+…+VnXn）。
该式子说明（X1,Y2,Y3,…,Yn）才是该背包问题的最优解，这与最开始的假设（X1,X2,…,Xn）是背包问题的最优解相矛盾，故背包问题满足最优性原理。
寻找递推关系式，面对当前商品有两种可能性：
包的容量比该商品体积小，装不下，此时的价值与前 i-1个的价值是一样的，即 V（i,j）=V（i-1,j）。
还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即 V（i,j）=max｛V（i-1,j）,V（i-1,j-w（i））+v（i）｝。
其中 V（i-1,j）表示不装，V（i-1,j-w（i））+v（i）表示装了第 i 个商品，背包容量减少 w（i），但价值增加了 v（i）。
由此可以得出递推关系式：
j<w（i）V（i,j）=V（i-1,j）
j>=w（i）V（i,j）=max｛V（i-1,j）,V（i-1,j-w（i））+v（i）｝
填表，首先初始化边界条件，如表 8.14所示，V（0,j）=V（i,0）=0。
表 8.14 初始化边界条件
然后一行一行地填表，
如，i=1,j=1,w（1）=2,v（1）=3，有 j<w（1），故 V（1,1）=V（1-1,1）=0。
又如 i=1,j=2,w（1）=2,v（1）=3，有 j=w（1），故 V（1,2）=max｛V（1-1,2）,V（1-1,2-w（1））+v（1）｝=max｛0,0+3｝=3。
如此下去，填到最后一个，i=4,j=8,w（4）=5,v（4）=6，有 j>w（4），故 V（4,8）=max｛V（4-1,8）,V（4-1,8-w（4））+v（4）｝=max｛9,4+6｝=10。所以填完如表 8.15所示。
表 8.15 填表
填完表格，最优解即是 V（number,capacity）=V（4,8）=10，但还不知道解由哪些商品组成，故要根据最优解回溯找出解的组成，根据填表的原理有如下的寻解方式：
V（i,j）=V（i-1,j）时，说明没有选择第 i 个商品，则回到 V（i-1,j）。


V（i,j）=V（i-1,j-w（i））+v（i）时，说明装了第 i 个商品，该商品是最优解组成的一部分，随后我们得回到装该商品之前，即回到 V（i-1,j-w（i））。
一直遍历到 i=0为止，所有解的组成都会找到。
如上例子，
最优解为 V（4,8）=10，而 V（4,8）!=V（3,8）却有 V（4,8）=V（3,8-w（4））+v（4）=V（3,3）+6=4+6=10，所以第 4 件商品被选中，并且回到 V（3,8-w（4））=V（3,3）。
有 V（3,3）=V（2,3）=4，所以第 3 件商品没被选择，回到 V（2,3）。
而 V（2,3）!=V（1,3）却有 V（2,3）=V（1,3-w（2））+v（2）=V（1,0）+4=0+4=4，所以第 2 件商品被选中，并且回到 V（1,3-w（2））=V（1,0）。
有 V（1,0）=V（0,0）=0，所以第 1 件商品没被选择。
到此，背包问题已经解决，如图 8.5所示，利用动态规划算法解决此问题的效率即是填写此张表的效率，所以动态规划的时间效率为 O（number*capacity）=O（n*c），由于用到二维数组存储子问题的解，所以动态规划的空间效率为 O（n*c）。
图 8.5 问题解决状态示意图
为了提升算法的空间效率，可以进行以下优化：
空间优化，每一次 V（i）（j）改变的值只与 V（i-1）（x）{x:1...j}有关，V（i-1）（x）是前一次 i 循环保存下来的值。
因此，可以将 V 缩减成一维数组，从而达到优化空间的目的，状态转移方程转换为 B（j）=max{B（j）,B（j-w（i））+v（i）}。
并且，状态转移方程，每一次推导 V（i）（j）都是通过 V（i-1）（j-w（i））来推导的，所以一维数组中 j 的扫描顺序应该从大到小（capacity到 0），否则前一次循环保存下来的值将会被修改，从而造成错误。
同样以上述例子中 i=3时来说明，有：
i=3,j=8,w（3）=4,v（3）=5，有 j>w（3），则 B（8）=max｛B（8）,B（8-w（3））+v（3）｝=max｛B（8）,B（4）+5｝=max｛7,4+5｝=9。
j--即 j=7，有 j>w（3），则 B（7）=max｛B（7）,B（7-w（3））+v（3）｝=max｛B（7）,B（3）+5｝=max｛7,4+5｝=9。
j--即 j=6，有 j>w（3），则 B（6）=max｛B（6）,B（6-w（3））+v（3）｝=max｛B（6）,B（2）+5｝=max｛7,3+5｝=8。
j--即 j=5，有 j>w（3），则 B（5）=max｛B（5）,B（5-w（3））+v（3）｝=max｛B（5）,B（1）+5｝=max｛7,0+5｝=7。
j--即 j=4，有 j=w（3），则 B（4）=max｛B（4）,B（4-w（3））+v（3）｝=max｛B（4）,B（0）+5｝=max｛4,0+5｝=5。
j--即 j=3，有 j<w（3），继续访问数组会出现越界，所以本轮操作停止，B（0）到 B（3）的值保留上轮循环（i=2时）的值不变，进入下一轮循环 i++。
如果 j 不逆序而采用正序 j=0...capacity，如表 8.16和表 8.17所示，当 j=8时应该有 B（8）=B（8-w（3））+v（3）=B（4）+5，然而此时的 B（4）已经在 j=4的时候被修改过了，原来的 B（4）=4，现在 B（4）=5，所以计算得出 B（8）=5+5=10，显然这与正确答案不符；所以该一维数组后面的值需要前面的值进行运算再改动，如果正序遍历，则前面的值将有可能被修改掉从而造成后面数据的错误；相反如果逆序遍历，先修改后面的数据再修改前面的数据，此种情况就不会出错了。
表 8.16 i取值为 2 和 3 时的情况


表 8.17 j=0...capacity的取值情况
然而不足的是，虽然优换了动态规划的空间，但是该方法不能找到最优解的解组成，因为动态规划寻找解组成必须要在确定了最优解的前提下再往回找解的构成，而优化后的动态规划只用了一维数组，之前的数据已经被覆盖掉，没办法寻找，所以两种方法各有优缺点。
8.3.3 最终代码
背包问题的动态规划求解代码如代码 8.3所示。
代码 8.3 背包问题的动态规划求解
输出的结果为：
最大价值为：15
选择的物品为：
第 0 个，第 1 个，第 4 个
