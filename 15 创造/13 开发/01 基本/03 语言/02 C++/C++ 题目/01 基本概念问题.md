---
title: 01 基本概念问题
toc: true
date: 2018-08-29
---


#### Q 30 :

题目：
下面有关继承、多态、组合的描述，说法**错误**的是：

答案:
继承可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
覆盖是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同

解答:
考察继承、多态概念。
1. 父类只有非 private 的部分才能被子类继承访问。<span style="color:red;">嗯。</span>
2. 重载（overload）：函数名相同 、函数参数不同、 必须位于同一个域（类）中。
3. 覆盖（override）：函数名相同 、函数参数相同、 分别位于派生类和基类中（虚函数）。<span style="color:red;">嗯，这个是覆盖，与重载还是不同的，这一点以前看的时候还是没有怎么注意，现在又明确了些。</span>





#### Q 43 :

题目：

以下描述正确的是：

答案:

虚函数不能是内联函数

父类的析构函数是非虚的，但是子类的析构函数是虚的，delete子类对象指针会调用父类的析构函数

解答:
1. 虚函数不能是内联函数（编译时展开，必须有实体），不能是静态函数（属于自身类，不属于对象，而虚函数要求有实体），不能是构造函数（尚未建立虚函数表）。
2. delete子类对象是一定会调用父类的析构函数的先调用子类的析构函数然后调用父类的析构函数。

#### Q 52 :

题目：
下列说法错误的有：

答案：
在类方法中可用 this 来调用本类的类方法。
在类方法中只能调用本类中的类方法。
在类方法中绝对不能调用实例方法。

解答：
1. 成员方法又称为实例方法，静态方法又称为类方法。
2. 类方法（静态方法）不属于特定的类，没有 this 指针。
3. 可以通过类名作用域的方式调用 ClassName::fun()。
4. 类中申请一个类对象或者参数传递一个对象或者指针都可以调用实例方法。





#### Q 57 :

题目：
关于内联函数正确的是：

答案：
在所有类说明中内部定义的成员函数都是内联函数

解答：
考察内联函数。
1. 见答案。
2. 使用内联函数的地方会在编译阶段用内联函数体替换掉。



#### Q 66 :

题目：
在 C++面向对象编程语言中，以下阐述不正确的是：

答案：
接口中可以用虚方法
接口中可以包含已经实现的方法

解答：
考察 C++抽象类。
1. 接口是一个概念，它在 C++中用抽象类来实现。
2. 抽象类必须是纯虚函数。


#### Q 33 :

题目：
#include 命令的功能是：

答案:
在命令处插入一个文本文件

解答:
1. "#include"在命令处插入，插入文本过程为预处理过程。<span style="color:red;">之前不清楚，这个 #include 在处理的时候是直接把对应的文本加入到这个地方来吗？</span>








#### Q 73 :

题目：
C++ 中 32 位单精度浮点数能表示的十进制有效数字是多少位：

答案：
7

解答：
考察浮点数表示。
1. float浮点数含有 1bit 符号位，8bit阶码，23bit位尾数，加上隐藏位的 1，实际可直接表示的数在 2^24以内。
2. float可以表示的十进制有效数字 7 位，double为 16 位。





#### [Q 77](http://www.cnblogs.com/always-chang/p/6107437.html) :

题目：
关于浅复制和深复制的说法，下列说法正确的是：

答案：
浅层复制：只复制指向对象的指针，而不复制引用对象本身。
深层复制：复制引用对象本身。
如果是深拷贝，修改一个对象不会影响到另外一个对象。

解答：
考察深拷贝和浅拷贝。
1. 对象里有指针时，浅拷贝只拷贝指针字面值，并不拷贝指针指向的内容。
2. 深拷贝会重新分配一块空间，并把被拷贝对象中指向的数据逐一复制过去。
3. 对象中有指针时，使用深拷贝。
4. 因为拷贝者和被拷贝里的指针指向同一区域，所以任意一个对数据的修改都会影响到另一个。
