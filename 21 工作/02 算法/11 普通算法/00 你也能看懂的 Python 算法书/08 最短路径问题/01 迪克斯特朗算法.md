---
title: 01 迪克斯特朗算法
toc: true
date: 2019-07-01
---
9.1 迪可斯特朗算法
小朗朗想坐公交车从 A 站到 F 站，如图 9.1所示，但他看着下面的公交车线路图有些眼花，不知道怎么坐车距离最短。这时，他想到了迪可斯特朗算法。
迪可斯特朗算法（Dijkstra's algorithm），又被译为戴克斯特拉算法，它主要用于解决有向图的最短路径问题。输入边的权重和一个起点，迪可斯特朗算法能够得出从该起点到任何其他节点的最短路径。从图中的某个顶点出发到达另外一个顶点所经过的边的权重和最小的一条路径，称为最短路径。
图 9.1 公交车线路图注意：权重不能为负。
它的发明者，艾兹格·迪可斯特朗（Edsger W.Dijkstra），是一位荷兰计算机科学家。他在二十分钟内，没有用纸和笔，只靠头脑就“想”出了现在的迪可斯特朗算法。
最初，迪可斯特朗想解决的问题是：如果我有荷兰 64 个城市的交通网络图，怎么样能让计算机找出任意两个城市之间的最短路径呢？20分钟后，迪可斯特朗算法诞生，它完美地解决了这个问题。现在，迪可斯特朗算法被广泛地应用在地铁、公交车，以及飞机的路线查询系统中。
9.1.1 术语释义
如果你对图不是很熟悉的话，可以先通过表 9.1了解一些关于图的基本术语。
表 9.1 术语释义
9.1.2 问题示例：最短公交线路
回到小朗朗的问题，先来观察一下上面的图 9.1。这个公交车系统包括 6 个站点（分别用字母 A、B、C、D、E和 F 来表示）和连接这些车站的 9 条边。图中每条边上都标着距离，这里的距离就是权重。另外，每条边都是双向的，可以从一个车站到另一个车站，也可以从那一个车站回到这个车站。
迪可斯特朗算法的基本概念是，如果设定一个车站为起点，那么算法能够找出一个公共交通系统中从该车站到任意其他车站的最短距离路线。迪可斯特朗算法的主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。下面来分步介绍一下这个算法。

9.1.3 图与节点的定义
首先，看一下图的定义，一个图由节点和连接这些节点的边组成。
接下来看一下节点的定义。
对于每个节点，需要存储到目前为止从起点 A 到这个节点的最短距离（距离值）。另外，除了距离值，每个节点还需要存储它的前任节点（predecessor），也就是目前最短距离路线中它之前的那个节点。只有这样，最后才能原路返回到起点。
9.1.4 把图用代码“画”出来
遵循以上定义，创建图 9.1所示的实例。
9.1.5 算法核心：两个节点集合
接下来，需要定义两个节点集合：临时（temporary）节点集合和永久（permanent）节点集合。临时节点集合用于存储距离值和改变空间的节点；永久节点集合用于存储距离值已经固定的节点。在算法起始，临时集合只存放起点 A，永久集合则为空。来看一下代码：
9.1.6 算法核心：循环
创建完图的实例、永久节点集合和临时节点集合后，开始运行算法。迪可斯特朗算法一直循环两个步骤，和贪心算法很像，它每循环一次都确保局部最优解。步骤 1：找到临时节点集合中距离值最小的节点，把它迁移到永久集合里。
这么做的逻辑是什么？想一想，临时节点集合里距离值最小的节点肯定已经找到了最短路线，因为临时节点集合里任何其他节点的距离值都比它的大或者和它一样，所以如果改变路线的话它的最短距离值只会增大。


因此，可以确认它的距离值不会再减少。步骤 2：检查该节点的相邻节点集合。如果相邻节点（neighbour）不属于永久集合，则尝试更新其距离值，一旦更新成功便把该相邻节点加入临时节点集合。
循环步骤 1 与步骤 2，直至临时节点集合为空。当所有节点都被框起来时，循环终止。这代表所有节点都找到了最小距离值与最短路线。来看一下代码：
9.1.7 输出路线
从终点回溯到起点就可以得到最短路线，这也是程序的最后一步。我们想要的输出结果是一个节点集合，节点以最短路线中的顺序展现。以下代码展示了这一步骤：
9.1.8 通过示例理解算法
如果你觉得看代码不是很明白，下面在示例图上模拟一遍思路，这样你就会对这个算法有一个比较透彻的理解。如图 9.2所示，用黑框代表存放在永久集合里的节点。每一次循环，都需要找到临时节点集合里距离值最小的节点，并把它迁移到永久集合里（用黑框框起来）。因为在算法起始，只有起点 A 在临时节点集合里，所以起点 A 就是第一次循环时临时节点集合里距离值最小的节点。
图 9.2 第一次循环
接着，检查节点 A 的相邻节点集合{B,C,E}。记住，如果相邻节点属于永久集合，则跳过；如果相邻节点不属于永久集合，则尝试更新其距离值，一旦更新成功就把该相邻节点加入临时节点集合。
A的相邻节点 B、C和 E 都不属于永久集合，所以可以尝试更新其距离值。如果经过 A 的路线距离值比原本距离值小，则更新距离值。更新距离值的过程有一个专业术语叫作“松弛”。这里拿节点 B 来举例。节点 B 的原本距离值理论上无限大，为最大值，经过 A 的话，B的距离值是 10，所以更新它的距离值，并且设定其前任节点为



节点 A。另外，把节点 B 加入临时节点集合。类似的，如图 9.3所示，更新 C 和 E 的距离值、前任节点，并把它们加入临时节点集合。
图 9.3 更新 B、C、E的距离值
现在，临时节点集合为{B,C,E}，因为临时节点集合不为空，所以循环步骤 1 与步骤 2。此时，临时节点集合中距离值最小的节点为 B，所以把它迁移到永久集合里，如图 9.4所示。
图 9.4 第二次循环
重复第一次循环时的步骤，检查节点 B 的相邻节点集合{A,D,E}。其中，A属于永久集合，不属于永久集合的相邻节点是 D 和 E。对比新老距离值，应该更新节点 D 和节点 E 的距离值，并设定它们的前任节点为节点 B，如图 9.5所示。
图 9.5 更新 D 和 E 的距离值
专业一点说，A节点到 D 节点的路程，通过边 AB 松弛成功；A节点到 E 节点的路程，通过边 AE 松弛成功。这便是迪可斯特朗算法的主要思想：通过“边”来松弛起始节点到其余各个节点的路程。接着，把节点 D 和节点 E 加入临时节点集合。注意：虽然节点 E 已经在临时节点集合中，不过集合的特性是不复制。
就这样，在临时节点集合不为空的情况下，一直循环步骤 1 与步骤 2。当所有节点都被框起来时，循环终止。那么，小朗朗想得到从 A 到 F 的最短距离路线。通过前任节点集合，他知道 F 站之前是 D 站，D站之前是 B 站，B站之前是 A 站。所以反过来，小朗朗得到的最短路线是 A—B—D—F，如图 9.6所示。
图 9.6 最终输出的最短距离路线
9.1.9 完整代码展示
最短距离路线算法的完整代码如代码 9.1所示。



代码 9.1 利用迪可斯特朗算法解决图的最短路线问题
9
