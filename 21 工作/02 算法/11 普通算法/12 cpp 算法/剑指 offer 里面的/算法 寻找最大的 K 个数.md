---
title: 算法 寻找最大的 K 个数
toc: true
date: 2018-06-11 08:14:54
---


# 相关






  1. [【编程之美】读书笔记：寻找最大的 K 个数](http://blog.csdn.net/xiaoding133/article/details/8037086)


  2. [寻找第 K 大的数](http://blog.chinaunix.net/uid-20196318-id-189514.html)


  3. [O(N)的时间寻找最大的 K 个数](http://www.cnblogs.com/luxiaoxun/archive/2012/08/06/2624799.html)




## 可以补充进来的






  * **还没有仔细整理，要整理下。**





* * *





# INTRODUCTION






  * aaa




# 问题


查找大量无序元素中最大的 K 个数。




# 方法汇总






  * 方法一：常规解法，先排序 (时间复杂度为 O(N*logN) )


  * 方法二：利用快速排序原理 (时间复杂度 O(N*logK) ) (掌握)


  * 方法三：利用最小堆的原理 (时间复杂度为 O(N*logK) )  (掌握)


  * 方法四：二分法 (在实际应用中效果不佳)


  * 方法五：用空间换取时间的方法





# 方法一：常规解法，先排序


首先，我们看看方法 1：

该解法是大部分能想到的，也是第一想到的方法。

假设数据量不大，可以先用快速排序或堆排序，他们的平均时间复杂度为 O(N*logN)，然后取出前 K 个，时间复杂度为 O(K) ，总的时间复杂度为 O(N*logN)+O(K)。

当 K=1时，上面的算法的时间复杂度也是 O(N*logN)。

上面的算法是把整个数组都进行了排序，而原题目只要求最大的 K 个数，并不需要前 K 个数有限，也不需要后 N-K 个数有序。可以通过部分排序算法如选择排序和交换排序，把 N 个数中的前 K 个数排序出来，复杂度为 O(N*K)，选择哪一个，取决于 K 的大小，在 K (K<logN) 较小的情况下，选择部分排序。




# **方法二：（掌握）**避免对前 K 个数进行排序来获取更好的性能（利用快速排序的原理）。


假设 N 个数存储在数组 S 中，从数组中随机找一个元素 X ，将数组分成两部分 Sa 和 Sb 。Sa中的元素大于等于 X，Sb 中的元素小于 X 。

出现如下两种情况：




  * **若 Sa 组的个数大于或等于 K，则继续在 sa 分组中找取最大的 K 个数字 。**


  * **若 Sa 组中的数字小于 K ，其个数为 T，则继续在 sb 中找取 K-T个数字 。**


一直这样递归下去，不断把问题分解成小问题，平均时间复杂度为 O(N*logK) 。**厉害呀**

代码如下：



















* * *





# COMMENT

